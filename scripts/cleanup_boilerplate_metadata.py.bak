#!/usr/bin/env python3
"""
Clean Up Boilerplate Task Metadata

Removes generic boilerplate quality_metadata from tasks that were auto-populated
with template data (smart filter criteria) instead of task-specific criteria.

Problem:
- 53 tasks have identical boilerplate metadata about "Users can filter results..."
- This causes false validation passes and lost traceability
- Metadata should be task-specific, not template-based

Solution (Option A - Reset to Empty):
- Set quality_metadata = '{}' for affected tasks
- Allows future agents to populate task-specific criteria
- Fast and clean (15 min)

Affected Task IDs (32 tasks):
517, 521, 525, 529, 530, 531, 532, 533, 536, 537, 538, 539, 546,
557, 598, 599, 601, 605, 606, 608, 609, 613, 617, 618, 619, 620,
621, 622, 623, 624, 625, 635

Usage:
    python scripts/cleanup_boilerplate_metadata.py
    python scripts/cleanup_boilerplate_metadata.py --dry-run
    python scripts/cleanup_boilerplate_metadata.py --task-ids 517,521,525
    python scripts/cleanup_boilerplate_metadata.py --verify
"""

import sys
import json
from pathlib import Path
from typing import List, Dict, Optional

# Add agentpm to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from agentpm.core.database.service import DatabaseService


# Known boilerplate patterns to detect
BOILERPLATE_PATTERNS = [
    "Users can filter results by at least five dimensions",
    "Filter selections persist across refresh and new sessions",
    "API returns results within 400ms p95 under load",
    "Tailwind config exposes utilities and component classes",
    "Smart filter JS unchanged and compatible",
]


class MetadataCleanup:
    """Clean up boilerplate quality_metadata from tasks"""

    def __init__(self, db_service: DatabaseService):
        self.db = db_service

    def detect_boilerplate(self, quality_metadata: str) -> bool:
        """Detect if quality_metadata contains boilerplate patterns"""
        if not quality_metadata or quality_metadata == '{}':
            return False

        try:
            metadata = json.loads(quality_metadata) if isinstance(quality_metadata, str) else quality_metadata

            # Check acceptance_criteria for boilerplate
            if 'acceptance_criteria' in metadata:
                criteria = metadata['acceptance_criteria']
                if isinstance(criteria, list):
                    for item in criteria:
                        # Handle both string and dict criteria
                        criterion_text = item.get('criterion', '') if isinstance(item, dict) else str(item)

                        # Check for boilerplate patterns
                        for pattern in BOILERPLATE_PATTERNS:
                            if pattern.lower() in criterion_text.lower():
                                return True

            # Check technical_approach for generic boilerplate
            if 'technical_approach' in metadata:
                approach = metadata['technical_approach']
                generic_approaches = [
                    "Outline core modules, data flow, and performance considerations",
                    "implementing the filters service",
                ]
                for generic in generic_approaches:
                    if generic.lower() in approach.lower():
                        return True

            return False

        except (json.JSONDecodeError, TypeError, AttributeError):
            return False

    def get_tasks_with_boilerplate(self, task_ids: Optional[List[int]] = None) -> List[Dict]:
        """Get tasks that have boilerplate metadata"""
        if task_ids:
            placeholders = ','.join('?' * len(task_ids))
            query = f"""
                SELECT id, name, quality_metadata
                FROM tasks
                WHERE id IN ({placeholders})
                AND quality_metadata IS NOT NULL
                AND quality_metadata != '{{}}'
            """
            params = tuple(task_ids)
        else:
            query = """
                SELECT id, name, quality_metadata
                FROM tasks
                WHERE quality_metadata IS NOT NULL
                AND quality_metadata != '{}'
            """
            params = ()

        with self.db.connect() as conn:
            cursor = conn.execute(query, params)
            rows = cursor.fetchall()

        # Filter for boilerplate
        tasks_with_boilerplate = []
        for row in rows:
            task_id, name, metadata = row
            if self.detect_boilerplate(metadata):
                tasks_with_boilerplate.append({
                    'id': task_id,
                    'name': name,
                    'metadata': metadata
                })

        return tasks_with_boilerplate

    def cleanup_task(self, task_id: int, dry_run: bool = False) -> Dict:
        """Reset quality_metadata to empty dict for a single task"""
        if dry_run:
            return {
                'success': True,
                'dry_run': True,
                'task_id': task_id,
                'action': 'Would reset quality_metadata to {}'
            }

        try:
            query = """
                UPDATE tasks
                SET quality_metadata = '{}'
                WHERE id = ?
            """
            with self.db.connect() as conn:
                conn.execute(query, (task_id,))
                conn.commit()

            return {
                'success': True,
                'task_id': task_id,
                'action': 'Reset quality_metadata to {}'
            }
        except Exception as e:
            return {
                'success': False,
                'task_id': task_id,
                'error': str(e)
            }

    def verify_cleanup(self, task_ids: List[int]) -> Dict:
        """Verify that cleanup was successful"""
        placeholders = ','.join('?' * len(task_ids))
        query = f"""
            SELECT
                COUNT(*) as total,
                SUM(CASE WHEN quality_metadata = '{{}}' THEN 1 ELSE 0 END) as cleaned,
                SUM(CASE WHEN quality_metadata != '{{}}' THEN 1 ELSE 0 END) as remaining
            FROM tasks
            WHERE id IN ({placeholders})
        """

        with self.db.connect() as conn:
            cursor = conn.execute(query, tuple(task_ids))
            row = cursor.fetchone()

        return {
            'total': row[0],
            'cleaned': row[1],
            'remaining': row[2]
        }


# Default affected task IDs (from Task 629 analysis)
DEFAULT_TASK_IDS = [
    517, 521, 525, 529, 530, 531, 532, 533, 536, 537, 538, 539, 546,
    557, 598, 599, 601, 605, 606, 608, 609, 613, 617, 618, 619, 620,
    621, 622, 623, 624, 625, 635
]


def main():
    """Main execution"""
    import argparse

    parser = argparse.ArgumentParser(description='Clean up boilerplate task metadata')
    parser.add_argument('--dry-run', action='store_true', help='Preview without making changes')
    parser.add_argument('--task-ids', type=str, help='Comma-separated task IDs (default: known boilerplate tasks)')
    parser.add_argument('--verify', action='store_true', help='Only verify current state without cleanup')
    args = parser.parse_args()

    # Parse task IDs
    task_ids = DEFAULT_TASK_IDS
    if args.task_ids:
        task_ids = [int(id.strip()) for id in args.task_ids.split(',')]

    # Initialize database
    db_path = Path('.agentpm/data/agentpm.db')
    if not db_path.exists():
        print(f"‚ùå Database not found: {db_path}")
        sys.exit(1)

    db = DatabaseService(str(db_path))
    cleanup = MetadataCleanup(db)

    print(f"\n{'=' * 80}")
    print(f"Task Metadata Cleanup - WI-117")
    print(f"{'=' * 80}")
    if args.dry_run:
        print("‚ö†Ô∏è  DRY RUN MODE - No changes will be made")
    if args.verify:
        print("‚ö†Ô∏è  VERIFY MODE - Only checking current state")
    print(f"\nTarget tasks: {len(task_ids)}")
    print()

    # Detect tasks with boilerplate
    print("üîç Detecting tasks with boilerplate metadata...")
    tasks_with_boilerplate = cleanup.get_tasks_with_boilerplate(task_ids)

    print(f"\nüìä Detection Results:")
    print(f"   - Tasks scanned: {len(task_ids)}")
    print(f"   - Tasks with boilerplate: {len(tasks_with_boilerplate)}")
    print()

    if not tasks_with_boilerplate:
        print("‚úÖ No boilerplate metadata found!")
        sys.exit(0)

    # Show sample boilerplate
    if tasks_with_boilerplate:
        print(f"üìã Sample Boilerplate (first 3 tasks):")
        for task in tasks_with_boilerplate[:3]:
            print(f"\n   Task {task['id']}: {task['name'][:60]}")
            try:
                metadata = json.loads(task['metadata']) if isinstance(task['metadata'], str) else task['metadata']
                if 'acceptance_criteria' in metadata:
                    ac = metadata['acceptance_criteria']
                    if isinstance(ac, list) and ac:
                        first_criterion = ac[0]
                        criterion_text = first_criterion.get('criterion', '') if isinstance(first_criterion, dict) else str(first_criterion)
                        print(f"      Criterion: {criterion_text[:80]}...")
            except (json.JSONDecodeError, TypeError):
                pass
        print()

    # Verify mode - just report and exit
    if args.verify:
        print(f"\n{'=' * 80}")
        print("Verification Complete")
        print(f"{'=' * 80}")
        print(f"‚úÖ Found {len(tasks_with_boilerplate)} tasks with boilerplate metadata")
        print(f"\nTo clean up, run:")
        print(f"   python scripts/cleanup_boilerplate_metadata.py --dry-run")
        print()
        sys.exit(0)

    # Clean up tasks
    print(f"üßπ Cleaning up {len(tasks_with_boilerplate)} tasks...")
    results = []
    for idx, task in enumerate(tasks_with_boilerplate, 1):
        task_id = task['id']
        task_name = task['name'][:50]
        print(f"[{idx}/{len(tasks_with_boilerplate)}] Task {task_id}: {task_name}...", end=' ')

        result = cleanup.cleanup_task(task_id, dry_run=args.dry_run)
        results.append(result)

        if result.get('success'):
            if args.dry_run:
                print("‚úÖ Would reset")
            else:
                print("‚úÖ Reset")
        else:
            print(f"‚ùå {result.get('error', 'Unknown error')}")

    # Summary
    print(f"\n{'=' * 80}")
    print("Summary")
    print(f"{'=' * 80}")

    successful = [r for r in results if r.get('success') and not r.get('dry_run')]
    dry_run_preview = [r for r in results if r.get('dry_run')]
    failed = [r for r in results if not r.get('success')]

    if args.dry_run:
        print(f"‚úÖ Would reset: {len(dry_run_preview)} tasks")
        print(f"\nTo execute cleanup, run:")
        print(f"   python scripts/cleanup_boilerplate_metadata.py")
    else:
        print(f"‚úÖ Reset: {len(successful)} tasks")
        print(f"‚ùå Failed: {len(failed)}")

        if successful:
            # Verify cleanup
            cleaned_task_ids = [r['task_id'] for r in successful]
            verification = cleanup.verify_cleanup(cleaned_task_ids)

            print(f"\n{'=' * 80}")
            print("Verification")
            print(f"{'=' * 80}")
            print(f"‚úÖ Total tasks: {verification['total']}")
            print(f"‚úÖ Cleaned (metadata = {{}}): {verification['cleaned']}")
            print(f"‚ö†Ô∏è  Remaining with metadata: {verification['remaining']}")

            if verification['remaining'] > 0:
                print(f"\n‚ö†Ô∏è  Warning: {verification['remaining']} tasks still have metadata")
                print(f"   This may indicate legitimate task-specific metadata")
        else:
            print("‚ö†Ô∏è  No tasks were cleaned")

    # Next steps
    print(f"\n{'=' * 80}")
    print("Next Steps")
    print(f"{'=' * 80}")
    if args.dry_run:
        print("1. Review the dry-run output above")
        print("2. Run without --dry-run to execute cleanup")
        print("3. Verify with: python scripts/cleanup_boilerplate_metadata.py --verify")
    else:
        print("‚úÖ Cleanup complete!")
        print("\nFuture metadata will be task-specific:")
        print("   - Planning agents will generate context-aware criteria")
        print("   - Implementation agents will document actual implementation")
        print("   - Quality gates will use meaningful, testable criteria")

    print()


if __name__ == '__main__':
    main()
