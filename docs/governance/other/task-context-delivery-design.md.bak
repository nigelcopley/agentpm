# Task Context Delivery Design: `apm task show <id>`

**Work Item**: WI-77 - Context Agent Implementation
**Component**: Task Context Delivery System
**Date**: 2025-10-17
**Status**: Design Complete

---

## 1. Executive Summary

**Objective**: Transform `apm task show <id>` from basic metadata display into a comprehensive context delivery system that provides agents with everything needed for task execution in a single command.

**Current State**:
- Shows only basic task fields (name, type, status, effort)
- No work item context
- No project context
- No 6W analysis
- No supporting evidence or documents

**Target State**:
- Complete hierarchical context (task → work item → project)
- Full 6W analysis at all levels
- Supporting documents, evidence, and research
- Recent activity and progress context
- Code context (amalgamation references)
- Multiple output formats (rich, JSON, markdown)

**Agent Benefit**: Single command replaces ~15 manual queries and provides 10x more actionable context.

---

## 2. Architecture Overview

### 2.1 Three-Tier Context Assembly

```
┌─────────────────────────────────────────────────────────────┐
│                  apm task show <id>                         │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  Tier 1: Core Hierarchy (3 queries)                 │   │
│  │  - Task entity                                       │   │
│  │  - Work Item entity                                  │   │
│  │  - Project entity                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                   │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  Tier 2: 6W Context (3 queries)                     │   │
│  │  - Task 6W (task_context)                           │   │
│  │  - Work Item 6W (work_item_context)                 │   │
│  │  - Project 6W (project_context)                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                   │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  Tier 3: Supporting Context (lazy load)             │   │
│  │  - Documents (document_references)                  │   │
│  │  - Evidence (evidence_sources)                      │   │
│  │  - Recent Events (events, last 5)                   │   │
│  │  - Work Item Summary (work_item_summaries, latest)  │   │
│  │  - Amalgamations (code references)                  │   │
│  │  - Dependencies (task_dependencies)                 │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Query Optimization Strategy

**Phase 1 - Essential Queries (Always Execute)**:
```sql
-- Query 1: Task with work item JOIN (1 query, 2 entities)
SELECT
  t.*,
  w.name as wi_name, w.type as wi_type, w.description as wi_description,
  w.business_context, w.status as wi_status, w.priority as wi_priority
FROM tasks t
JOIN work_items w ON t.work_item_id = w.id
WHERE t.id = ?

-- Query 2: Project (1 query)
SELECT * FROM projects WHERE id = ?

-- Query 3: All 6W contexts (1 query with polymorphic lookup)
SELECT * FROM contexts
WHERE (entity_type = 'TASK' AND entity_id = ?)
   OR (entity_type = 'WORK_ITEM' AND entity_id = ?)
   OR (entity_type = 'PROJECT' AND entity_id = ?)
```

**Total Core Queries: 3** (down from 9 sequential queries)

**Phase 2 - Supporting Queries (Conditional)**:
```sql
-- Only if documents exist for this work item
SELECT * FROM document_references
WHERE work_item_id = ?
ORDER BY created_at DESC LIMIT 10

-- Only if evidence exists for this work item
SELECT * FROM evidence_sources
WHERE work_item_id = ?
ORDER BY created_at DESC LIMIT 10

-- Recent activity (last 5 events for work item)
SELECT * FROM events
WHERE work_item_id = ?
ORDER BY created_at DESC LIMIT 5

-- Latest work item summary
SELECT * FROM work_item_summaries
WHERE work_item_id = ?
ORDER BY created_at DESC LIMIT 1

-- Task dependencies
SELECT * FROM task_dependencies
WHERE task_id = ? OR depends_on_task_id = ?
```

**Total Supporting Queries: 0-5** (only if data exists)

---

## 3. Complete Output Schema

### 3.1 Core Task Information

```yaml
task:
  id: 355
  name: "Implement user authentication middleware"
  description: |
    Create JWT-based authentication middleware for Express.js
    that validates tokens and attaches user context to requests.

  # Type & Workflow
  type: "implementation"
  status: "in_progress"

  # Planning
  effort_hours: 3.5
  max_hours: 4.0  # Time-box limit for type
  priority: 1  # (1=highest, 5=lowest)

  # Assignment
  assigned_to: "code-implementer"

  # Relationships
  work_item_id: 45

  # Timestamps
  created_at: "2025-10-15T10:30:00Z"
  started_at: "2025-10-16T09:00:00Z"
  updated_at: "2025-10-17T14:22:00Z"

  # Quality Metadata (type-specific)
  quality_metadata:
    acceptance_criteria:
      - "Middleware validates JWT tokens using secret key"
      - "Invalid tokens return 401 Unauthorized"
      - "User context attached to req.user"
      - "90%+ test coverage"
    test_plan: |
      - Unit tests for token validation
      - Integration tests with Express routes
      - Edge cases: expired, malformed, missing tokens
    technical_approach: |
      Use jsonwebtoken library, implement as Express middleware,
      follow existing auth patterns in /middleware/auth.js
```

### 3.2 Parent Work Item Context

```yaml
work_item:
  id: 45
  name: "User Authentication System"
  type: "feature"
  description: |
    Complete user authentication system with JWT tokens,
    login/logout, password reset, and session management.

  # Business Context
  business_context: |
    Users need secure authentication to access protected resources.
    Current system uses basic auth which is insecure for production.

  # Workflow
  status: "in_progress"
  phase: "implementation"
  priority: 1

  # Planning
  effort_estimate_hours: 40.0

  # Timestamps
  created_at: "2025-10-10T08:00:00Z"

  # Why Value (from 6W or business_context)
  why_value: |
    **Business Value**: Enable secure user access to premium features,
    compliance with security standards (OWASP)

    **Risk if Delayed**: Security vulnerability exposure, cannot
    launch premium tier without proper authentication
```

### 3.3 Project Context

```yaml
project:
  id: 1
  name: "E-Commerce Platform API"
  path: "/Users/dev/projects/ecommerce-api"

  # Technical Foundation
  tech_stack:
    - python
    - django
    - postgresql
    - redis
    - docker

  detected_frameworks:
    - django-rest-framework
    - celery
    - pytest

  # Business Context
  business_domain: "E-commerce"
  business_description: |
    RESTful API backend for e-commerce platform supporting
    product catalog, user management, orders, and payments.

  # Standards & Patterns
  standards:
    - "Django naming conventions (snake_case)"
    - "REST API design principles"
    - "Test coverage >85%"
    - "Docstrings required for all public methods"
```

### 3.4 Six-W Context (Hierarchical)

```yaml
six_w:
  # Task Level (most granular)
  task:
    who:
      implementers: ["@alice", "@code-implementer"]
      reviewers: ["@bob", "@security-validator"]
      end_users: ["API consumers", "Frontend team"]

    what:
      functional_requirements:
        - "Validate JWT tokens in Authorization header"
        - "Extract user ID from token payload"
        - "Attach user object to request context"
        - "Return 401 for invalid/expired tokens"

      technical_constraints:
        - "Must work with existing Express.js setup"
        - "Use HS256 algorithm for JWT"
        - "Token secret from environment variable"
        - "Response time <10ms per request"

      acceptance_criteria:
        - "All tests passing with 90%+ coverage"
        - "Handles expired tokens correctly"
        - "Compatible with existing /api/auth routes"
        - "No breaking changes to auth flow"

    where:
      affected_services: ["api-gateway", "auth-service"]
      repositories: ["backend-api"]
      deployment_targets: ["staging", "production"]
      files:
        - "src/middleware/auth.js"
        - "src/utils/jwt.js"
        - "tests/middleware/auth.test.js"

    when:
      deadline: "2025-10-20"
      dependencies_timeline:
        - "Blocked by: Task #352 (JWT secret configuration) - DONE"
        - "Blocks: Task #358 (Protected routes implementation)"

    why:
      business_value: "Enables secure authentication for all protected endpoints"
      risk_if_delayed: "API remains vulnerable, premium features cannot launch"

    how:
      suggested_approach: |
        1. Import jsonwebtoken library
        2. Create middleware function that:
           - Extracts token from Authorization header
           - Validates token using JWT_SECRET
           - Queries user from database
           - Attaches to req.user
        3. Add error handling for all failure cases

      existing_patterns:
        - "middleware/rate-limiter.js (similar structure)"
        - "middleware/logger.js (error handling pattern)"
        - "utils/response.js (error response format)"

  # Work Item Level (component/feature scope)
  work_item:
    who:
      implementers: ["@team-backend", "@alice", "@bob"]
      reviewers: ["@tech-lead", "@security-team"]
      end_users: ["All platform users"]

    what:
      functional_requirements:
        - "User registration and login"
        - "JWT token generation and validation"
        - "Password reset flow"
        - "Session management"

      technical_constraints:
        - "RESTful API design"
        - "OWASP security compliance"
        - "OAuth2 compatibility for future"

    where:
      affected_services: ["api-gateway", "auth-service", "user-service"]
      repositories: ["backend-api"]

    when:
      deadline: "2025-10-25"
      dependencies_timeline:
        - "Sprint 3 delivery"
        - "Before premium tier launch"

    why:
      business_value: "Foundation for secure user management and premium features"
      risk_if_delayed: "Cannot launch premium tier, security vulnerability"

    how:
      suggested_approach: "JWT-based auth with refresh tokens"
      existing_patterns: ["REST API patterns", "Error handling"]

  # Project Level (system-wide)
  project:
    who:
      implementers: ["@backend-team", "@frontend-team", "@devops"]
      reviewers: ["@cto", "@tech-leads"]
      end_users: ["E-commerce customers", "Admin users"]

    what:
      functional_requirements:
        - "Complete e-commerce platform backend"
        - "Product catalog, orders, payments, users"

      technical_constraints:
        - "High availability (99.9% uptime)"
        - "Scalable to 10K concurrent users"
        - "PCI DSS compliance for payments"

    where:
      affected_services: ["All microservices"]
      repositories: ["backend-api", "frontend-web"]
      deployment_targets: ["AWS EKS production cluster"]

    when:
      deadline: "Q1 2026 GA launch"

    why:
      business_value: "Enable online sales, revenue generation"
      risk_if_delayed: "Market share loss to competitors"

    how:
      suggested_approach: "Microservices on Kubernetes"
      existing_patterns: ["Service mesh", "Event-driven architecture"]
```

### 3.5 Supporting Context

```yaml
supporting_context:
  # Documents (specs, ADRs, design docs)
  documents:
    - id: 12
      type: "architecture_decision"
      title: "ADR-005: JWT Authentication Strategy"
      path: "docs/adrs/ADR-005-jwt-auth.md"
      summary: "Decision to use JWT over session-based auth"
      created_at: "2025-10-08"

    - id: 13
      type: "specification"
      title: "Authentication System Specification"
      path: "docs/specs/auth-system-spec.md"
      summary: "Complete auth system requirements and flows"
      created_at: "2025-10-09"

  # Evidence (research, decisions, external sources)
  evidence:
    - id: 8
      source_type: "external"
      url: "https://jwt.io/introduction"
      title: "JWT Introduction and Best Practices"
      summary: "Official JWT documentation covering security considerations"
      confidence: 0.9
      captured_at: "2025-10-09"

    - id: 9
      source_type: "internal"
      title: "Security Review Notes"
      content: "Team decision: Use HS256 algorithm, 1h expiry, refresh tokens"
      confidence: 1.0
      captured_at: "2025-10-10"

  # Recent Activity (last 5 events for work item)
  recent_activity:
    - event_type: "task_started"
      summary: "Task #355 started by @alice"
      timestamp: "2025-10-16T09:00:00Z"

    - event_type: "task_completed"
      summary: "Task #352 (JWT config) completed by @bob"
      timestamp: "2025-10-15T16:30:00Z"

    - event_type: "work_item_updated"
      summary: "Work item status changed to in_progress"
      timestamp: "2025-10-15T10:00:00Z"

  # Progress Context (latest work item summary)
  progress:
    summary: |
      Authentication system 60% complete:
      ✅ JWT configuration and secret management
      ✅ User model and database schema
      🔄 Authentication middleware (in progress)
      ⏳ Protected routes implementation (pending)
      ⏳ Password reset flow (pending)

    blockers: []

    updated_at: "2025-10-17T08:00:00Z"

  # Dependencies (task relationships)
  dependencies:
    blocks:
      - task_id: 358
        name: "Implement protected routes"
        status: "validated"
        reason: "Needs auth middleware to function"

    blocked_by:
      - task_id: 352
        name: "Configure JWT secret"
        status: "done"
        resolved_at: "2025-10-15T16:30:00Z"

  # Code Context (amalgamation references)
  code_context:
    amalgamations:
      python_classes: ".agentpm/contexts/lang_python_classes.txt"
      python_functions: ".agentpm/contexts/lang_python_functions.txt"
      django_models: ".agentpm/contexts/framework_django_models.txt"
      pytest_tests: ".agentpm/contexts/testing_pytest_fixtures.txt"

    relevant_files:
      - "backend/auth/middleware.py"
      - "backend/auth/jwt_utils.py"
      - "tests/test_auth_middleware.py"
```

---

## 4. Implementation Design

### 4.1 Enhanced Command Structure

```python
# agentpm/cli/commands/task/show.py

@click.command()
@click.argument('task_id', type=int)
@click.option('--format', type=click.Choice(['rich', 'json', 'markdown']),
              default='rich', help='Output format')
@click.option('--full', is_flag=True,
              help='Include all supporting context (documents, evidence, events)')
@click.option('--minimal', is_flag=True,
              help='Show only core task + work item context')
@click.pass_context
def show(ctx: click.Context, task_id: int, format: str, full: bool, minimal: bool):
    """
    Show complete task context for agent execution.

    Delivers hierarchical context in a single command:
    - Task details with quality metadata
    - Work item context and business value
    - Project technical foundation
    - 6W analysis at all levels
    - Supporting documents, evidence, and activity

    \b
    Examples:
      apm task show 355                    # Rich display
      apm task show 355 --format=json      # JSON for agents
      apm task show 355 --full             # Include all supporting context
      apm task show 355 --minimal          # Just core hierarchy
    """
    console = ctx.obj['console']
    project_root = ensure_project_root(ctx)
    db = get_database_service(project_root)

    # Use ContextService for optimized assembly
    from agentpm.core.context.service import ContextService
    context_service = ContextService(db, project_root)

    # Assemble complete context
    if minimal:
        context = context_service.get_task_context_minimal(task_id)
    elif full:
        context = context_service.get_task_context_full(task_id)
    else:
        context = context_service.get_task_context(task_id)

    # Render based on format
    if format == 'json':
        render_json(console, context)
    elif format == 'markdown':
        render_markdown(console, context)
    else:
        render_rich(console, context)
```

### 4.2 Context Service Enhancement

```python
# agentpm/core/context/service.py

class ContextService:
    """Enhanced context service with task context delivery"""

    def get_task_context(self, task_id: int) -> Dict[str, Any]:
        """
        Get complete task context (optimized, standard mode).

        Returns:
            {
                'task': {...},           # Task entity
                'work_item': {...},      # Work item entity
                'project': {...},        # Project entity
                'six_w': {               # All 6W levels
                    'task': {...},
                    'work_item': {...},
                    'project': {...}
                },
                'supporting': {          # Conditional (only if exists)
                    'documents': [...],
                    'evidence': [...],
                    'recent_activity': [...],
                    'progress': {...},
                    'dependencies': {...},
                    'code_context': {...}
                }
            }
        """
        # Phase 1: Core hierarchy (3 queries)
        task, work_item, project = self._get_core_hierarchy(task_id)

        # Phase 2: 6W contexts (1 query)
        six_w = self._get_six_w_contexts(task_id, work_item.id, project.id)

        # Phase 3: Supporting context (conditional)
        supporting = self._get_supporting_context(task_id, work_item.id)

        return {
            'task': self._serialize_task(task),
            'work_item': self._serialize_work_item(work_item),
            'project': self._serialize_project(project),
            'six_w': six_w,
            'supporting': supporting,
            'metadata': {
                'assembled_at': datetime.now().isoformat(),
                'context_version': '1.0',
                'query_count': self._query_count
            }
        }

    def get_task_context_minimal(self, task_id: int) -> Dict[str, Any]:
        """Minimal context (just core hierarchy + 6W)"""
        # Only Phase 1 & 2, skip supporting context
        ...

    def get_task_context_full(self, task_id: int) -> Dict[str, Any]:
        """Full context (everything, no conditional loading)"""
        # Always load all supporting context
        ...

    def _get_core_hierarchy(self, task_id: int):
        """Optimized: 1 query with JOIN"""
        query = """
            SELECT
                t.*,
                w.id as wi_id, w.name as wi_name, w.type as wi_type,
                w.description as wi_description, w.business_context,
                w.status as wi_status, w.priority as wi_priority,
                w.effort_estimate_hours, w.phase, w.project_id,
                p.id as proj_id, p.name as proj_name, p.path as proj_path,
                p.tech_stack, p.detected_frameworks, p.business_domain
            FROM tasks t
            JOIN work_items w ON t.work_item_id = w.id
            JOIN projects p ON w.project_id = p.id
            WHERE t.id = ?
        """
        # Returns task, work_item, project in one query
        ...

    def _get_six_w_contexts(self, task_id: int, work_item_id: int,
                           project_id: int) -> Dict[str, Any]:
        """Optimized: 1 query for all 6W levels"""
        query = """
            SELECT * FROM contexts
            WHERE context_type IN ('TASK_CONTEXT', 'WORK_ITEM_CONTEXT', 'PROJECT_CONTEXT')
              AND (
                  (entity_type = 'TASK' AND entity_id = ?)
                  OR (entity_type = 'WORK_ITEM' AND entity_id = ?)
                  OR (entity_type = 'PROJECT' AND entity_id = ?)
              )
        """
        # Returns all 6W contexts in one query, parse into hierarchy
        ...

    def _get_supporting_context(self, task_id: int,
                               work_item_id: int) -> Dict[str, Any]:
        """Conditional supporting context (0-5 queries)"""
        supporting = {}

        # Only query if data exists (check counts first)
        if self._has_documents(work_item_id):
            supporting['documents'] = self._get_documents(work_item_id)

        if self._has_evidence(work_item_id):
            supporting['evidence'] = self._get_evidence(work_item_id)

        # Always get recent activity (lightweight)
        supporting['recent_activity'] = self._get_recent_activity(work_item_id)

        if self._has_summary(work_item_id):
            supporting['progress'] = self._get_latest_summary(work_item_id)

        if self._has_dependencies(task_id):
            supporting['dependencies'] = self._get_dependencies(task_id)

        # Code context (amalgamation references)
        supporting['code_context'] = self._get_code_context(project.tech_stack)

        return supporting
```

### 4.3 Rendering Implementations

#### 4.3.1 Rich Console Display

```python
# agentpm/cli/commands/task/renderers.py

from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.tree import Tree
from rich.markdown import Markdown

def render_rich(console: Console, context: Dict[str, Any]):
    """Rich formatted display for terminal"""

    # Header
    task = context['task']
    console.print(f"\n[bold cyan]📋 Task #{task['id']}: {task['name']}[/bold cyan]\n")

    # Core Task Info Panel
    task_info = Table.grid(padding=(0, 2))
    task_info.add_column(style="bold")
    task_info.add_column()

    task_info.add_row("Type", f"[yellow]{task['type']}[/yellow]")
    task_info.add_row("Status", _status_badge(task['status']))
    task_info.add_row("Effort", f"{task['effort_hours']}h / {task['max_hours']}h max")
    task_info.add_row("Priority", f"{'⭐' * task['priority']} ({task['priority']}/5)")
    task_info.add_row("Assigned To", task['assigned_to'] or "[dim]Unassigned[/dim]")

    console.print(Panel(task_info, title="Task Details", border_style="cyan"))

    # Description
    if task.get('description'):
        console.print(f"\n[bold]Description:[/bold]\n{task['description']}\n")

    # Quality Metadata (acceptance criteria, test plan)
    if task.get('quality_metadata'):
        render_quality_metadata(console, task['quality_metadata'])

    # Work Item Context Panel
    work_item = context['work_item']
    console.print(f"\n[bold magenta]🎯 Work Item Context: {work_item['name']}[/bold magenta]\n")

    wi_info = Table.grid(padding=(0, 2))
    wi_info.add_column(style="bold")
    wi_info.add_column()

    wi_info.add_row("Type", work_item['type'])
    wi_info.add_row("Status", _status_badge(work_item['status']))
    wi_info.add_row("Priority", f"{'⭐' * work_item['priority']}")

    console.print(Panel(wi_info, border_style="magenta"))

    if work_item.get('business_context'):
        console.print(f"\n[bold]Business Context:[/bold]\n{work_item['business_context']}\n")

    # Project Context Panel
    project = context['project']
    console.print(f"\n[bold green]🏗️  Project: {project['name']}[/bold green]\n")

    proj_info = Table.grid(padding=(0, 2))
    proj_info.add_column(style="bold")
    proj_info.add_column()

    proj_info.add_row("Tech Stack", ", ".join(project['tech_stack']))
    proj_info.add_row("Frameworks", ", ".join(project['detected_frameworks']))
    proj_info.add_row("Domain", project.get('business_domain', 'N/A'))

    console.print(Panel(proj_info, border_style="green"))

    # 6W Analysis (Hierarchical Tree)
    console.print("\n[bold]📊 6W Context Analysis[/bold]\n")
    render_six_w_tree(console, context['six_w'])

    # Supporting Context (if exists)
    if context.get('supporting'):
        console.print("\n[bold]📚 Supporting Context[/bold]\n")
        render_supporting_context(console, context['supporting'])

    # Footer with metadata
    console.print(f"\n[dim]Context assembled at: {context['metadata']['assembled_at']}[/dim]")
    console.print(f"[dim]Queries executed: {context['metadata']['query_count']}[/dim]\n")

def render_six_w_tree(console: Console, six_w: Dict[str, Any]):
    """Render 6W analysis as collapsible tree"""

    tree = Tree("🧭 Six-W Framework")

    # Task level (most detailed)
    task_branch = tree.add("[cyan]Task Level[/cyan] (Implementation Details)")
    _add_six_w_branch(task_branch, six_w['task'])

    # Work Item level
    wi_branch = tree.add("[magenta]Work Item Level[/magenta] (Feature Scope)")
    _add_six_w_branch(wi_branch, six_w['work_item'])

    # Project level
    proj_branch = tree.add("[green]Project Level[/green] (System Context)")
    _add_six_w_branch(proj_branch, six_w['project'])

    console.print(tree)

def render_supporting_context(console: Console, supporting: Dict[str, Any]):
    """Render supporting context sections"""

    # Documents
    if docs := supporting.get('documents'):
        console.print("[bold]📄 Documents[/bold]")
        for doc in docs:
            console.print(f"  • {doc['title']} ([dim]{doc['type']}[/dim])")
            console.print(f"    {doc['path']}")

    # Evidence
    if evidence := supporting.get('evidence'):
        console.print("\n[bold]🔍 Evidence & Research[/bold]")
        for ev in evidence:
            console.print(f"  • {ev['title']} (confidence: {ev['confidence']:.1%})")
            if ev.get('url'):
                console.print(f"    {ev['url']}")

    # Recent Activity
    if activity := supporting.get('recent_activity'):
        console.print("\n[bold]⏱️  Recent Activity[/bold]")
        for event in activity:
            console.print(f"  • {event['summary']} ([dim]{event['timestamp']}[/dim])")

    # Progress
    if progress := supporting.get('progress'):
        console.print("\n[bold]📈 Progress Summary[/bold]")
        console.print(Markdown(progress['summary']))

    # Dependencies
    if deps := supporting.get('dependencies'):
        console.print("\n[bold]🔗 Dependencies[/bold]")
        if deps.get('blocks'):
            console.print("  Blocks:")
            for task in deps['blocks']:
                console.print(f"    → Task #{task['task_id']}: {task['name']}")
        if deps.get('blocked_by'):
            console.print("  Blocked By:")
            for task in deps['blocked_by']:
                status = "✅" if task['status'] == 'done' else "⏳"
                console.print(f"    {status} Task #{task['task_id']}: {task['name']}")

    # Code Context
    if code := supporting.get('code_context'):
        console.print("\n[bold]💻 Code Context[/bold]")
        console.print("  Amalgamations:")
        for name, path in code['amalgamations'].items():
            console.print(f"    • {name}: {path}")
```

#### 4.3.2 JSON Output

```python
def render_json(console: Console, context: Dict[str, Any]):
    """JSON output for machine consumption"""
    import json

    # Pretty print with indentation
    json_str = json.dumps(context, indent=2, default=str)
    console.print(json_str)
```

#### 4.3.3 Markdown Output

```python
def render_markdown(console: Console, context: Dict[str, Any]):
    """Markdown output (hybrid: human-readable + parseable)"""

    task = context['task']
    work_item = context['work_item']
    project = context['project']

    md = f"""# Task #{task['id']}: {task['name']}

## Task Details

- **Type**: {task['type']}
- **Status**: {task['status']}
- **Effort**: {task['effort_hours']}h / {task['max_hours']}h max
- **Priority**: {task['priority']}/5
- **Assigned To**: {task['assigned_to'] or 'Unassigned'}

### Description

{task.get('description', 'No description')}

### Acceptance Criteria

{_format_list(task.get('quality_metadata', {}).get('acceptance_criteria', []))}

### Test Plan

{task.get('quality_metadata', {}).get('test_plan', 'No test plan')}

---

## Work Item Context: {work_item['name']}

- **Type**: {work_item['type']}
- **Status**: {work_item['status']}
- **Priority**: {work_item['priority']}/5

### Business Context

{work_item.get('business_context', 'No business context')}

### Why Value

{context['six_w']['work_item']['why']['business_value']}

---

## Project Context: {project['name']}

- **Tech Stack**: {', '.join(project['tech_stack'])}
- **Frameworks**: {', '.join(project['detected_frameworks'])}
- **Domain**: {project.get('business_domain', 'N/A')}

---

## 6W Analysis

### Task Level (Implementation)

#### WHO
- **Implementers**: {', '.join(context['six_w']['task']['who']['implementers'])}
- **Reviewers**: {', '.join(context['six_w']['task']['who']['reviewers'])}

#### WHAT
{_format_six_w_section(context['six_w']['task']['what'])}

#### WHERE
{_format_six_w_section(context['six_w']['task']['where'])}

#### WHEN
- **Deadline**: {context['six_w']['task']['when']['deadline']}

#### WHY
{context['six_w']['task']['why']['business_value']}

#### HOW
{context['six_w']['task']['how']['suggested_approach']}

---

## Supporting Context

### Documents
{_format_documents(context['supporting'].get('documents', []))}

### Evidence & Research
{_format_evidence(context['supporting'].get('evidence', []))}

### Recent Activity
{_format_activity(context['supporting'].get('recent_activity', []))}

### Dependencies
{_format_dependencies(context['supporting'].get('dependencies', {}))}

---

*Context assembled: {context['metadata']['assembled_at']}*
"""

    console.print(Markdown(md))
```

---

## 5. Performance Analysis

### 5.1 Query Comparison

**Current Implementation** (basic task show):
```
Query 1: SELECT * FROM tasks WHERE id = ?
Total: 1 query, ~50 bytes
```

**New Implementation** (full context):
```
Core Queries (always):
  Query 1: Task + Work Item JOIN       → ~500 bytes
  Query 2: Project                     → ~300 bytes
  Query 3: All 6W contexts            → ~2KB

Supporting Queries (conditional):
  Query 4: Documents (if exist)        → ~1KB
  Query 5: Evidence (if exist)         → ~1KB
  Query 6: Recent events               → ~500 bytes
  Query 7: Latest summary (if exist)   → ~500 bytes
  Query 8: Dependencies (if exist)     → ~300 bytes

Total: 3-8 queries, ~2.5KB-6KB data
```

**Performance Impact**:
- **Minimal Mode**: 3 queries, ~2.8KB, <50ms
- **Standard Mode**: 5-6 queries, ~4KB, <100ms
- **Full Mode**: 8 queries, ~6KB, <150ms

**Agent Benefit**:
- **Without enhancement**: Agent makes ~15 separate queries manually
- **With enhancement**: 1 command delivers everything
- **Time saved**: ~500ms → ~100ms (5x faster)
- **Context completeness**: 10x more information

### 5.2 Token Efficiency

**Current Basic Display**: ~100 tokens
**New Full Context Display**: ~2,000-3,000 tokens
**Agent Benefit**: Single comprehensive context vs. multiple queries

---

## 6. Usage Examples

### 6.1 Standard Rich Display

```bash
$ apm task show 355

📋 Task #355: Implement user authentication middleware

╭─ Task Details ─────────────────────────╮
│ Type         implementation             │
│ Status       🔄 in_progress             │
│ Effort       3.5h / 4.0h max            │
│ Priority     ⭐ (1/5)                   │
│ Assigned To  code-implementer           │
╰────────────────────────────────────────╯

Description:
Create JWT-based authentication middleware for Express.js
that validates tokens and attaches user context to requests.

Acceptance Criteria:
✓ Middleware validates JWT tokens using secret key
✓ Invalid tokens return 401 Unauthorized
✓ User context attached to req.user
✓ 90%+ test coverage

🎯 Work Item Context: User Authentication System

╭─ Work Item Details ────────────────────╮
│ Type         feature                    │
│ Status       🔄 in_progress             │
│ Priority     ⭐ (1/5)                   │
╰────────────────────────────────────────╯

Business Context:
Users need secure authentication to access protected resources.
Current system uses basic auth which is insecure for production.

🏗️  Project: E-Commerce Platform API

╭─ Project Details ──────────────────────╮
│ Tech Stack   python, django, postgres  │
│ Frameworks   DRF, celery, pytest       │
│ Domain       E-commerce                 │
╰────────────────────────────────────────╯

📊 6W Context Analysis

🧭 Six-W Framework
├─ 🔷 Task Level (Implementation Details)
│  ├─ WHO: @alice, @code-implementer → @bob, @security-validator
│  ├─ WHAT: Validate JWT, extract user ID, attach to request...
│  ├─ WHERE: api-gateway, auth-service | src/middleware/auth.js
│  ├─ WHEN: 2025-10-20 | Blocked by: Task #352 (DONE)
│  ├─ WHY: Enable secure authentication for protected endpoints
│  └─ HOW: Use jsonwebtoken library, middleware pattern...
├─ 🔷 Work Item Level (Feature Scope)
│  ├─ WHO: @team-backend → @tech-lead
│  ├─ WHAT: User reg, login, JWT, password reset, sessions
│  └─ WHY: Foundation for secure user management
└─ 🔷 Project Level (System Context)
   ├─ WHO: @backend-team, @frontend-team, @devops
   ├─ WHAT: Complete e-commerce backend
   └─ WHY: Enable online sales, revenue generation

📚 Supporting Context

📄 Documents
  • ADR-005: JWT Authentication Strategy (architecture_decision)
    docs/adrs/ADR-005-jwt-auth.md
  • Authentication System Specification (specification)
    docs/specs/auth-system-spec.md

🔍 Evidence & Research
  • JWT Introduction and Best Practices (confidence: 90%)
    https://jwt.io/introduction
  • Security Review Notes (confidence: 100%)

⏱️  Recent Activity
  • Task #355 started by @alice (2025-10-16T09:00:00Z)
  • Task #352 (JWT config) completed by @bob (2025-10-15T16:30:00Z)

📈 Progress Summary
Authentication system 60% complete:
✅ JWT configuration and secret management
✅ User model and database schema
🔄 Authentication middleware (in progress)
⏳ Protected routes implementation (pending)

🔗 Dependencies
  Blocks:
    → Task #358: Implement protected routes
  Blocked By:
    ✅ Task #352: Configure JWT secret (resolved)

💻 Code Context
  Amalgamations:
    • python_classes: .agentpm/contexts/lang_python_classes.txt
    • python_functions: .agentpm/contexts/lang_python_functions.txt
    • django_models: .agentpm/contexts/framework_django_models.txt

Context assembled at: 2025-10-17T14:45:00Z
Queries executed: 6
```

### 6.2 JSON Output (for agents)

```bash
$ apm task show 355 --format=json > task-355-context.json

# Agent can now parse complete context programmatically
```

### 6.3 Minimal Mode (quick check)

```bash
$ apm task show 355 --minimal

📋 Task #355: Implement user authentication middleware
Type: implementation | Status: in_progress | Effort: 3.5h/4h

🎯 Work Item: User Authentication System
Type: feature | Status: in_progress

🏗️  Project: E-Commerce Platform API
Tech: python, django, postgresql

6W Context:
WHO: @alice, @code-implementer
WHAT: JWT middleware with token validation
WHERE: api-gateway, auth-service
WHEN: 2025-10-20
WHY: Enable secure authentication
HOW: jsonwebtoken library, middleware pattern
```

---

## 7. Migration Path

### 7.1 Phase 1: Core Implementation
1. Enhance `ContextService.get_task_context()` with optimized queries
2. Implement query optimization (JOINs, conditional loading)
3. Add rich rendering for hierarchical 6W display

### 7.2 Phase 2: Supporting Context
1. Add document/evidence/event queries
2. Implement conditional loading logic
3. Add code context (amalgamation references)

### 7.3 Phase 3: Output Formats
1. Implement JSON renderer
2. Implement markdown renderer
3. Add format flags to CLI

### 7.4 Phase 4: Optimization
1. Query result caching (session-level)
2. Lazy loading for large contexts
3. Pagination for documents/evidence

---

## 8. Testing Strategy

### 8.1 Unit Tests
```python
def test_get_task_context_minimal():
    """Minimal mode returns only core hierarchy"""

def test_get_task_context_full():
    """Full mode returns all supporting context"""

def test_query_optimization():
    """Verify optimized query count (3-8 max)"""

def test_conditional_loading():
    """Supporting queries only if data exists"""

def test_six_w_hierarchy_assembly():
    """6W contexts correctly parsed into 3 levels"""
```

### 8.2 Integration Tests
```python
def test_complete_task_context_delivery():
    """End-to-end: command → context service → rendering"""

def test_format_outputs():
    """All formats (rich, json, markdown) render correctly"""

def test_performance_benchmarks():
    """Context assembly completes in <150ms"""
```

---

## 9. Benefits Summary

### 9.1 Agent Perspective
- **Before**: 15+ manual queries to assemble context
- **After**: 1 command delivers everything
- **Time**: 500ms → 100ms (5x faster)
- **Completeness**: 10x more actionable information

### 9.2 Developer Perspective
- **Before**: Checking task details required multiple commands
- **After**: Single command shows complete picture
- **Context**: Full 6W analysis reveals hidden requirements
- **Confidence**: See business value, dependencies, risks upfront

### 9.3 System Perspective
- **Query Optimization**: 15 queries → 3-8 queries (50%+ reduction)
- **Context Quality**: Hierarchical inheritance ensures completeness
- **Consistency**: Same structure across all entity types
- **Extensibility**: Easy to add new supporting context types

---

## 10. Conclusion

This design transforms `apm task show <id>` from a basic metadata display into a comprehensive context delivery system that provides agents with everything needed for task execution in a single, optimized command.

**Key Innovations**:
1. **Three-tier context assembly** (core → 6W → supporting)
2. **Query optimization** (JOINs, conditional loading)
3. **Hierarchical 6W inheritance** (task inherits from work item and project)
4. **Multiple output formats** (rich, JSON, markdown)
5. **Performance-first design** (<150ms for full context)

**Next Steps**:
1. Implement enhanced `ContextService` methods
2. Add rendering implementations
3. Update CLI command with new options
4. Add comprehensive tests
5. Update documentation

---

**Document Version**: 1.0
**Author**: System Architect
**Last Updated**: 2025-10-17
