# Principle-Based Agents - Design Concept

**Status**: Concept Exploration
**Created**: 2025-10-14
**Purpose**: Map software engineering principles to specialized AI agents for automated code quality enforcement

---

## ðŸŽ¯ Core Concept

**Principle**: Create specialized agents that embody specific software engineering principles and patterns.

**Benefits**:
1. **Single Responsibility**: Each agent has one clear focus
2. **Composable**: Combine agents for comprehensive reviews
3. **Educational**: Agents explain *why* not just *what*
4. **Measurable**: Clear metrics per principle
5. **Progressive**: Apply principles incrementally based on project maturity

---

## ðŸ¤– Proposed Principle-Based Agents

### 1. Architecture Principle Agents

#### `solid-agent`
**Embodies**: SOLID Principles (5 principles)
- **S**ingle Responsibility Principle
- **O**pen/Closed Principle
- **L**iskov Substitution Principle
- **I**nterface Segregation Principle
- **D**ependency Inversion Principle

**Capabilities**:
- Analyzes class and module design
- Detects SRP violations (god objects, multiple responsibilities)
- Identifies OCP violations (modification vs extension)
- Validates LSP with inheritance hierarchies
- Checks ISP for fat interfaces
- Evaluates DIP for concrete dependencies

**Output Example**:
```yaml
violations:
  - principle: SRP
    location: "src/services/user_service.py:45"
    issue: "UserService handles auth, email, and logging (3 responsibilities)"
    recommendation: "Extract EmailService and LoggingService"
    severity: HIGH

  - principle: DIP
    location: "src/controllers/auth.py:12"
    issue: "Depends on concrete MySQLDatabase class"
    recommendation: "Depend on DatabaseInterface abstraction"
    severity: MEDIUM
```

#### `dry-agent`
**Embodies**: Don't Repeat Yourself
**Maps to Rules**: CQ-021 to CQ-030 (Function Quality)

**Capabilities**:
- Detects code duplication (exact and semantic)
- Identifies copy-paste patterns
- Suggests abstractions and refactorings
- Analyzes function similarities
- Proposes shared utilities

**Metrics**:
- Duplication percentage
- Repeated code blocks found
- Abstraction opportunities
- Complexity reduction potential

**Output Example**:
```yaml
duplications:
  - pattern: "validate_user_input"
    occurrences: 5
    locations:
      - "src/auth/login.py:34-42"
      - "src/auth/register.py:56-64"
      - "src/api/user.py:89-97"
    similarity: 92%
    recommendation: "Extract to shared validators.validate_user_input()"
    estimated_loc_reduction: 36
```

#### `kiss-agent`
**Embodies**: Keep It Simple, Stupid
**Maps to Rules**: DP-021 to DP-024 (Code Complexity)

**Capabilities**:
- Measures cyclomatic complexity
- Detects over-engineering
- Identifies unnecessary abstractions
- Evaluates cognitive complexity
- Suggests simplifications

**Metrics**:
- Cyclomatic complexity per function
- Nesting depth
- Lines of code per function
- Cognitive complexity score

#### `yagni-agent`
**Embodies**: You Aren't Gonna Need It
**Maps to Rules**: DP-023 (Code Complexity)

**Capabilities**:
- Identifies unused code
- Detects premature abstractions
- Finds over-generalized solutions
- Analyzes speculative features
- Suggests removal of unused complexity

---

### 2. Pattern-Based Agents

#### `make-it-work-agent`
**Embodies**: "Make It Work â†’ Make It Right â†’ Make It Fast" (Kent Beck)
**Phase**: 1 - Make It Work

**Capabilities**:
- Validates functionality against requirements
- Checks acceptance criteria compliance
- Verifies edge cases handled
- Ensures tests pass
- Focuses on correctness over elegance

**Gate**: Must pass before "make-it-right" phase

#### `make-it-right-agent`
**Embodies**: "Make It Work â†’ Make It Right â†’ Make It Fast"
**Phase**: 2 - Make It Right
**Prerequisite**: `make-it-work-agent` passed

**Capabilities**:
- Applies SOLID, DRY, KISS principles
- Refactors for maintainability
- Improves naming and structure
- Enhances readability
- Reduces technical debt

**Delegates to**: `solid-agent`, `dry-agent`, `kiss-agent`

#### `make-it-fast-agent`
**Embodies**: "Make It Work â†’ Make It Right â†’ Make It Fast"
**Phase**: 3 - Make It Fast
**Prerequisite**: `make-it-right-agent` passed

**Capabilities**:
- Profiles performance bottlenecks
- Optimizes algorithms
- Suggests caching strategies
- Identifies N+1 queries
- Recommends indexing

**Maps to Rules**: DP-046 to DP-055 (Performance Standards)

---

### 3. Quality Principle Agents

#### `test-pyramid-agent`
**Embodies**: Test Pyramid (Unit â†’ Integration â†’ E2E)
**Maps to Rules**: TEST-001 to TEST-020

**Capabilities**:
- Validates test distribution (70% unit, 20% integration, 10% E2E)
- Ensures coverage targets met
- Checks test isolation
- Validates test naming
- Measures test quality

**Output Example**:
```yaml
test_distribution:
  unit: 65%        # âš ï¸ Target: 70%
  integration: 25% # âš ï¸ Target: 20%
  e2e: 10%         # âœ… Target: 10%

recommendations:
  - "Add 15 unit tests-BAK for service layer"
  - "Reduce integration tests-BAK by converting to unit tests-BAK"

coverage: 87%      # âš ï¸ Target: 90%
```

#### `tdd-agent`
**Embodies**: Test-Driven Development
**Maps to Rules**: WR-006 (Test-First Workflow)

**Capabilities**:
- Enforces test-first workflow
- Validates red-green-refactor cycle
- Checks test commit order
- Measures TDD compliance
- Guides test writing

#### `security-first-agent`
**Embodies**: Security by Design
**Maps to Rules**: DP-036 to DP-045 (Security Standards)

**Capabilities**:
- Scans for security vulnerabilities
- Validates input sanitization
- Checks authentication/authorization
- Detects secrets in code
- Enforces HTTPS, encryption

---

### 4. Workflow Principle Agents

#### `time-boxing-agent`
**Embodies**: Time-Boxing Discipline
**Maps to Rules**: DP-001 to DP-011 (Time-Boxing)

**Capabilities**:
- Enforces task time limits
- Tracks implementation time
- Alerts on overruns
- Suggests task decomposition
- Prevents scope creep

**Output Example**:
```yaml
task: "Implement OAuth2 authentication"
estimated_hours: 4.0
actual_hours: 6.5
status: âš ï¸ OVER_TIME (162%)

recommendation: "Task exceeded 4h limit. Consider splitting into:"
  - "OAuth2 provider integration (3h)"
  - "Token validation middleware (2h)"
  - "User session management (2h)"
```

#### `incremental-agent`
**Embodies**: Incremental Development
**Maps to Rules**: WF-001 (Commit Frequency)

**Capabilities**:
- Enforces frequent commits (every 30-60min)
- Validates incremental progress
- Checks commit granularity
- Measures delivery cadence
- Prevents big-bang integration

---

### 5. Communication Principle Agents

#### `clarity-agent`
**Embodies**: Clear Communication
**Maps to Rules**: DOC-001 to DOC-025 (Documentation Standards)

**Capabilities**:
- Validates documentation completeness
- Checks docstring quality
- Analyzes naming clarity
- Measures readability scores
- Suggests improvements

**Metrics**:
- Flesch reading ease score
- Documentation coverage %
- Naming consistency score
- Comment quality score

#### `handover-agent`
**Embodies**: Context Preservation
**Maps to Rules**: DOC-021 to DOC-025 (Handover Documentation)

**Capabilities**:
- Validates session summaries
- Ensures decisions documented
- Checks blocker documentation
- Verifies next steps clarity
- Measures handover quality

---

## ðŸ”„ Agent Orchestration Patterns

### Sequential Pattern (Progressive Quality)
```
1. make-it-work-agent    â†’ Functionality validation
   â†“
2. make-it-right-agent   â†’ Refactoring & principles
   â†“ (delegates to)
   - solid-agent
   - dry-agent
   - kiss-agent
   â†“
3. make-it-fast-agent    â†’ Performance optimization
   â†“
4. security-first-agent  â†’ Security review
   â†“
5. clarity-agent         â†’ Documentation review
```

### Parallel Pattern (Comprehensive Review)
```
Code Submission
   â†“
   â”œâ”€â†’ solid-agent â”€â”€â”
   â”œâ”€â†’ dry-agent â”€â”€â”€â”€â”¤
   â”œâ”€â†’ kiss-agent â”€â”€â”€â”¤
   â”œâ”€â†’ test-pyramid-agent â”€â”¤
   â”œâ”€â†’ security-first-agent â”€â”¤
   â””â”€â†’ clarity-agent â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
                        Aggregated Report
```

### Conditional Pattern (Risk-Based)
```
if (critical_feature):
    run: security-first-agent, test-pyramid-agent, solid-agent
elif (refactoring):
    run: dry-agent, kiss-agent, solid-agent
elif (documentation):
    run: clarity-agent, handover-agent
else:
    run: solid-agent, dry-agent  # Minimal review
```

---

## ðŸ“Š Implementation Architecture

### Agent Base Class
```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from dataclasses import dataclass

@dataclass
class PrincipleViolation:
    principle: str
    location: str  # file:line
    issue: str
    recommendation: str
    severity: str  # HIGH, MEDIUM, LOW
    rule_id: str  # Maps to rules catalog

@dataclass
class AgentReport:
    agent_name: str
    principle: str
    passed: bool
    violations: List[PrincipleViolation]
    metrics: Dict[str, Any]
    summary: str

class PrincipleAgent(ABC):
    """Base class for principle-based agents"""

    @abstractmethod
    def analyze(self, code_path: str) -> AgentReport:
        """Analyze code against principle"""
        pass

    @abstractmethod
    def get_mapped_rules(self) -> List[str]:
        """Return rule IDs this agent enforces"""
        pass

    @abstractmethod
    def explain_principle(self) -> str:
        """Educational explanation of the principle"""
        pass
```

### Example: SOLID Agent Implementation
```python
class SOLIDAgent(PrincipleAgent):
    """Agent embodying SOLID principles"""

    def __init__(self, db: DatabaseService):
        self.db = db
        self.principles = {
            'SRP': SingleResponsibilityChecker(),
            'OCP': OpenClosedChecker(),
            'LSP': LiskovSubstitutionChecker(),
            'ISP': InterfaceSegregationChecker(),
            'DIP': DependencyInversionChecker()
        }

    def analyze(self, code_path: str) -> AgentReport:
        violations = []

        # Run each SOLID principle check
        for principle, checker in self.principles.items():
            principle_violations = checker.check(code_path)
            violations.extend(principle_violations)

        return AgentReport(
            agent_name="solid-agent",
            principle="SOLID Principles",
            passed=len(violations) == 0,
            violations=violations,
            metrics=self._calculate_metrics(violations),
            summary=self._generate_summary(violations)
        )

    def get_mapped_rules(self) -> List[str]:
        return [
            "CQ-031",  # class-single-responsibility
            "CQ-033",  # class-composition-over-inheritance
            "CQ-038",  # class-interface-segregation
            "CQ-039",  # class-dependency-injection
            "DP-035"   # code-single-responsibility
        ]

    def explain_principle(self) -> str:
        return """
        SOLID Principles (Robert C. Martin):

        S - Single Responsibility: Each class has one reason to change
        O - Open/Closed: Open for extension, closed for modification
        L - Liskov Substitution: Derived classes substitutable for base
        I - Interface Segregation: Small, focused interfaces
        D - Dependency Inversion: Depend on abstractions, not concretions

        These principles create maintainable, flexible software.
        """
```

---

## ðŸŽ“ Educational Benefits

### Learning Through Enforcement
Each agent provides:
1. **What**: Specific violation found
2. **Why**: Principle violated and importance
3. **How**: Concrete refactoring recommendation
4. **Reference**: Link to detailed explanation

### Example Educational Output
```yaml
violation:
  what: "UserService class has 3 responsibilities"
  why: |
    Single Responsibility Principle states each class should have
    only one reason to change. Multiple responsibilities make the
    class harder to test, maintain, and understand.

  how: |
    Extract separate classes:
    1. UserService â†’ user CRUD operations only
    2. EmailService â†’ email notifications
    3. AuditLogger â†’ audit trail logging

  reference: "https://docs.agentpm.dev/principles/solid/srp"

  before: |
    class UserService:
        def create_user(self): ...
        def send_welcome_email(self): ...
        def log_user_creation(self): ...

  after: |
    class UserService:
        def __init__(self, email: EmailService, audit: AuditLogger):
            self.email = email
            self.audit = audit

        def create_user(self):
            user = self._create_user_record()
            self.email.send_welcome(user)
            self.audit.log_creation(user)
            return user
```

---

## ðŸ”— Integration with AIPM Rules

### Mapping Strategy

| Principle Agent | Enforces Rules | Category |
|----------------|----------------|----------|
| `solid-agent` | CQ-031, CQ-033, CQ-038, CQ-039, DP-035 | Code Quality |
| `dry-agent` | CQ-021 to CQ-030 | Function Quality |
| `kiss-agent` | DP-021 to DP-024 | Code Complexity |
| `yagni-agent` | DP-023, CQ-019 | Code Simplicity |
| `test-pyramid-agent` | TEST-001 to TEST-020 | Testing |
| `tdd-agent` | WR-006 | Workflow |
| `security-first-agent` | DP-036 to DP-045 | Security |
| `time-boxing-agent` | DP-001 to DP-011 | Time Management |
| `incremental-agent` | WF-001 to WF-010 | Git Workflow |
| `clarity-agent` | DOC-001 to DOC-025 | Documentation |
| `handover-agent` | DOC-021 to DOC-025 | Handover Docs |

### Rule Activation
```python
# When user enables rules via questionnaire
def activate_principle_agents(rules: List[Rule]) -> List[PrincipleAgent]:
    """
    Map enabled rules to corresponding principle agents
    """
    agents = []

    # Check if SOLID rules enabled
    solid_rules = ["CQ-031", "CQ-033", "CQ-038", "CQ-039", "DP-035"]
    if any(r.rule_id in solid_rules for r in rules if r.enabled):
        agents.append(SOLIDAgent(db))

    # Check if DRY rules enabled
    dry_rules = [f"CQ-{i:03d}" for i in range(21, 31)]
    if any(r.rule_id in dry_rules for r in rules if r.enabled):
        agents.append(DRYAgent(db))

    # ... continue for other principles

    return agents
```

---

## ðŸš€ Usage Examples

### Example 1: Code Review Workflow
```python
# Developer commits code
git commit -m "feat: Add user authentication"

# Pre-commit hook triggers principle agents
agents = [
    SOLIDAgent(db),
    DRYAgent(db),
    SecurityFirstAgent(db),
    TestPyramidAgent(db)
]

reports = []
for agent in agents:
    report = agent.analyze("src/auth/")
    reports.append(report)

# Aggregate results
if all(r.passed for r in reports):
    print("âœ… All principle checks passed")
else:
    print("âŒ Principle violations found:")
    for report in reports:
        if not report.passed:
            print(f"\n{report.agent_name}:")
            for violation in report.violations:
                print(f"  - {violation.location}: {violation.issue}")
```

### Example 2: Progressive Quality Gates
```python
# Phase 1: Make It Work
make_it_work = MakeItWorkAgent(db)
if not make_it_work.analyze(code_path).passed:
    raise Exception("Functionality not working - fix before proceeding")

# Phase 2: Make It Right
make_it_right = MakeItRightAgent(db)
report = make_it_right.analyze(code_path)
if not report.passed:
    print("Refactoring recommendations:")
    for violation in report.violations:
        print(f"  - {violation.recommendation}")

# Phase 3: Make It Fast
make_it_fast = MakeItFastAgent(db)
perf_report = make_it_fast.analyze(code_path)
if perf_report.metrics['response_time_p95'] > 200:
    print("Performance optimization needed")
```

### Example 3: Continuous Learning
```python
# Track principle violations over time
def track_principle_adherence(project_id: int, agent: PrincipleAgent):
    """
    Track how well team adheres to principles over time
    """
    report = agent.analyze(f"projects/{project_id}/")

    metrics = {
        'date': datetime.now(),
        'principle': agent.principle,
        'violations': len(report.violations),
        'severity_high': len([v for v in report.violations if v.severity == 'HIGH']),
        'severity_medium': len([v for v in report.violations if v.severity == 'MEDIUM']),
        'files_analyzed': report.metrics['files_analyzed']
    }

    db.principle_metrics.insert(project_id, metrics)

    # Visualize trend
    trend = db.principle_metrics.get_trend(project_id, agent.principle, days=30)
    if trend['violations'] < trend['violations_30d_ago']:
        print(f"âœ… {agent.principle} adherence improving (+{trend['improvement']}%)")
```

---

## ðŸ“ˆ Metrics & Dashboards

### Principle Adherence Dashboard
```yaml
project: "E-commerce Platform"
date: "2025-10-14"

principle_scores:
  SOLID: 85%     # âœ… Good
  DRY: 92%       # âœ… Excellent
  KISS: 78%      # âš ï¸ Needs attention
  Security: 95%  # âœ… Excellent
  Testing: 87%   # âœ… Good

trends_30d:
  SOLID: +5%
  DRY: +2%
  KISS: -3%      # âš ï¸ Declining

top_violations:
  1. "God objects (SRP)" - 12 occurrences
  2. "High cyclomatic complexity (KISS)" - 8 occurrences
  3. "Duplicate validation logic (DRY)" - 6 occurrences
```

---

## ðŸ› ï¸ Implementation Roadmap

### Phase 1: Foundation (Week 1-2)
- [x] Design principle agent architecture
- [ ] Implement base `PrincipleAgent` class
- [ ] Create agent-to-rule mapping system
- [ ] Implement `SOLIDAgent` (pilot)
- [ ] Add to CI/CD pipeline

### Phase 2: Core Principles (Week 3-4)
- [ ] Implement `DRYAgent`
- [ ] Implement `KISSAgent`
- [ ] Implement `YAGNIAgent`
- [ ] Implement `TestPyramidAgent`
- [ ] Add metrics dashboard

### Phase 3: Workflow Principles (Week 5-6)
- [ ] Implement `TimeBoxingAgent`
- [ ] Implement `IncrementalAgent`
- [ ] Implement `TDDAgent`
- [ ] Add agent orchestration patterns

### Phase 4: Quality & Communication (Week 7-8)
- [ ] Implement `SecurityFirstAgent`
- [ ] Implement `ClarityAgent`
- [ ] Implement `HandoverAgent`
- [ ] Add educational explanations

### Phase 5: Progressive Quality (Week 9-10)
- [ ] Implement `MakeItWorkAgent`
- [ ] Implement `MakeItRightAgent`
- [ ] Implement `MakeItFastAgent`
- [ ] Create comprehensive test suite

---

## ðŸŽ¯ Success Criteria

### Technical Metrics
- [ ] 11+ principle agents implemented
- [ ] All agents mapped to rules catalog
- [ ] 90%+ test coverage for agents
- [ ] <1s analysis time per file
- [ ] Educational explanations for all violations

### Adoption Metrics
- [ ] 80%+ of violations have clear recommendations
- [ ] 50%+ reduction in principle violations over 3 months
- [ ] Positive developer feedback (4+/5 rating)
- [ ] Integration with existing AIPM workflow

### Learning Metrics
- [ ] Developers can explain principle after violation
- [ ] Reduced repeat violations (-60% over 6 months)
- [ ] Improved code quality scores
- [ ] Increased principle adherence in new code

---

## ðŸ“š References

- **SOLID Principles**: Robert C. Martin, "Clean Architecture"
- **DRY Principle**: Andy Hunt & Dave Thomas, "The Pragmatic Programmer"
- **KISS Principle**: Kelly Johnson, Lockheed Skunk Works
- **YAGNI Principle**: Kent Beck, Extreme Programming
- **Test Pyramid**: Mike Cohn, "Succeeding with Agile"
- **Make It Work/Right/Fast**: Kent Beck

---

## ðŸ”® Future Enhancements

### Advanced Agents
- `martin-fowler-agent`: Refactoring patterns specialist
- `gang-of-four-agent`: Design patterns validator
- `clean-code-agent`: Comprehensive code quality (Uncle Bob)
- `architecture-agent`: System-level architecture patterns

### AI-Powered Features
- Natural language violation explanations
- Automated refactoring suggestions
- Context-aware recommendations
- Learning from team patterns

### Team Collaboration
- Principle adoption tracking per developer
- Team-wide principle dashboards
- Gamification (principle mastery badges)
- Peer learning recommendations

---

**Document Status**: âœ… Concept Complete - Ready for Technical Design
**Next Steps**:
1. Review with team for feedback
2. Create technical implementation plan
3. Prioritize agents for MVP
4. Design integration with existing AIPM workflow

---

*Generated: 2025-10-14 by Claude Code*
*Work Item: Principle-Based Agents Exploration*
