# Agent Storage Architecture Design

**Status**: DESIGN PROPOSAL
**Version**: 1.0.0
**Date**: 2025-10-17
**Author**: System Architect

---

## Executive Summary

**Problem**: Current agent definitions stored in `.claude/agents/` are Claude Code-specific. System needs provider-agnostic templates that generate provider-specific agents.

**Solution**: Three-tier architecture with YAML definitions, provider-specific plugins, and database synchronization.

**Key Decision**: **YAML + Database hybrid** with Jinja2 template generation.

---

## 1. Current State Analysis

### 1.1 Existing Structure

```
.claude/agents/                    # Claude Code-specific location
├── orchestrators/                 # 6 mini-orchestrators (tier 2)
├── sub-agents/                    # 31 sub-agents (tier 1)
└── utilities/                     # Utility agents

agentpm/templates/agents/          # Generic templates (15 files)
├── implementer.md                 # Domain-agnostic templates
├── tester.md
├── planner.md
└── ...

Database: agents table             # Single source of truth
├── id, role, display_name
├── sop_content (markdown)
├── agent_type (template type)
├── tier (1=sub-agent, 2=mini-orch, 3=master)
└── file_path (generated file location)
```

### 1.2 Problems Identified

1. **Provider Lock-In**: `.claude/agents/` ties system to Claude Code
2. **No Template System**: Templates in `agentpm/templates/agents/` not integrated with plugins
3. **Manual Generation**: No automatic provider-specific generation
4. **Database Mismatch**: Database stores agents but doesn't drive generation
5. **Plugin Gap**: LLM plugins exist but don't generate agents

---

## 2. Proposed Architecture

### 2.1 Three-Tier Storage Model

```
1. Definition Layer (YAML - Source of Truth)
   ├─ agentpm/core/agents/definitions/
   │  ├─ orchestrators.yaml          # Mini-orchestrators (6)
   │  ├─ sub-agents.yaml             # Sub-agents (31)
   │  └─ specialists.yaml            # Role templates (15)
   │
2. Plugin Layer (Provider-Specific Templates)
   ├─ agentpm/core/plugins/domains/llms/
   │  ├─ anthropic/claude-code/
   │  │  ├─ templates/
   │  │  │  ├─ orchestrator.md.j2   # Jinja2 templates
   │  │  │  ├─ sub-agent.md.j2
   │  │  │  └─ specialist.md.j2
   │  │  └─ generator.py             # ClaudeCodeAgentGenerator
   │  │
   │  ├─ google/gemini/
   │  │  ├─ templates/
   │  │  │  └─ gemini-agent.xml.j2  # Gemini-specific format
   │  │  └─ generator.py
   │  │
   │  └─ openai/codex/               # Future
   │     └─ ...
   │
3. Database Layer (Runtime State)
   ├─ agents table                   # Active agent instances
   └─ agent_relationships            # Orchestration hierarchy
```

### 2.2 Data Flow

```
YAML Definition → AgentBuilder API → Database → Plugin Generator → Provider Files

orchestrators.yaml  →  create_orchestrator()  →  agents table  →  ClaudeCodeGenerator  →  .claude/agents/
                                                                 →  GeminiGenerator     →  .gemini/agents/
                                                                 →  CursorGenerator     →  .cursor/agents/
```

---

## 3. Detailed Component Design

### 3.1 Definition Layer (YAML)

**Location**: `agentpm/core/agents/definitions/`

**Format**: YAML (human-readable, versionable, declarative)

**Example**: `orchestrators.yaml`

```yaml
# agentpm/core/agents/definitions/orchestrators.yaml

orchestrators:
  definition-orch:
    tier: 2
    orchestrator_type: mini
    display_name: "Definition Orchestrator"
    description: "Requirements & Scope Definition orchestrator for D1 gate"
    phase: definition
    gate: D1

    sop_sections:
      role: |
        You are the **Definition Orchestrator**. You coordinate requirements definition.

      responsibilities:
        - Triage incoming requests
        - Assemble project context
        - Frame problem with constraints
        - Articulate business/user value
        - Define acceptance criteria (≥3)
        - Identify and assess risks

      delegates_to:
        - intent-triage
        - context-assembler
        - problem-framer
        - value-articulator
        - ac-writer
        - risk-notary

      gate_requirements:
        why_value: "Business and user value articulated"
        acceptance_criteria: "Minimum 3 testable criteria"
        risks: "Identified with mitigation strategies"
        confidence: "≥0.70 confidence score"

      output_artifact: "workitem.ready"

    tools:
      - name: context7
        phase: discovery
        priority: 1
        purpose: "Library documentation and patterns"

      - name: sequential-thinking
        phase: reasoning
        priority: 1
        purpose: "Multi-step reasoning and analysis"

    metadata:
      execution_mode: parallel
      symbol_mode: enabled
      version: "1.0.0"

  planning-orch:
    # ... similar structure ...
```

**Rationale for YAML**:
- ✅ Human-readable and editable
- ✅ Version control friendly
- ✅ Declarative structure
- ✅ Easy validation (JSON Schema)
- ✅ Standard format (PyYAML library)
- ✅ Supports comments and multi-line strings

**Alternative Considered**: Python dataclasses
- ❌ Less human-readable
- ❌ Requires Python to view/edit
- ❌ Harder for non-developers

### 3.2 Plugin Layer (Provider-Specific)

**Location**: `agentpm/core/plugins/domains/llms/{provider}/{tool}/`

**Structure**:

```python
# agentpm/core/plugins/domains/llms/anthropic/claude-code/generator.py

from typing import Dict, Any
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
from agentpm.core.agents.builder import AgentDefinition


class ClaudeCodeAgentGenerator:
    """Generate Claude Code-specific agent markdown files."""

    def __init__(self, output_dir: Path = Path(".claude/agents")):
        self.output_dir = output_dir
        self.template_dir = Path(__file__).parent / "templates"
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(self.template_dir)),
            trim_blocks=True,
            lstrip_blocks=True
        )

    def generate(self, definition: AgentDefinition, db_agent: Agent) -> Path:
        """
        Generate Claude Code agent file from definition + database state.

        Args:
            definition: YAML agent definition
            db_agent: Database agent record (runtime state)

        Returns:
            Path to generated .md file
        """
        # Select template based on tier
        template_name = {
            1: "sub-agent.md.j2",
            2: "orchestrator.md.j2",
            3: "master-orchestrator.md.j2"
        }[db_agent.tier]

        template = self.jinja_env.get_template(template_name)

        # Combine definition + database state
        context = {
            **definition.dict(),
            "agent_id": db_agent.id,
            "is_active": db_agent.is_active,
            "created_at": db_agent.created_at,
            "relationships": self._load_relationships(db_agent.id),
            "tools": self._load_tools(db_agent.id)
        }

        # Render template
        content = template.render(**context)

        # Write to provider-specific location
        output_path = self.output_dir / f"{db_agent.tier_name}s" / f"{db_agent.role}.md"
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(content)

        return output_path
```

**Template Example**: `templates/orchestrator.md.j2`

```jinja2
---
name: {{ role }}
description: {{ description }}
tools: {{ tools | map(attribute='name') | join(', ') }}
tier: {{ tier }}
orchestrator_type: {{ orchestrator_type }}
---

You are the **{{ display_name }}**.

## Responsibilities

{{ sop_sections.responsibilities | to_markdown }}

## Delegates To

{% for sub_agent in sop_sections.delegates_to %}
- `{{ sub_agent }}` - {{ get_sub_agent_description(sub_agent) }}
{% endfor %}

## Gate Requirements ({{ gate }})

{% for requirement, description in sop_sections.gate_requirements.items() %}
- **{{ requirement }}**: {{ description }}
{% endfor %}

## Tools Available

{% for tool in tools %}
### {{ tool.name }}
- **Phase**: {{ tool.phase }}
- **Purpose**: {{ tool.purpose }}
- **Priority**: {{ tool.priority }}
{% endfor %}

## Output Artifact

`{{ sop_sections.output_artifact }}`

---

**Database ID**: {{ agent_id }}
**Active**: {{ is_active }}
**Generated**: {{ generated_at }}
**Version**: {{ metadata.version }}
```

### 3.3 Database Layer (Runtime)

**Existing Schema** (no changes needed):

```python
# agentpm/core/database/models/agent.py

class Agent(BaseModel):
    id: Optional[int]
    project_id: int
    role: str                      # e.g., "definition-orch"
    display_name: str
    description: Optional[str]
    sop_content: Optional[str]     # Generated markdown (cache)
    capabilities: list[str]
    is_active: bool
    agent_type: Optional[str]      # Template type
    file_path: Optional[str]       # Generated file location
    generated_at: Optional[datetime]
    tier: Optional[AgentTier]      # 1=sub-agent, 2=mini-orch, 3=master
    last_used_at: Optional[datetime]
    metadata: Optional[str]        # JSON
```

**Synchronization Strategy**:

```python
# agentpm/core/agents/sync.py

class AgentSynchronizer:
    """Sync YAML definitions → Database → Provider files."""

    def sync_all(self):
        """Full synchronization workflow."""

        # 1. Load YAML definitions
        definitions = self._load_yaml_definitions()

        # 2. Sync to database (create/update)
        for definition in definitions:
            agent = self._sync_to_database(definition)

        # 3. Detect current LLM provider
        provider = self._detect_provider()

        # 4. Generate provider-specific files
        generator = self._get_generator(provider)
        for agent in self.db.agents.list_all():
            definition = self._find_definition(agent.role)
            generator.generate(definition, agent)

    def _detect_provider(self) -> str:
        """Detect current LLM provider."""
        if Path(".claude").exists():
            return "anthropic/claude-code"
        elif Path(".gemini").exists():
            return "google/gemini"
        elif Path(".cursor").exists():
            return "cursor"
        else:
            return "generic"
```

---

## 4. Design Decisions & Rationale

### Decision 1: YAML vs Python Dataclasses

**Choice**: YAML

**Rationale**:
- **Human-editable**: Non-developers can modify definitions
- **Version control**: Diffs are readable
- **Declarative**: Clear structure
- **Standard**: Widely understood format
- **Tooling**: JSON Schema validation, editors with autocomplete

**Trade-offs**:
- ❌ No type safety (mitigated by JSON Schema validation)
- ❌ Runtime parsing cost (minimal, one-time)
- ✅ Flexibility for complex structures
- ✅ Easy to extend

### Decision 2: Jinja2 vs Programmatic Generation

**Choice**: Jinja2 Templates

**Rationale**:
- **Separation of Concerns**: Logic separate from presentation
- **Maintainability**: Templates easier to modify than code
- **Provider-Specific**: Each provider can customize templates
- **Familiar**: Jinja2 widely known
- **Powerful**: Filters, macros, inheritance

**Trade-offs**:
- ❌ Learning curve (minimal for Jinja2)
- ✅ Flexibility for different output formats
- ✅ Easy to add new providers

### Decision 3: Database as Source of Truth vs Files

**Choice**: Hybrid (YAML definitions → Database → Generated files)

**Rationale**:
- **YAML**: Canonical definitions (version controlled)
- **Database**: Runtime state (active, last_used, relationships)
- **Generated Files**: Provider consumption (ephemeral, regenerable)

**Flow**:
```
YAML (git) → Database (runtime) → Provider Files (ephemeral)
   ↑              ↓                      ↓
  Edit        Track usage          Consumed by LLM
```

**Trade-offs**:
- ✅ Single source of truth (YAML + Database hybrid)
- ✅ Version control for definitions
- ✅ Runtime state tracking
- ✅ Provider-agnostic core
- ❌ Two-step sync process (acceptable complexity)

### Decision 4: Plugin Location

**Choice**: `agentpm/core/plugins/domains/llms/{provider}/`

**Rationale**:
- **Consistency**: Matches existing plugin architecture
- **Discovery**: Follows established detection pattern
- **Isolation**: Provider-specific code encapsulated
- **Extensibility**: Easy to add new providers

**Structure Matches**:
```
agentpm/core/plugins/domains/
├─ languages/python/     # Existing
├─ testing/pytest/       # Existing
└─ llms/                 # NEW
   ├─ anthropic/
   ├─ google/
   └─ openai/
```

---

## 5. Implementation Phases

### Phase 1: Foundation (Week 1)

**Goals**:
- Define YAML schema
- Create base generator interface
- Implement Claude Code generator
- Sync existing agents to YAML

**Deliverables**:
- `agentpm/core/agents/definitions/orchestrators.yaml`
- `agentpm/core/agents/definitions/sub-agents.yaml`
- `agentpm/core/agents/definitions/specialists.yaml`
- `agentpm/core/plugins/domains/llms/anthropic/claude-code/generator.py`
- `agentpm/core/agents/sync.py`

**Tasks**:
1. Define YAML schema (JSON Schema for validation)
2. Export existing database agents to YAML
3. Create Jinja2 templates for Claude Code
4. Implement ClaudeCodeAgentGenerator
5. Implement AgentSynchronizer
6. Test generation workflow

### Phase 2: Provider Expansion (Week 2)

**Goals**:
- Add Google Gemini support
- Implement provider auto-detection
- Add CLI commands for agent management

**Deliverables**:
- `agentpm/core/plugins/domains/llms/google/gemini/generator.py`
- `apm agents sync` command
- `apm agents generate --provider=<name>` command

**Tasks**:
1. Implement GeminiAgentGenerator
2. Create Gemini-specific templates
3. Add provider detection logic
4. Create CLI commands
5. Test multi-provider generation

### Phase 3: Advanced Features (Week 3)

**Goals**:
- Add agent versioning
- Implement staleness detection
- Add validation and testing

**Deliverables**:
- Agent version tracking
- Automatic regeneration triggers
- Comprehensive test suite

**Tasks**:
1. Add version field to YAML definitions
2. Implement staleness detection (compare YAML vs generated)
3. Add automatic regeneration on definition changes
4. Write tests for all generators
5. Document architecture

---

## 6. Provider-Specific Examples

### 6.1 Claude Code (Anthropic)

**Output Location**: `.claude/agents/{tier}/{role}.md`

**Format**: Markdown with YAML frontmatter

**Example**:
```markdown
---
name: definition-orch
description: Definition Orchestrator
tools: context7, sequential-thinking
---

You are the **Definition Orchestrator**.
...
```

### 6.2 Google Gemini

**Output Location**: `.gemini/agents/{role}.xml`

**Format**: XML (Gemini's agent format)

**Example**:
```xml
<agent id="definition-orch" tier="2">
  <name>Definition Orchestrator</name>
  <description>Requirements &amp; Scope Definition</description>
  <tools>
    <tool name="context7" priority="1"/>
    <tool name="sequential-thinking" priority="1"/>
  </tools>
  <sop>
    <![CDATA[
    You are the **Definition Orchestrator**.
    ...
    ]]>
  </sop>
</agent>
```

### 6.3 Generic/Fallback

**Output Location**: `.agentpm/agents/{role}.txt`

**Format**: Plain text (no special markup)

---

## 7. API Examples

### 7.1 Agent Synchronization

```python
# Example 1: Sync all agents from YAML to database and generate files
from agentpm.core.agents.sync import AgentSynchronizer

sync = AgentSynchronizer(db, project_path)
sync.sync_all()  # YAML → DB → Provider files
```

### 7.2 Provider-Specific Generation

```python
# Example 2: Generate for specific provider
from agentpm.core.plugins.domains.llms.anthropic.claude_code.generator import ClaudeCodeAgentGenerator

generator = ClaudeCodeAgentGenerator(output_dir=Path(".claude/agents"))

# Load definition and database agent
definition = load_yaml_definition("definition-orch")
db_agent = db.agents.get_by_role("definition-orch")

# Generate
output_path = generator.generate(definition, db_agent)
print(f"Generated: {output_path}")
```

### 7.3 CLI Commands

```bash
# Sync all agents (YAML → DB → Files)
apm agents sync

# Generate for specific provider
apm agents generate --provider=gemini

# Force regeneration (even if not stale)
apm agents sync --force

# List stale agents (need regeneration)
apm agents list --stale

# Export database agents to YAML
apm agents export --output=definitions/
```

---

## 8. Validation & Testing

### 8.1 YAML Schema Validation

```python
# JSON Schema for orchestrators.yaml
ORCHESTRATOR_SCHEMA = {
    "type": "object",
    "properties": {
        "orchestrators": {
            "type": "object",
            "patternProperties": {
                "^[a-z-]+$": {
                    "type": "object",
                    "required": ["tier", "display_name", "phase", "gate"],
                    "properties": {
                        "tier": {"enum": [1, 2, 3]},
                        "orchestrator_type": {"enum": ["master", "mini"]},
                        "display_name": {"type": "string"},
                        "phase": {"type": "string"},
                        "gate": {"type": "string"},
                        "sop_sections": {"type": "object"},
                        "tools": {"type": "array"}
                    }
                }
            }
        }
    }
}
```

### 8.2 Integration Tests

```python
# tests/core/agents/test_sync.py

def test_yaml_to_database_sync():
    """Test YAML definitions sync to database correctly."""
    sync = AgentSynchronizer(db, project_path)
    sync.sync_all()

    # Verify orchestrators created
    definition_orch = db.agents.get_by_role("definition-orch")
    assert definition_orch.tier == 2
    assert definition_orch.orchestrator_type == "mini"

def test_provider_generation():
    """Test provider-specific file generation."""
    generator = ClaudeCodeAgentGenerator()
    definition = load_yaml_definition("definition-orch")
    db_agent = db.agents.get_by_role("definition-orch")

    output_path = generator.generate(definition, db_agent)
    assert output_path.exists()
    assert "Definition Orchestrator" in output_path.read_text()
```

---

## 9. Migration Strategy

### 9.1 Existing Agents

**Current State**: 38 agents in database, files in `.claude/agents/`

**Migration Steps**:

```python
# scripts/migrate_agents_to_yaml.py

def migrate_existing_agents():
    """Export existing database agents to YAML definitions."""

    orchestrators = {}
    sub_agents = {}

    for agent in db.agents.list_all():
        if agent.tier == 2:
            orchestrators[agent.role] = export_orchestrator(agent)
        elif agent.tier == 1:
            sub_agents[agent.role] = export_sub_agent(agent)

    # Write YAML files
    write_yaml("definitions/orchestrators.yaml", {"orchestrators": orchestrators})
    write_yaml("definitions/sub-agents.yaml", {"sub_agents": sub_agents})
```

**Validation**:
1. Export existing agents → YAML
2. Sync YAML → new database
3. Compare old vs new database
4. Generate files from new database
5. Compare old vs new files (should be identical)

### 9.2 Backward Compatibility

**Strategy**: Keep `.claude/agents/` files during transition

**Timeline**:
- **Phase 1 (Weeks 1-2)**: Dual system (old files + new generation)
- **Phase 2 (Weeks 3-4)**: New generation primary, old files deprecated
- **Phase 3 (Week 5+)**: Remove old manual files

---

## 10. Success Criteria

### 10.1 Functional Requirements

- ✅ YAML definitions are single source of truth for agent structure
- ✅ Database tracks runtime state (active, usage, relationships)
- ✅ Providers can generate agent files from definitions + database
- ✅ New providers can be added without changing core system
- ✅ Existing agents migrate cleanly to new system
- ✅ CLI commands for sync, generate, validate

### 10.2 Non-Functional Requirements

- ✅ Generation time: <1s for all agents
- ✅ YAML validation catches errors before database sync
- ✅ Provider detection is automatic
- ✅ Staleness detection triggers regeneration
- ✅ Backward compatible with existing database schema

### 10.3 Quality Gates

- ✅ All YAML definitions validate against schema
- ✅ Generated files match expected output format
- ✅ Database sync is idempotent (repeat = same result)
- ✅ Test coverage ≥90% for all components
- ✅ Documentation complete for all public APIs

---

## 11. Open Questions

### 11.1 Resolved

**Q**: Should templates be in database or filesystem?
**A**: Filesystem (easier to version, edit, customize per provider)

**Q**: How to handle provider-specific extensions?
**A**: Provider plugins can add custom fields to metadata JSON

**Q**: What if provider doesn't support certain features?
**A**: Graceful degradation in templates (Jinja2 conditionals)

### 11.2 To Be Resolved

**Q**: Should YAML definitions support includes/inheritance?
**A**: TBD - evaluate after Phase 1 (might use YAML anchors)

**Q**: How to version agent definitions?
**A**: TBD - consider semantic versioning in YAML

**Q**: Should we support hot-reload of agent definitions?
**A**: TBD - evaluate need after Phase 2

---

## 12. References

**Related Documents**:
- `docs/reports/MINI_ORCHESTRATORS_DEFINED.md` - Current orchestrator definitions
- `agentpm/core/plugins/base/plugin_interface.py` - Plugin architecture
- `agentpm/core/database/models/agent.py` - Agent database schema
- `agentpm/templates/agents/` - Existing generic templates

**External References**:
- [Jinja2 Documentation](https://jinja.palletsprojects.com/)
- [YAML Specification](https://yaml.org/spec/1.2.2/)
- [JSON Schema](https://json-schema.org/)

---

## Appendix A: Complete File Structure

```
agentpm/
├─ core/
│  ├─ agents/
│  │  ├─ definitions/                    # NEW: YAML definitions
│  │  │  ├─ orchestrators.yaml          # 6 mini-orchestrators
│  │  │  ├─ sub-agents.yaml             # 31 sub-agents
│  │  │  ├─ specialists.yaml            # 15 role templates
│  │  │  └─ schema.json                 # JSON Schema validation
│  │  ├─ builder.py                     # Existing AgentBuilder
│  │  ├─ sync.py                        # NEW: Synchronizer
│  │  └─ loader.py                      # NEW: YAML loader
│  │
│  ├─ plugins/
│  │  ├─ domains/
│  │  │  ├─ llms/                       # NEW: LLM provider plugins
│  │  │  │  ├─ __init__.py
│  │  │  │  ├─ base.py                  # AgentGeneratorInterface
│  │  │  │  ├─ anthropic/
│  │  │  │  │  └─ claude-code/
│  │  │  │  │     ├─ __init__.py
│  │  │  │  │     ├─ generator.py       # ClaudeCodeAgentGenerator
│  │  │  │  │     └─ templates/
│  │  │  │  │        ├─ master-orchestrator.md.j2
│  │  │  │  │        ├─ orchestrator.md.j2
│  │  │  │  │        ├─ sub-agent.md.j2
│  │  │  │  │        └─ specialist.md.j2
│  │  │  │  ├─ google/
│  │  │  │  │  └─ gemini/
│  │  │  │  │     ├─ generator.py
│  │  │  │  │     └─ templates/
│  │  │  │  │        └─ gemini-agent.xml.j2
│  │  │  │  └─ openai/                  # Future
│  │  │  │     └─ codex/
│  │
│  ├─ database/
│  │  ├─ models/
│  │  │  └─ agent.py                    # Existing (no changes)
│  │
│  └─ templates/
│     └─ agents/                        # Existing generic templates
│        └─ implementer.md              # To be deprecated

scripts/
├─ migrate_agents_to_yaml.py           # NEW: Export DB → YAML
└─ validate_agent_definitions.py       # NEW: YAML validation

.claude/agents/                         # Generated (ephemeral)
├─ orchestrators/
│  └─ definition-orch.md               # Generated from YAML
├─ sub-agents/
│  └─ intent-triage.md                 # Generated from YAML
└─ specialists/
   └─ implementer.md                   # Generated from YAML

.gemini/agents/                         # Generated (if Gemini detected)
└─ definition-orch.xml                 # XML format for Gemini
```

---

## Appendix B: Example YAML Definition (Complete)

```yaml
# agentpm/core/agents/definitions/orchestrators.yaml

version: "1.0.0"
schema_version: "1.0"

orchestrators:
  definition-orch:
    tier: 2
    orchestrator_type: mini
    display_name: "Definition Orchestrator"
    description: "Requirements & Scope Definition orchestrator for D1 gate"
    phase: definition
    gate: D1

    sop_sections:
      role: |
        You are the **Definition Orchestrator**. You coordinate requirements
        definition phase work, delegating to specialized sub-agents until the
        D1 gate passes.

      responsibilities:
        - Triage incoming requests (classify type and scope)
        - Assemble project context from database
        - Frame problem with constraints
        - Articulate business and user value
        - Define acceptance criteria (minimum 3, testable)
        - Identify risks with mitigation strategies

      delegates_to:
        - role: intent-triage
          description: "Classify request type and scope"
        - role: context-assembler
          description: "Gather project context from database"
        - role: problem-framer
          description: "Frame problem with constraints"
        - role: value-articulator
          description: "Articulate business/user value"
        - role: ac-writer
          description: "Define acceptance criteria"
        - role: risk-notary
          description: "Identify and assess risks"

      gate_requirements:
        why_value:
          description: "Business and user value articulated"
          validation: "Check why_value field in work item"

        acceptance_criteria:
          description: "Minimum 3 testable criteria"
          validation: "Count acceptance_criteria array length ≥ 3"

        risks:
          description: "Risks identified with mitigations"
          validation: "Check risks field has entries with mitigation strategies"

        confidence:
          description: "Confidence score ≥0.70"
          validation: "Check context confidence_score ≥ 0.70"

      output_artifact: "workitem.ready"

      prohibited_actions:
        - "Never implement code (delegate to Implementation Orchestrator)"
        - "Never write tests (delegate to Review & Test Orchestrator)"
        - "Never skip gate checks (always validate D1 before advancing)"

    tools:
      - name: context7
        phase: discovery
        priority: 1
        purpose: "Library documentation and framework patterns"
        usage: "Use for researching existing patterns"

      - name: sequential-thinking
        phase: reasoning
        priority: 1
        purpose: "Multi-step reasoning and analysis"
        usage: "Use for complex problem decomposition"

    metadata:
      execution_mode: parallel
      symbol_mode: enabled
      version: "1.0.0"
      created_at: "2025-10-12"
      updated_at: "2025-10-17"
```

---

**Status**: READY FOR REVIEW
**Next Step**: Technical review → Approval → Phase 1 implementation
**Estimated Effort**: 3 weeks (Phase 1: 1 week, Phase 2: 1 week, Phase 3: 1 week)
