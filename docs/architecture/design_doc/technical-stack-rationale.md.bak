# APM Technical Stack Rationale

**Status**: Active Documentation
**Date**: 2025-10-25
**Purpose**: Explain WHY specific technologies and architectural patterns were chosen
**Audience**: Developers, contributors, technical decision-makers

---

## Overview

This document provides the **technical rationale** for APM's technology stack and architectural decisions. Every choice is explained with clear reasoning focused on **AI agent reliability**, **quality enforcement**, and **developer experience**.

**Core Philosophy**: Standard, proven technologies optimized for AI agent compatibility and safety.

---

## Technology Stack

### Python 3.9+ (Primary Language)

**Decision**: Python as the primary implementation language

**Rationale**:

1. **Universal AI Agent Compatibility**
   - All major AI coding tools support Python (Claude Code, Cursor, GitHub Copilot, Aider)
   - Widest adoption among AI-assisted development tools
   - Ensures maximum compatibility across providers

2. **Rich Ecosystem**
   - Mature libraries for CLI (Click), validation (Pydantic), databases (SQLite)
   - Strong data manipulation capabilities (essential for context assembly)
   - Excellent testing frameworks (pytest) with >90% coverage tooling

3. **Strong Type System**
   - Type hints + mypy enable compile-time validation
   - Prevents AI agent errors before runtime
   - Pydantic enforces data contracts between layers

4. **Interpreted Language Benefits**
   - No compilation step = faster AI agent iteration
   - Dynamic introspection supports plugin system
   - Easy to extend and modify

**Alternatives Considered**:
- ❌ TypeScript/Node.js: Limited AI agent tooling, weaker data validation
- ❌ Go: Compiled language slows iteration, less AI ecosystem support
- ❌ Rust: Too complex for CLI tools, steep learning curve for contributors

---

### SQLite (Database)

**Decision**: SQLite as the primary database for per-project storage

**Rationale**:

1. **Zero Configuration**
   - Single file database (`.agentpm/data/agentpm.db`)
   - No server setup or configuration
   - Works immediately after `apm init`
   - Perfect for per-project isolation

2. **ACID Transactions**
   - Ensures data integrity when multiple AI agents work concurrently
   - Prevents corrupted state from agent failures
   - Rollback support for failed operations
   - Critical for quality gate enforcement

3. **Full-Text Search (FTS5)**
   - Built-in FTS5 extension for document search
   - No external search engine required
   - Fast queries across contexts, documents, evidence
   - Essential for context assembly performance

4. **Scalability**
   - Handles 1M+ rows easily
   - Sufficient for complex projects (10K+ tasks, 1K+ work items)
   - Scales to enterprise needs before requiring PostgreSQL

5. **Git-Friendly**
   - File-based storage works with version control
   - Can commit database with code
   - Enables team collaboration via Git
   - Portable across environments (dev, staging, prod)

6. **PostgreSQL Migration Path**
   - Three-layer architecture supports database swapping
   - Same adapters work with PostgreSQL (future enterprise feature)
   - Can migrate without application code changes

**Alternatives Considered**:
- ❌ PostgreSQL: Requires server setup, overkill for per-project use
- ❌ MongoDB: Schema flexibility not needed, no ACID guarantees
- ❌ JSON files: No transactions, no relational queries, poor integrity

**Trade-offs Accepted**:
- ⚠️ Write concurrency limits (acceptable for single-developer/small team use)
- ⚠️ No distributed queries (not needed for per-project architecture)

---

### Click 8.1+ (CLI Framework)

**Decision**: Click for command-line interface implementation

**Rationale**:

1. **Industry Standard**
   - De facto standard for Python CLIs
   - Familiar to developers (Flask, AWS CLI use Click)
   - Extensive documentation and community support

2. **Lazy-Loading Commands**
   - LazyGroup pattern enables <100ms startup time
   - Critical for AI agent responsiveness
   - Loads only required command code
   - Scales to 40+ commands without performance degradation

3. **Type-Safe Parameter Validation**
   - Automatic parameter parsing and validation
   - Prevents malformed AI agent inputs
   - Clear error messages guide agents to correct usage
   - Supports complex types (choices, ranges, paths)

4. **Excellent Help Generation**
   - Automatic `--help` for all commands
   - AI agents can discover available commands
   - Consistent interface across all commands

5. **Testing Support**
   - ClickRunner for isolated CLI testing
   - Can test commands without subprocess overhead
   - Essential for >90% coverage requirement

**Alternatives Considered**:
- ❌ argparse: Less ergonomic, no lazy-loading, verbose
- ❌ typer: Newer, less mature, fewer features than Click
- ❌ fire: Too magical, poor help text, harder to test

---

### Pydantic 2.5+ (Data Validation)

**Decision**: Pydantic for all data models and validation

**Rationale**:

1. **CRITICAL for AI Agent Reliability**
   - Validates all data before database storage
   - Prevents corrupted data from AI hallucinations
   - Type-safe serialization prevents runtime errors
   - Catches schema mismatches at model boundary

2. **Three-Layer Pattern Enforcement**
   - Models (domain objects) - Pydantic classes
   - Adapters (DB mapping) - Pydantic to/from SQLite
   - Methods (business logic) - Operates on Pydantic models
   - **MANDATORY pattern prevents direct DB access**

3. **Schema Evolution Safety**
   - Field validators catch breaking changes
   - Default values enable backward compatibility
   - Migrations can validate data integrity
   - Prevents schema drift between code and database

4. **JSON Serialization**
   - Automatic JSON ↔ Python object conversion
   - Essential for context assembly (JSON fields in DB)
   - Type-safe serialization of complex objects
   - No manual dict manipulation

5. **Performance**
   - Pydantic V2 uses Rust core (10-100x faster than V1)
   - Fast validation critical for context assembly pipeline
   - Minimal overhead for CLI operations

**Alternatives Considered**:
- ❌ dataclasses: No validation, manual JSON handling
- ❌ attrs: Less validation, smaller ecosystem
- ❌ marshmallow: Separate schema classes, more verbose

**Trade-offs Accepted**:
- ⚠️ Slight memory overhead (acceptable for CLI tool)
- ⚠️ Learning curve for contributors (mitigated by documentation)

---

### Rich 13.7+ (Terminal UI)

**Decision**: Rich for all terminal output formatting

**Rationale**:

1. **Professional Output**
   - Tables, panels, syntax highlighting
   - Improves AI agent feedback readability
   - Makes CLI output parseable by agents
   - Better than plain text for complex data

2. **Progress Feedback**
   - Progress bars for long operations (context assembly, migrations)
   - Spinners for background tasks
   - Provides visibility into agent actions
   - Prevents "is it working?" confusion

3. **Structured Output**
   - Consistent formatting across all commands
   - AI agents can parse table output reliably
   - JSON output mode for programmatic access
   - Human-friendly and machine-parseable

4. **Zero GUI Dependencies**
   - Terminal-only (no Electron, web UI required)
   - Works in SSH sessions, Docker containers
   - Lightweight and fast
   - Aligns with CLI-first philosophy

5. **Syntax Highlighting**
   - Code snippets in context output
   - Markdown rendering for documentation
   - Makes output more readable for humans reviewing agent work

**Alternatives Considered**:
- ❌ Plain print(): Poor readability, no structure
- ❌ colorama: Only colors, no tables/panels
- ❌ blessed: More complex API, less maintained

---

### pytest + pytest-cov (Testing)

**Decision**: pytest as the testing framework with coverage enforcement

**Rationale**:

1. **Industry Standard**
   - Most popular Python testing framework
   - Familiar to contributors
   - Extensive plugin ecosystem

2. **Excellent Fixture System**
   - Database fixtures for test isolation
   - Context assembly fixtures for integration tests
   - Reusable fixtures reduce boilerplate
   - Essential for three-layer testing

3. **Coverage Enforcement**
   - pytest-cov integrates seamlessly
   - Enforces >90% coverage requirement (CI-004 gate)
   - HTML reports show missing lines
   - Prevents undertested code from merging

4. **Async Support**
   - pytest-asyncio for future provider integrations
   - Ready for async context assembly
   - Supports async database operations

5. **Clear Output**
   - Excellent error reporting
   - Shows exactly where tests fail
   - Helps AI agents understand test failures
   - Supports debugging with `-vv` flag

**Alternatives Considered**:
- ❌ unittest: Verbose, less ergonomic, no fixtures
- ❌ nose: Deprecated, no longer maintained
- ❌ doctest: Not suitable for integration tests

---

### NetworkX 3.0+ (Graph Algorithms)

**Decision**: NetworkX for dependency graph operations

**Rationale**:

1. **Task Dependency Management**
   - Detects circular dependencies (Tarjan's algorithm)
   - Computes optimal task ordering (topological sort)
   - Identifies critical path for scheduling
   - Essential for quality workflow enforcement

2. **Code Relationship Analysis**
   - Import graphs for plugin system
   - Coupling metrics for architecture validation
   - Dependency visualization for documentation
   - Used by detection/graphs system

3. **Proven Algorithms**
   - Battle-tested graph algorithms
   - Correct implementations of complex algorithms
   - Well-documented API
   - No need to reinvent graph theory

4. **Visualization Support**
   - Can export DOT format for Graphviz
   - Enables dependency diagrams
   - Helps debug complex dependencies
   - Useful for documentation

**Alternatives Considered**:
- ❌ igraph: Python bindings to C library, harder to install
- ❌ graph-tool: Requires compilation, complex setup
- ❌ Custom implementation: Too complex, error-prone

---

## Architectural Patterns

### Three-Layer Architecture (Models → Adapters → Methods)

**Decision**: Mandatory three-layer pattern for all database operations

**Pattern**:
```
┌─────────────────────────────────────────┐
│ Methods (Business Logic)                │
│ - create_work_item()                    │
│ - validate_transition()                 │
│ - calculate_confidence()                │
└──────────────┬──────────────────────────┘
               │ Uses Pydantic Models
┌──────────────▼──────────────────────────┐
│ Adapters (Database Mapping)             │
│ - WorkItemAdapter.to_model()            │
│ - WorkItemAdapter.from_model()          │
│ - SQL query construction                │
└──────────────┬──────────────────────────┘
               │ SQLite Row ↔ Pydantic
┌──────────────▼──────────────────────────┐
│ Models (Domain Objects)                 │
│ - WorkItem (Pydantic model)             │
│ - Task (Pydantic model)                 │
│ - Context (Pydantic model)              │
└─────────────────────────────────────────┘
```

**Rationale**:

1. **MANDATORY for AI Agent Safety**
   - Prevents direct database manipulation
   - All data validated through Pydantic layer
   - No raw SQL in business logic
   - Type-safe at every layer

2. **Testability**
   - Mock adapters for unit tests
   - Test methods in isolation
   - Integration tests verify full stack
   - Clear boundaries for test strategies

3. **Type Safety**
   - Pydantic models enforce contracts
   - Adapters convert between representations
   - Methods operate on validated models
   - No `Dict[str, Any]` in public APIs

4. **Maintainability**
   - Clear separation of concerns
   - Models = domain (what is it?)
   - Adapters = persistence (how is it stored?)
   - Methods = business logic (what can we do?)
   - Changes isolated to appropriate layer

5. **Database Migration Path**
   - Can swap SQLite for PostgreSQL
   - Only adapters need changes
   - Models and methods unchanged
   - Proven migration strategy

**Trade-offs Accepted**:
- ⚠️ More code than direct DB access (acceptable for safety)
- ⚠️ Learning curve for contributors (mitigated by templates)

---

### Hexagonal Architecture (Ports & Adapters)

**Decision**: Hexagonal architecture for external integrations

**Pattern**:
```
        ┌────────────────────────┐
        │   Core Domain Logic    │
        │  (Work Items, Tasks)   │
        └──────────┬─────────────┘
                   │
        ┌──────────▼─────────────┐
        │    Port Interfaces     │
        │  - IProviderAdapter    │
        │  - IContextAssembler   │
        │  - IPluginDetector     │
        └──────────┬─────────────┘
                   │
    ┌──────────────┼──────────────┐
    │              │              │
┌───▼────┐   ┌────▼────┐   ┌────▼────┐
│ Claude │   │ Cursor  │   │  Aider  │
│Adapter │   │ Adapter │   │ Adapter │
└────────┘   └─────────┘   └─────────┘
```

**Rationale**:

1. **Provider Abstraction**
   - Swap Claude Code for Cursor without core changes
   - Add new AI providers by implementing adapter interface
   - Core logic doesn't know about specific providers
   - Critical for multi-provider support

2. **Testability**
   - Mock external systems (AI providers, Git, filesystem)
   - Test core logic in isolation
   - Integration tests verify adapters
   - No dependency on external services in unit tests

3. **Future-Proof**
   - Add new providers without breaking existing code
   - Plugin system follows same pattern
   - Context assembly is provider-agnostic
   - New integrations (Jira, Linear) fit naturally

4. **Clear Boundaries**
   - Core domain never imports provider code
   - Providers depend on core interfaces
   - Dependency inversion principle
   - Prevents tight coupling

**Trade-offs Accepted**:
- ⚠️ More abstraction layers (acceptable for flexibility)
- ⚠️ Interface maintenance overhead (acceptable for extensibility)

---

### Domain-Driven Design (DDD)

**Decision**: DDD principles for complex domain modeling

**Rationale**:

1. **Complex Domain**
   - Work items, tasks, dependencies, contexts, agents, rules
   - Multiple bounded contexts (workflow ≠ context ≠ plugins)
   - Rich domain logic (quality gates, state machines)
   - Not just CRUD operations

2. **Ubiquitous Language**
   - Shared vocabulary: proposed→validated→accepted→in_progress→review→completed
   - Same terms used by agents, humans, and code
   - Reduces miscommunication
   - Domain terms match database schema

3. **Bounded Contexts**
   - Workflow system (state management)
   - Context system (information assembly)
   - Plugin system (framework detection)
   - Detection system (SBOM, fitness)
   - Clear boundaries prevent feature creep

4. **Aggregates**
   - WorkItem is aggregate root (contains tasks)
   - Task is aggregate root (contains dependencies)
   - Context is value object (computed from work item + task)
   - Clear ownership and consistency boundaries

5. **Domain Events**
   - WorkItemCreated, TaskValidated, PhaseChanged
   - Enable audit trail
   - Support integrations (Slack, webhooks)
   - Decouple subsystems

**Trade-offs Accepted**:
- ⚠️ More upfront design (acceptable for complex domain)
- ⚠️ Requires domain expertise (mitigated by documentation)

---

### Database-First Architecture

**Decision**: Database as single source of truth, not files

**Pattern**:
```
┌─────────────────────────────────────┐
│      SQLite Database (Truth)        │
│  • work_items table                 │
│  • tasks table                      │
│  • contexts table (JSON)            │
│  • rules table (enforced)           │
│  • State machine triggers           │
└─────────────────────────────────────┘
         │
         │ Runtime queries
         │
┌────────▼────────────────────────────┐
│    Application (Reads Only)         │
│  • CLI commands                     │
│  • Agents query DB                  │
│  • Context assembly                 │
└─────────────────────────────────────┘

❌ _RULES/ directory = Documentation ONLY
❌ No file-based data storage
❌ No file-DB sync required
```

**Rationale**:

1. **Persistent Memory Across AI Sessions**
   - Agents never "forget" what was done
   - Context survives session restarts
   - Perfect recall of decisions and rationale
   - Critical for complex multi-session projects

2. **Single Source of Truth**
   - No file-database sync conflicts
   - Database is authoritative
   - Files are documentation only
   - Eliminates "which is right?" confusion

3. **Queryable History**
   - SQL queries for audit trails
   - Decision tracking with evidence
   - Session history and handover
   - Compliance and accountability

4. **Enforced Quality Gates**
   - SQLite triggers enforce state machine
   - Cannot bypass gates in application code
   - Database-level constraints
   - Agents cannot shortcut quality

5. **Team Collaboration**
   - Shared database in Git repo
   - All team members see same state
   - No "sync my local state" issues
   - Works with CI/CD pipelines

**Trade-offs Accepted**:
- ⚠️ Binary database file (not human-readable, but Git handles diffs)
- ⚠️ Schema migrations required (mitigated by migration system)

---

### Per-Project Database (not global)

**Decision**: Each project has its own `.agentpm/data/agentpm.db` file

**Rationale**:

1. **Isolation**
   - Project A doesn't affect project B
   - Independent schema versions per project
   - No cross-project contamination
   - Parallel project work without conflicts

2. **Portability**
   - `.agentpm/` folder contains complete project state
   - Move project = move database
   - No external dependencies
   - Works offline

3. **Version Control Friendly**
   - Commit database with code
   - Branch = branch database state
   - Merge = merge database state (with care)
   - Enables team collaboration via Git

4. **Backup and Recovery**
   - Backup project = backup database
   - Restore project = restore database
   - No separate backup strategy needed
   - Simple disaster recovery

5. **Privacy**
   - Each project's data is isolated
   - No global database with all project data
   - Easier to share specific projects
   - Meets data residency requirements

**Alternatives Considered**:
- ❌ Global database: Cross-project issues, harder backup, privacy concerns
- ❌ Remote database: Requires network, adds complexity, breaks portability

---

## Quality Enforcement Architecture

### State Machine (Quality Gates)

**Decision**: Workflow state machine enforced at database level

**Implementation**:
```sql
-- Example: Prevent skipping validation
CREATE TRIGGER prevent_skip_validation
BEFORE UPDATE ON work_items
WHEN NEW.status = 'accepted' AND OLD.status = 'proposed'
BEGIN
    SELECT RAISE(ABORT, 'Cannot skip validation: proposed → accepted not allowed');
END;
```

**Rationale**:

1. **Prevent AI Agents from Skipping Critical Steps**
   - Cannot go proposed → accepted (must validate first)
   - Cannot go in_progress → completed (must review first)
   - Database enforces, not application code
   - Impossible to bypass in any programming language

2. **Type-Specific Requirements**
   - FEATURE work items require DESIGN + IMPLEMENTATION + TESTING + DOCUMENTATION tasks
   - Validated at proposed → validated transition
   - Different rules for different work item types
   - Ensures complete scope definition

3. **Time-Boxing Enforcement**
   - IMPLEMENTATION tasks ≤4 hours (STRICT)
   - Forces task decomposition
   - Prevents scope creep
   - Validated before accepted state

4. **Audit Trail**
   - Every state transition logged
   - Who, when, why recorded
   - Cannot alter history
   - Compliance and accountability

**Trade-offs Accepted**:
- ⚠️ Schema changes require migrations (acceptable for data integrity)
- ⚠️ Database-level enforcement harder to test (mitigated by integration tests)

---

### Plugin System (Framework Detection)

**Decision**: Plugin-based framework intelligence extraction

**Architecture**:
```
┌────────────────────────────────────┐
│     Plugin Detectors               │
│  • DjangoPlugin                    │
│  • ReactPlugin                     │
│  • pytestPlugin                    │
│  • ClickPlugin                     │
└──────────────┬─────────────────────┘
               │ Extracts facts
┌──────────────▼─────────────────────┐
│     Code Amalgamations             │
│  • Django models (50KB)            │
│  • React components (40KB)         │
│  • pytest fixtures (20KB)          │
│  • Click commands (15KB)           │
└──────────────┬─────────────────────┘
               │ Used by
┌──────────────▼─────────────────────┐
│     Context Assembly               │
│  • Project facts                   │
│  • Work item scope                 │
│  • Task details                    │
│  • Searchable code examples        │
└────────────────────────────────────┘
```

**Rationale**:

1. **Project-Specific Intelligence**
   - Not generic advice ("use REST API")
   - Actual code patterns from codebase ("use UserSerializer from api/serializers.py")
   - Framework-specific best practices
   - Context grounded in real project code

2. **Code Amalgamations**
   - 222KB+ searchable code for complex projects
   - Groups related code (all Django models, all React hooks)
   - Fast search (<100ms) vs reading files
   - Fits within AI token limits

3. **Facts, Not Recommendations**
   - "Django 4.2 detected" (fact)
   - "PostgreSQL configured" (fact)
   - "pytest fixtures in conftest.py" (fact)
   - Not "you should use Django" (recommendation)

4. **Extensible**
   - Add new plugins without core changes
   - Community can contribute framework support
   - Plugin interface is stable
   - Follows hexagonal architecture

**Trade-offs Accepted**:
- ⚠️ Plugin maintenance overhead (acceptable for intelligence value)
- ⚠️ Initial detection time (mitigated by caching)

---

## Performance Considerations

### Lazy-Loading (CLI Startup Time)

**Decision**: Lazy-load commands to minimize startup time

**Implementation**:
```python
# Click LazyGroup pattern
@click.group(cls=LazyGroup)
def cli():
    """APM CLI"""
    pass

# Commands loaded only when invoked
cli.add_command(lazy_command("work-item", "agentpm.cli.commands.work_item"))
```

**Rationale**:
- <100ms startup critical for AI agent responsiveness
- 40+ commands would slow startup if all imported
- Lazy-loading = only import needed command
- Scales to hundreds of commands without degradation

---

### Context Assembly Pipeline

**Decision**: 7-step optimized context assembly pipeline

**Pipeline**:
```
1. Load 6W (5ms)           → Unified context structure
2. Load work item (3ms)    → Scope and acceptance criteria
3. Load task (2ms)         → Specific objective
4. Load plugin facts (8ms) → Framework intelligence
5. Load amalgamations(10ms)→ Code examples
6. Merge contexts (5ms)    → Hierarchical assembly
7. Calculate confidence(2ms)→ Quality score
────────────────────────────
Total: ~35ms               → Fast enough for real-time
```

**Rationale**:
- Sub-50ms assembly time maintains responsiveness
- Parallel loading where possible (plugin facts + amalgamations)
- Cached results for repeated queries
- Fast enough for AI agent iteration

---

## Security Considerations

### Input Validation (Three Layers)

**Decision**: Validate at CLI, Pydantic, and Database levels

**Layers**:
```
1. Click parameters  → Type validation, ranges, choices
2. Pydantic models   → Schema validation, constraints
3. SQLite CHECK      → Database constraints, triggers
```

**Rationale**:
- Defense in depth prevents injection attacks
- AI agents can't bypass validation
- Each layer catches different error classes
- Fail fast with clear error messages

---

### Sensitive Data Redaction

**Decision**: Redact secrets before storage

**Implementation**:
```python
# Redact API keys, passwords, tokens
patterns = [
    r'sk_live_[A-Za-z0-9]{48}',  # Stripe API keys
    r'ghp_[A-Za-z0-9]{36}',       # GitHub tokens
    r'password\s*=\s*["\'][^"\']+["\']'
]
```

**Rationale**:
- Prevents accidental secret storage in database
- Database can be safely committed to Git
- Meets compliance requirements (GDPR, SOC 2)
- Protects against AI agent hallucinations exposing secrets

---

## Development Experience

### Testing Strategy

**Strategy**:
```
Unit Tests (80%)        → Fast, isolated, mock adapters
Integration Tests (15%) → Database + adapters + methods
E2E Tests (5%)         → CLI commands, full stack
```

**Coverage Requirements**:
- >90% overall (CI-004 gate)
- 100% for critical paths (quality gates, state machine)
- Fixtures reduce boilerplate
- Fast test suite (<30s for 200+ tests)

---

### Development Workflow

**Workflow**:
```
1. Write failing test (TDD)
2. Implement in three layers (Model → Adapter → Method)
3. Run tests (pytest)
4. Check coverage (pytest-cov)
5. Type check (mypy)
6. Lint (ruff)
7. Format (black)
8. Commit (conventional commits)
```

**Rationale**:
- TDD prevents regressions
- Three-layer pattern enforced by code review
- Automated checks prevent quality issues
- Consistent code style across codebase

---

## Migration and Evolution

### Schema Migration Strategy

**Strategy**: File-based migrations with upgrade/downgrade

**Example**:
```python
# agentpm/core/database/migrations/files/migration_0025.py
def upgrade(db: Connection) -> None:
    """Add idea_elements table for 6W decomposition"""
    db.execute("""
        CREATE TABLE idea_elements (
            id INTEGER PRIMARY KEY,
            idea_id INTEGER REFERENCES ideas(id),
            element_type TEXT CHECK(element_type IN ('who', 'what', ...)),
            ...
        )
    """)

def downgrade(db: Connection) -> None:
    """Remove idea_elements table"""
    db.execute("DROP TABLE idea_elements")
```

**Rationale**:
- Forward and backward migration support
- Testable migrations (can verify up + down)
- Sequential numbering (migration_0025, migration_0026)
- Recorded in database (applied_migrations table)

---

## Future-Proofing

### PostgreSQL Migration Path

**Decision**: Architecture supports PostgreSQL with minimal changes

**Changes Required**:
```
Adapters: SQLite-specific SQL → PostgreSQL SQL
Core: No changes (uses adapter interface)
Tests: Add PostgreSQL fixtures
Config: Add connection string parameter
```

**Rationale**:
- Three-layer architecture isolates database
- Can add PostgreSQL adapter alongside SQLite
- Supports enterprise scale (multi-team, multi-project)
- Migration path validated in design

---

### Multi-Provider Support

**Decision**: Provider abstraction ready for additional AI tools

**Current Providers**:
- Claude Code (primary)
- Cursor (supported)
- Aider (supported)

**Future Providers** (via adapter pattern):
- GitHub Copilot
- Gemini
- GPT-4 (ChatGPT)
- Local models (Ollama)

**Rationale**:
- Hexagonal architecture supports any provider
- Core logic provider-agnostic
- Add provider by implementing adapter interface
- No breaking changes to core

---

## Summary

### Key Technology Decisions

| Technology | Primary Reason | Key Benefit |
|------------|---------------|-------------|
| Python 3.9+ | AI agent compatibility | Universal support across tools |
| SQLite | Zero-config persistence | Perfect for per-project use |
| Click | Industry-standard CLI | Lazy-loading, <100ms startup |
| Pydantic | AI-safe validation | Three-layer type safety |
| Rich | Professional terminal UI | Better agent feedback |
| pytest | Quality enforcement | >90% coverage requirement |
| NetworkX | Proven algorithms | Dependency graph operations |

### Key Architectural Decisions

| Pattern | Primary Reason | Key Benefit |
|---------|---------------|-------------|
| Three-Layer | AI agent safety | Type-safe, testable, maintainable |
| Hexagonal | Provider abstraction | Multi-provider support |
| DDD | Complex domain | Clear boundaries, ubiquitous language |
| Database-First | Persistent memory | Cross-session context |
| Per-Project DB | Isolation | Portable, Git-friendly |
| State Machine | Quality enforcement | Agents can't skip gates |
| Plugin System | Framework intelligence | Project-specific context |

---

## Conclusion

APM's technical stack is optimized for three goals:

1. **AI Agent Reliability**: Type-safe validation, quality enforcement, clear error messages
2. **Developer Experience**: Standard tools, clear patterns, excellent documentation
3. **Future-Proofing**: Extensible architecture, migration paths, provider abstraction

Every technology choice prioritizes **AI agent safety** while maintaining **professional developer standards**. The result is a system that AI agents can use reliably while developers can extend confidently.

---

**Version**: 1.0
**Last Updated**: 2025-10-25
**Maintained By**: APM Core Team
