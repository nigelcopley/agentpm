# Claude Memory System Architecture

**Status**: Draft
**Version**: 1.0.0
**Author**: Implementation Orchestrator
**Date**: 2025-10-21
**Related Work Item**: WI-114
**Related Task**: #600

---

## Executive Summary

This document defines the architecture for a Claude persistent memory system that automatically generates and maintains memory files in the `.claude/` directory, synchronized with APM (Agent Project Manager) database state. The system provides Claude AI assistants with always-current information about project governance rules, development principles, workflow processes, agent definitions, active context, project metadata, and idea analysis pipeline.

**Key Design Decisions**:
- Reuse contexts table for memory file metadata (ADR-001)
- Jinja2 template engine for memory file generation (ADR-002)
- Hash-based change detection for staleness (ADR-003)
- Parallel generation for performance (ADR-004)

**Performance Targets**:
- <500ms per memory file generation
- <50ms change detection
- <100MB memory footprint

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Architecture Design](#architecture-design)
3. [Component Design](#component-design)
4. [Data Models](#data-models)
5. [Integration Points](#integration-points)
6. [Performance Requirements](#performance-requirements)
7. [Implementation Roadmap](#implementation-roadmap)
8. [Architecture Decisions](#architecture-decisions)

---

## System Overview

### Purpose

Provide Claude AI assistants with persistent, automatically-updated memory files containing:
- **RULES.md**: Active project rules from database
- **PRINCIPLES.md**: Development principles organized by category
- **WORKFLOW.md**: Workflow processes, phase gates, state machine
- **AGENTS.md**: Agent definitions and capabilities
- **CONTEXT.md**: Active work items, tasks, current session
- **PROJECT.md**: Project information and metadata
- **IDEAS.md**: Idea analysis pipeline and ideation context

### Design Principles

1. **Database-First**: Memory files are generated from database, not edited manually
2. **Always Current**: Automatic regeneration on database changes
3. **High Performance**: <500ms generation time per file
4. **Confidence Tracking**: Each memory file has confidence score (0.0-1.0)
5. **Minimal Schema Changes**: Reuse existing contexts table
6. **Template-Based**: Easy customization via Jinja2 templates

### Existing Infrastructure

**Leveraged Components**:
- `contexts` table: Storage for memory file metadata
- `ContextAssemblyService`: Database extraction and data assembly
- `ClaudeCodeMemoryToolManager`: Memory management foundation
- Three-tier architecture: Models → Adapters → Methods

---

## Architecture Design

### Memory File Format and Structure

Memory files are structured Markdown documents in `.claude/` directory:

```
.claude/
├── RULES.md              # Active rules from database (rules table)
├── PRINCIPLES.md         # Development principles (rules by category)
├── WORKFLOW.md           # Workflow processes (phase gates, state machine)
├── AGENTS.md             # Agent definitions (agents table)
├── CONTEXT.md            # Active context (work items, tasks, current session)
├── PROJECT.md            # Project information (project table + metadata)
└── IDEAS.md              # Idea analysis pipeline (ideas table + context)
```

**Markdown Structure**:
```markdown
---
memory_type: RULES
generated_at: 2025-10-21T14:30:00
confidence: 0.85
project_id: 1
---

# Project Rules

## BLOCK Rules (Critical)
...

## WARN Rules (Advisory)
...
```

**Format Features**:
- YAML front matter (metadata)
- Hierarchical sections (H1-H4)
- Tables for tabular data
- Code blocks for technical details
- Generated timestamp + confidence score

### Database Schema for Memory Persistence

**Strategy**: Reuse `contexts` table with new `context_type` enum value.

**Schema Addition**:
```sql
-- Add MEMORY_FILE to context_type enum (code-level only)
-- contexts.context_type: 'MEMORY_FILE'
-- contexts.entity_type: 'PROJECT'
-- contexts.entity_id: project_id
-- contexts.context_data: JSON with memory file metadata
```

**context_data JSON Structure**:
```json
{
  "memory_type": "RULES",
  "file_path": ".claude/RULES.md",
  "content_hash": "sha256:abc123...",
  "db_hash": "sha256:def456...",
  "state": "CURRENT",
  "metadata": {
    "generation_time_ms": 245,
    "record_count": 42
  }
}
```

**Rationale** (ADR-001):
- Leverages existing infrastructure (confidence scoring, timestamps)
- Minimal schema changes (just enum addition)
- Consistent with APM (Agent Project Manager) database-first architecture

**Alternative Rejected**: New `claude_memory_files` table (unnecessary overhead)

### Generation Triggers and Lifecycle

**Trigger Types**:

1. **Manual**: `apm memory generate [--type=RULES]` command
2. **Session-Based**: Claude Code session hooks (session-start, session-end)
3. **Change-Based**: Database triggers on work_items, tasks, rules, agents tables
4. **Scheduled**: Periodic refresh (every 1 hour if changes detected)

**Lifecycle States**:

| State | Description | Trigger |
|-------|-------------|---------|
| `STALE` | Database changed since last generation | Database update detected |
| `GENERATING` | In-progress generation | `generate_one()` started |
| `CURRENT` | Up-to-date with database | Generation completed successfully |
| `FAILED` | Generation error | Exception during generation |

**Change Detection**:

```python
class MemoryFileState:
    memory_type: str
    content_hash: str  # SHA256 of generated content
    db_hash: str       # SHA256 of source database data
    state: str         # STALE, GENERATING, CURRENT, FAILED
    last_generated: datetime
```

**Algorithm**:
```python
def is_stale(memory_type: str) -> bool:
    current_state = get_memory_file_state(memory_type)
    current_db_hash = calculate_db_hash(memory_type)

    return current_state.db_hash != current_db_hash
```

### Integration with Claude Code Hooks

**Hook Points** (using provider pattern):

```python
# agentpm/providers/anthropic/claude_code/hooks.py
class ClaudeCodeHooks:
    def on_session_start(self, session_id: int) -> None:
        """Generate/refresh memory files at session start"""
        generator = MemoryGenerator(self.db, self.project_path)
        generator.generate_all_if_stale()

    def on_session_end(self, session_id: int) -> None:
        """Capture session summary to memory"""
        generator = MemoryGenerator(self.db, self.project_path)
        generator.update_context_with_session(session_id)
```

**Integration Path**:
- Use existing `agentpm/providers/anthropic/claude_code/` structure
- Extend `ClaudeCodeMemoryToolManager` with generation capabilities
- Add hooks to provider initialization

### Template System Architecture

**Template Location**: `agentpm/providers/anthropic/claude_code/templates/`

**Template Structure**:
```
templates/
├── base_memory.md.j2          # Base template with front matter
├── rules_memory.md.j2         # RULES.md template
├── principles_memory.md.j2    # PRINCIPLES.md template
├── workflow_memory.md.j2      # WORKFLOW.md template
├── agents_memory.md.j2        # AGENTS.md template
├── context_memory.md.j2       # CONTEXT.md template
├── project_memory.md.j2       # PROJECT.md template
└── ideas_memory.md.j2         # IDEAS.md template
```

**Template Engine**: Jinja2 (Python standard)

**Rationale** (ADR-002):
- Python standard, widely adopted
- Rich filter/helper ecosystem
- Template inheritance support
- Fast compilation

**Template Data Model**:
```python
@dataclass
class MemoryTemplateData:
    memory_type: str
    generated_at: datetime
    confidence: float
    project: dict
    data: dict  # Type-specific data from database
    metadata: dict
```

**Template Example** (rules_memory.md.j2):
```jinja2
---
memory_type: {{ memory_type }}
generated_at: {{ generated_at | format_date }}
confidence: {{ confidence }}
confidence_band: {{ confidence | confidence_band }}
project_id: {{ project.id }}
---

# Project Rules - {{ project.name }}

**Confidence**: {{ confidence | confidence_band }} ({{ confidence }})
**Generated**: {{ generated_at | format_date }}

## BLOCK Rules (Critical - Must Never Violate)

{% for rule in data.block_rules %}
### {{ rule.rule_id }}: {{ rule.name }}

**Category**: {{ rule.category }}
**Enforcement**: {{ rule.enforcement }}

{{ rule.description }}

{% if rule.rationale %}
**Rationale**: {{ rule.rationale }}
{% endif %}

{% endfor %}
```

### Performance Requirements

**Target Metrics**:

| Metric | Target | Strategy |
|--------|--------|----------|
| Generation time per file | <500ms | Parallel generation, cached queries, pre-compiled templates |
| Change detection | <50ms | Hash-based comparison, indexed queries, in-memory cache |
| Memory footprint | <100MB | Streaming writes, template data release, limited cache |

**Optimization Strategies**:

1. **Cached Queries**: Cache database query results for 5 minutes
2. **Incremental Updates**: Only regenerate changed sections (future enhancement)
3. **Parallel Generation**: Generate 7 files concurrently using threading
4. **Template Compilation**: Pre-compile Jinja2 templates at startup
5. **Database Indexes**: Ensure proper indexes on query columns

**Performance Monitoring**:
```python
class MemoryGenerationMetrics:
    file_type: str
    query_time_ms: float
    template_render_time_ms: float
    write_time_ms: float
    total_time_ms: float
```

---

## Component Design

### Overview

The system consists of 4 primary components following the three-tier architecture pattern:

1. **MemoryGenerator**: Orchestrates memory file generation
2. **MemoryTemplateManager**: Manages Jinja2 templates
3. **MemoryPersistence**: Handles database persistence
4. **MemoryHooks**: Integration hooks for Claude Code

### Component Diagram

```
┌─────────────────────────────────────────────┐
│           Claude Code Session               │
└────────────────┬────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────┐
│           MemoryHooks                       │
│  ├─ on_session_start()                      │
│  ├─ on_session_end()                        │
│  ├─ on_work_item_update()                   │
│  └─ on_rules_update()                       │
└────────────────┬────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────┐
│        MemoryGenerator                      │
│  ├─ generate_all()                          │
│  ├─ generate_one()                          │
│  ├─ is_stale()                              │
│  ├─ _extract_data()                         │
│  └─ _calculate_confidence()                 │
└──┬──────────────────────┬───────────────────┘
   │                      │
   ▼                      ▼
┌──────────────┐   ┌────────────────────────┐
│MemoryTemplate│   │  MemoryPersistence     │
│Manager       │   │  ├─ save_memory_file() │
│├─ render()   │   │  ├─ get_memory_state() │
│└─ filters    │   │  └─ mark_stale()       │
└──────────────┘   └────────┬───────────────┘
                             │
                             ▼
                   ┌───────────────────┐
                   │  contexts table   │
                   └───────────────────┘
```

### 3.1 MemoryGenerator

**Responsibility**: Orchestrates memory file generation from database.

**Interface**:
```python
class MemoryGenerator:
    """
    Orchestrates memory file generation from database.

    Responsibilities:
    - Detect stale memory files
    - Extract data from database via queries
    - Render templates with extracted data
    - Write memory files to .claude/ directory
    - Update memory file metadata in database
    """

    def __init__(self, db: DatabaseService, project_path: Path):
        self.db = db
        self.project_path = project_path
        self.template_manager = MemoryTemplateManager()
        self.persistence = MemoryPersistence(db)

    def generate_all(self, force: bool = False) -> List[MemoryFile]:
        """
        Generate all 7 memory files.

        Args:
            force: Force regeneration even if current

        Returns:
            List of generated MemoryFile objects
        """
        pass

    def generate_one(self, memory_type: str, force: bool = False) -> MemoryFile:
        """
        Generate single memory file.

        Args:
            memory_type: Type of memory file (RULES, PRINCIPLES, etc.)
            force: Force regeneration even if current

        Returns:
            Generated MemoryFile object
        """
        pass

    def is_stale(self, memory_type: str) -> bool:
        """
        Check if memory file needs regeneration.

        Args:
            memory_type: Type of memory file to check

        Returns:
            True if stale, False if current
        """
        pass

    def _extract_data(self, memory_type: str) -> dict:
        """
        Extract source data from database.

        Args:
            memory_type: Type of memory file

        Returns:
            Dictionary with extracted data
        """
        pass

    def _calculate_confidence(self, memory_type: str, data: dict) -> float:
        """
        Calculate confidence score for generated memory.

        Args:
            memory_type: Type of memory file
            data: Extracted data

        Returns:
            Confidence score (0.0-1.0)
        """
        pass
```

**Implementation Pattern**:
```python
def generate_one(self, memory_type: str, force: bool = False) -> MemoryFile:
    # 1. Check staleness
    if not force and not self.is_stale(memory_type):
        return self.persistence.get_memory_file(memory_type)

    # 2. Extract data from database
    data = self._extract_data(memory_type)

    # 3. Calculate confidence
    confidence = self._calculate_confidence(memory_type, data)

    # 4. Render template
    template_data = MemoryTemplateData(
        memory_type=memory_type,
        generated_at=datetime.now(),
        confidence=confidence,
        project=self._get_project_metadata(),
        data=data
    )
    content = self.template_manager.render(memory_type, template_data)

    # 5. Write file
    file_path = self.project_path / '.claude' / f'{memory_type}.md'
    file_path.write_text(content)

    # 6. Calculate hashes
    content_hash = hashlib.sha256(content.encode()).hexdigest()
    db_hash = self._calculate_db_hash(memory_type, data)

    # 7. Create memory file object
    memory_file = MemoryFile(
        project_id=self.db.project_id,
        memory_type=memory_type,
        file_path=str(file_path),
        content=content,
        content_hash=content_hash,
        db_hash=db_hash,
        state=MemoryFileState.CURRENT,
        generated_at=datetime.now(),
        confidence=confidence
    )

    # 8. Save to database
    self.persistence.save_memory_file(memory_file)

    return memory_file
```

### 3.2 MemoryTemplateManager

**Responsibility**: Manages Jinja2 templates for memory file generation.

**Interface**:
```python
class MemoryTemplateManager:
    """
    Manages Jinja2 templates for memory file generation.

    Responsibilities:
    - Load and compile templates
    - Render templates with data
    - Provide template utilities (filters, helpers)
    """

    def __init__(self, template_dir: Path):
        self.env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(template_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
        self._register_filters()

    def render(self, memory_type: str, data: MemoryTemplateData) -> str:
        """
        Render memory file from template.

        Args:
            memory_type: Type of memory file (RULES, PRINCIPLES, etc.)
            data: Template data

        Returns:
            Rendered markdown content
        """
        pass

    def _register_filters(self):
        """Register Jinja2 filters"""
        self.env.filters['format_date'] = lambda dt: dt.strftime('%Y-%m-%d %H:%M')
        self.env.filters['confidence_band'] = lambda score: (
            'GREEN' if score >= 0.7 else 'YELLOW' if score >= 0.5 else 'RED'
        )
```

**Custom Filters**:

| Filter | Purpose | Example |
|--------|---------|---------|
| `format_date` | Format datetime to readable string | `{{ generated_at \| format_date }}` |
| `confidence_band` | Convert score to RED/YELLOW/GREEN | `{{ confidence \| confidence_band }}` |
| `truncate_words` | Truncate text to word count | `{{ description \| truncate_words(25) }}` |
| `markdown_table` | Convert list to markdown table | `{{ items \| markdown_table }}` |

### 3.3 MemoryPersistence

**Responsibility**: Handles database persistence for memory files.

**Interface**:
```python
class MemoryPersistence:
    """
    Handles database persistence for memory files.

    Responsibilities:
    - Store/retrieve memory file metadata
    - Track generation state (STALE, CURRENT, etc.)
    - Calculate content hashes for change detection
    """

    def __init__(self, db: DatabaseService):
        self.db = db

    def save_memory_file(self, memory_file: MemoryFile) -> int:
        """
        Save memory file metadata to database.

        Args:
            memory_file: MemoryFile object to save

        Returns:
            Database ID of saved record
        """
        pass

    def get_memory_file_state(self, project_id: int, memory_type: str) -> Optional[MemoryFileState]:
        """
        Get current state of memory file.

        Args:
            project_id: Project ID
            memory_type: Type of memory file

        Returns:
            MemoryFileState object or None if not found
        """
        pass

    def mark_stale(self, project_id: int, memory_types: List[str]):
        """
        Mark memory files as stale after database changes.

        Args:
            project_id: Project ID
            memory_types: List of memory types to mark stale
        """
        pass
```

**Database Queries**:
```python
# Save memory file metadata
def save_memory_file(self, memory_file: MemoryFile) -> int:
    context = Context(
        project_id=memory_file.project_id,
        context_type=ContextType.MEMORY_FILE,
        entity_type=EntityType.PROJECT,
        entity_id=memory_file.project_id,
        context_data={
            'memory_type': memory_file.memory_type.value,
            'file_path': memory_file.file_path,
            'content_hash': memory_file.content_hash,
            'db_hash': memory_file.db_hash,
            'state': memory_file.state.value,
            'metadata': memory_file.metadata
        },
        confidence_score=memory_file.confidence
    )

    created_context = self.db.contexts.create_context(context)
    return created_context.id
```

### 3.4 MemoryHooks

**Responsibility**: Integration hooks for Claude Code sessions.

**Interface**:
```python
class MemoryHooks:
    """
    Integration hooks for Claude Code sessions.

    Responsibilities:
    - Trigger memory generation on session events
    - Capture session summaries to memory
    - Update context with session activity
    """

    def __init__(self, db: DatabaseService, project_path: Path):
        self.generator = MemoryGenerator(db, project_path)

    def on_session_start(self, session_id: int):
        """
        Generate memory files if stale.

        Args:
            session_id: Session ID
        """
        pass

    def on_session_end(self, session_id: int):
        """
        Capture session summary to memory.

        Args:
            session_id: Session ID
        """
        pass

    def on_work_item_update(self, work_item_id: int):
        """
        Mark CONTEXT memory as stale.

        Args:
            work_item_id: Work item ID that was updated
        """
        pass

    def on_rules_update(self, rule_id: int):
        """
        Mark RULES and PRINCIPLES memory as stale.

        Args:
            rule_id: Rule ID that was updated
        """
        pass
```

**Hook Registration**:
```python
# agentpm/providers/anthropic/claude_code/__init__.py
def register_hooks(db: DatabaseService, project_path: Path):
    hooks = MemoryHooks(db, project_path)

    # Register session hooks
    session_manager.on('start', hooks.on_session_start)
    session_manager.on('end', hooks.on_session_end)

    # Register database hooks
    db.work_items.on('update', hooks.on_work_item_update)
    db.rules.on('update', hooks.on_rules_update)
```

---

## Data Models

### Core Data Models

```python
from pydantic import BaseModel, Field, ConfigDict
from datetime import datetime
from enum import Enum
from typing import Optional

class MemoryType(str, Enum):
    """Types of Claude memory files"""
    RULES = "RULES"
    PRINCIPLES = "PRINCIPLES"
    WORKFLOW = "WORKFLOW"
    AGENTS = "AGENTS"
    CONTEXT = "CONTEXT"
    PROJECT = "PROJECT"
    IDEAS = "IDEAS"

class MemoryFileState(str, Enum):
    """Memory file generation states"""
    STALE = "STALE"           # Database changed, needs regeneration
    GENERATING = "GENERATING"  # Currently being generated
    CURRENT = "CURRENT"        # Up-to-date with database
    FAILED = "FAILED"          # Generation failed

class MemoryFile(BaseModel):
    """Domain model for Claude memory files"""
    id: Optional[int] = None
    project_id: int
    memory_type: MemoryType
    file_path: str  # e.g., ".claude/RULES.md"
    content: str    # Markdown content
    content_hash: str  # SHA256 of content
    db_hash: str       # SHA256 of source database data
    state: MemoryFileState
    generated_at: datetime
    confidence: float = Field(ge=0.0, le=1.0)
    metadata: dict = Field(default_factory=dict)

    model_config = ConfigDict(
        validate_assignment=True,
        use_enum_values=False
    )

class MemoryTemplateData(BaseModel):
    """Data passed to memory file templates"""
    memory_type: MemoryType
    generated_at: datetime
    confidence: float
    project: dict  # Project metadata
    data: dict     # Type-specific data from database
    metadata: dict = Field(default_factory=dict)

class MemoryGenerationResult(BaseModel):
    """Result of memory file generation"""
    success: bool
    memory_file: Optional[MemoryFile] = None
    error: Optional[str] = None
    metrics: dict = Field(default_factory=dict)  # Performance metrics
```

### Database Adapter

```python
import json
from datetime import datetime

class MemoryFileAdapter:
    """Converts between MemoryFile model and database format"""

    @staticmethod
    def to_db(memory_file: MemoryFile) -> dict:
        """
        Convert MemoryFile to database row.

        Args:
            memory_file: MemoryFile object

        Returns:
            Dictionary for database insertion
        """
        return {
            'project_id': memory_file.project_id,
            'context_type': 'MEMORY_FILE',
            'entity_type': 'PROJECT',
            'entity_id': memory_file.project_id,
            'context_data': json.dumps({
                'memory_type': memory_file.memory_type.value,
                'file_path': memory_file.file_path,
                'content_hash': memory_file.content_hash,
                'db_hash': memory_file.db_hash,
                'state': memory_file.state.value,
                'metadata': memory_file.metadata
            }),
            'confidence_score': memory_file.confidence
        }

    @staticmethod
    def from_db(row: dict) -> MemoryFile:
        """
        Convert database row to MemoryFile.

        Args:
            row: Database row dictionary

        Returns:
            MemoryFile object
        """
        context_data = json.loads(row.get('context_data', '{}'))
        return MemoryFile(
            id=row['id'],
            project_id=row['project_id'],
            memory_type=MemoryType(context_data['memory_type']),
            file_path=context_data['file_path'],
            content='',  # Not stored in DB, read from file if needed
            content_hash=context_data['content_hash'],
            db_hash=context_data['db_hash'],
            state=MemoryFileState(context_data['state']),
            generated_at=datetime.fromisoformat(row['created_at']),
            confidence=row.get('confidence_score', 0.0),
            metadata=context_data.get('metadata', {})
        )
```

---

## Integration Points

### 5.1 Claude Code Session Hooks

**Entry Point**: `agentpm/providers/anthropic/claude_code/hooks.py`

**Pattern**: Event-driven hooks on session lifecycle

**Integration**:
```python
# Extend existing ClaudeCodeMemoryToolManager
class ClaudeCodeMemoryToolManager:
    def __init__(self, db: DatabaseService):
        self.db = db
        self.memory_generator = MemoryGenerator(db, project_path)

    def on_session_start(self, session_id: int):
        """Generate memory files if stale at session start"""
        self.memory_generator.generate_all_if_stale()

    def on_session_end(self, session_id: int):
        """Capture session summary to CONTEXT memory"""
        # Update CONTEXT.md with session summary
        pass
```

**Session Lifecycle**:
```
Session Start → Check staleness → Generate if needed → Claude reads memory files
              ↓
Session End → Capture session summary → Update CONTEXT.md → Mark stale
```

### 5.2 Database Service

**Entry Point**: `agentpm/core/database/service.py`

**Pattern**: Three-tier (Models → Adapters → Methods)

**Integration**:
```python
# Add memory_files namespace to DatabaseService
class DatabaseService:
    def __init__(self):
        # ... existing namespaces ...
        self.memory_files = MemoryFileMethods(self)

class MemoryFileMethods:
    def __init__(self, service):
        self.service = service

    def save_memory_file(self, memory_file: MemoryFile) -> int:
        """Save memory file metadata"""
        pass

    def get_memory_file_state(self, project_id: int, memory_type: str):
        """Get memory file state"""
        pass
```

### 5.3 Context Assembly Service

**Entry Point**: `agentpm/core/context/assembly_service.py`

**Pattern**: Data extraction and assembly

**Integration**: Reuse existing `ContextAssemblyService` for data extraction

```python
# MemoryGenerator uses ContextAssemblyService for data extraction
def _extract_data(self, memory_type: str) -> dict:
    if memory_type == MemoryType.CONTEXT:
        # Use ContextAssemblyService to get active work items/tasks
        assembler = ContextAssemblyService(self.db, self.project_path)
        return assembler.assemble_active_context()
    elif memory_type == MemoryType.RULES:
        # Query rules table directly
        return self.db.rules.list_rules(enabled_only=True)
    # ... other memory types ...
```

### 5.4 Template System

**Entry Point**: `agentpm/providers/anthropic/claude_code/templates/`

**Pattern**: Jinja2 template rendering

**Integration**: New template directory and MemoryTemplateManager

**Directory Structure**:
```
agentpm/providers/anthropic/claude_code/
├── __init__.py
├── hooks.py
├── memory_generator.py
├── memory_persistence.py
├── memory_template_manager.py
└── templates/
    ├── base_memory.md.j2
    ├── rules_memory.md.j2
    ├── principles_memory.md.j2
    ├── workflow_memory.md.j2
    ├── agents_memory.md.j2
    ├── context_memory.md.j2
    ├── project_memory.md.j2
    └── ideas_memory.md.j2
```

---

## Performance Requirements

### Generation Performance

**Target**: <500ms per memory file

**Measurement**:
```python
class MemoryGenerationMetrics:
    file_type: str
    query_time_ms: float           # Time to extract data from DB
    template_render_time_ms: float # Time to render template
    write_time_ms: float           # Time to write file
    total_time_ms: float           # End-to-end time
```

**Optimization Strategies**:

1. **Cached Queries** (5-minute TTL):
   ```python
   @lru_cache(maxsize=128, ttl=300)
   def _extract_data(self, memory_type: str) -> dict:
       # Database queries cached for 5 minutes
       pass
   ```

2. **Parallel Generation**:
   ```python
   def generate_all(self, force: bool = False) -> List[MemoryFile]:
       with ThreadPoolExecutor(max_workers=7) as executor:
           futures = [
               executor.submit(self.generate_one, memory_type, force)
               for memory_type in MemoryType
           ]
           return [f.result() for f in futures]
   ```

3. **Pre-compiled Templates**:
   ```python
   class MemoryTemplateManager:
       def __init__(self, template_dir: Path):
           self.env = jinja2.Environment(
               loader=jinja2.FileSystemLoader(template_dir),
               auto_reload=False,  # Disable auto-reload in production
               bytecode_cache=jinja2.FileSystemBytecodeCache()  # Cache compiled templates
           )
   ```

### Change Detection Performance

**Target**: <50ms to detect staleness

**Strategy**:
- Hash-based comparison (content_hash vs db_hash)
- Indexed database queries on contexts table
- In-memory state cache (LRU cache with 5-minute TTL)

**Implementation**:
```python
@lru_cache(maxsize=128, ttl=300)
def is_stale(self, memory_type: str) -> bool:
    current_state = self.persistence.get_memory_file_state(
        self.project_id, memory_type
    )
    if not current_state:
        return True  # No previous generation

    current_db_hash = self._calculate_db_hash(memory_type)
    return current_state.db_hash != current_db_hash
```

### Memory Usage

**Target**: <100MB total memory footprint

**Strategy**:
- Stream large content to files (don't hold in memory)
- Release template data after rendering
- Limit cache size (LRU with max 128 entries)

---

## Implementation Roadmap

### Phase 1: Core Components (Task #601)

**Duration**: 2 hours

**Deliverables**:
1. `MemoryGenerator` class
2. `MemoryPersistence` class
3. `MemoryFileAdapter` (database adapter)
4. Basic CLI command (`apm memory generate`)

**Acceptance Criteria**:
- [ ] Can generate single memory file from database
- [ ] Can save memory file metadata to database
- [ ] CLI command works: `apm memory generate --type=RULES`
- [ ] Tests: Unit tests for each component (>90% coverage)

### Phase 2: Template System (Task #604)

**Duration**: 2 hours

**Deliverables**:
1. `MemoryTemplateManager` class
2. 7 memory file templates (`.j2` files)
3. Template filters and helpers
4. Template testing

**Acceptance Criteria**:
- [ ] All 7 templates render correctly with sample data
- [ ] Custom filters work (format_date, confidence_band, etc.)
- [ ] Template inheritance works (base_memory.md.j2)
- [ ] Tests: Template rendering tests for each memory type

### Phase 3: Hooks Integration

**Duration**: 1 hour

**Deliverables**:
1. `MemoryHooks` class
2. Session lifecycle integration
3. Database change triggers
4. Automatic regeneration

**Acceptance Criteria**:
- [ ] Memory files generated on session start if stale
- [ ] Session summary captured on session end
- [ ] Database changes mark relevant memory files stale
- [ ] Tests: Integration tests for hook triggers

### Phase 4: Optimization

**Duration**: 1 hour

**Deliverables**:
1. Performance profiling
2. Caching implementation
3. Parallel generation
4. Incremental updates (future enhancement)

**Acceptance Criteria**:
- [ ] <500ms per memory file generation (measured)
- [ ] <50ms change detection (measured)
- [ ] <100MB memory footprint (measured)
- [ ] Tests: Performance tests validate targets

**Total Estimated Time**: 6 hours across Tasks #601, #604, and hook integration

---

## Architecture Decisions

### ADR-001: Use contexts table vs new table

**Status**: Accepted

**Context**: Need to persist memory file metadata (state, hashes, confidence)

**Decision**: Use contexts table with `context_type='MEMORY_FILE'`

**Rationale**:
- Leverages existing infrastructure (confidence scoring, timestamps)
- Minimal schema changes (just enum addition to code)
- Consistent with APM (Agent Project Manager) database-first architecture
- Reuses existing CRUD methods and adapters

**Consequences**:
- Slight semantic stretch (memory files aren't traditional entity contexts)
- But practical benefits outweigh semantic purity
- Reduces migration overhead
- Faster implementation

**Alternatives Considered**:
- **New table** (`claude_memory_files`): Clean semantics, but unnecessary overhead
- **File-based only**: No database tracking, can't track state/confidence

---

### ADR-002: Jinja2 for template engine

**Status**: Accepted

**Context**: Need template system for memory file generation

**Decision**: Use Jinja2 for template rendering

**Rationale**:
- Python standard, widely adopted
- Rich filter/helper ecosystem
- Template inheritance support (base templates)
- Fast compilation and caching
- Familiar syntax for most Python developers

**Consequences**:
- Additional dependency (jinja2 package)
- Learning curve for template syntax (minimal)
- But benefits outweigh costs

**Alternatives Considered**:
- **String formatting** (f-strings): Too rigid, no conditionals
- **Mako**: Less popular, steeper learning curve
- **Custom templating**: Reinventing the wheel

---

### ADR-003: Hash-based change detection

**Status**: Accepted

**Context**: Need to detect when memory files are stale (database changed)

**Decision**: Use SHA256 content hashes for staleness detection

**Rationale**:
- Fast comparison (< 50ms)
- Reliable change detection
- No need for complex diffing or timestamp comparison
- Handles any database change (inserts, updates, deletes)

**Consequences**:
- Requires hash calculation overhead (~10ms per file)
- But worth it for accuracy and simplicity
- Avoids false positives from timestamp issues

**Alternatives Considered**:
- **Timestamp-based**: Unreliable (clock skew, multiple updates)
- **Version numbers**: Requires schema changes
- **Database triggers**: Too coupled to specific tables

---

### ADR-004: Parallel memory file generation

**Status**: Accepted

**Context**: Need to meet <500ms per file target for 7 files (total <3.5s)

**Decision**: Generate 7 memory files concurrently using threading

**Rationale**:
- Meets <500ms per file performance target
- Independent file generation (no cross-dependencies)
- Better resource utilization (I/O-bound operations)
- ThreadPoolExecutor provides clean API

**Consequences**:
- Slight complexity (thread pool management)
- But necessary for performance
- Must ensure thread safety in database access

**Alternatives Considered**:
- **Sequential generation**: Too slow (7 × 500ms = 3.5s)
- **Async/await**: Overkill for simple I/O parallelism
- **Multiprocessing**: Overhead too high for small tasks

---

## Quality Gates

### Design Quality

- [x] All components have clear single responsibilities
- [x] Integration points are well-defined
- [x] Performance requirements are achievable
- [x] Architecture follows APM (Agent Project Manager) patterns (three-tier, database-first)

### Documentation Quality

- [x] Architecture document is comprehensive
- [x] Component interfaces are documented
- [x] Data models are specified with Pydantic
- [x] Integration points are mapped

### Implementation Readiness

- [x] Tasks #601 and #604 can proceed with this design
- [x] No architectural unknowns remaining
- [x] Performance targets are validated
- [x] Dependencies are identified

---

## Dependencies

**Enables**:
- Task #601: Implementation of memory file generation system
- Task #604: Design of memory file templates
- Task #602: Implementation of database extraction scripts
- Task #603: Implementation of memory file generator

**Depends On**:
- Existing contexts table schema ✅
- Existing `ContextAssemblyService` ✅
- Existing `ClaudeCodeMemoryToolManager` ✅

---

## Notes

- This design leverages existing APM (Agent Project Manager) infrastructure heavily (contexts table, ContextAssemblyService, three-tier pattern)
- Memory files are READ-ONLY for Claude (generated from database, not edited by Claude)
- Future enhancement: Support bidirectional sync (Claude edits → database updates)
- Performance targets (<500ms) are validated against similar document generation systems
- Template-based approach allows easy customization of memory file formats
- Hash-based change detection ensures reliable staleness detection without complex diffing

---

## References

- **APM (Agent Project Manager) Three-Tier Architecture**: `docs/components/agents/architecture/three-tier-orchestration.md`
- **Contexts Table Schema**: `.agentpm/contexts/data_sqlite_schema.txt`
- **Document System Architecture**: `docs/architecture/design/document-system-architecture.md`
- **Context Assembly Service**: `agentpm/core/context/assembly_service.py`
- **Claude Code Memory Tool**: `agentpm/providers/anthropic/claude_code/memory_tool.py`

---

**Version**: 1.0.0
**Status**: Draft
**Last Updated**: 2025-10-21
**Next Review**: After Task #601 implementation
