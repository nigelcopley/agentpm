# APM (Agent Project Manager) Developer Onboarding Guide

**Version:** 1.0
**Last Updated:** 2025-10-21
**Audience:** New developers joining APM (Agent Project Manager) development
**Estimated Reading Time:** 45 minutes

---

## Welcome to APM (Agent Project Manager)

This guide will help you understand APM (Agent Project Manager)'s architecture, set up your development environment, and start contributing effectively.

**What is APM (Agent Project Manager)?**
APM (Agent Project Manager) is a **database-driven AI project management system** that orchestrates AI-assisted software development workflows through a sophisticated multi-agent architecture.

**Core Philosophy:**
- **Database-First:** All runtime state in database, not files
- **Three-Layer Pattern:** Clean separation (Models → Adapters → Methods)
- **Agent Orchestration:** Master delegates to specialists
- **Quality Gates:** Enforce standards at every phase

---

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Development Environment Setup](#development-environment-setup)
3. [Architecture Walkthrough](#architecture-walkthrough)
4. [Development Workflow](#development-workflow)
5. [Three-Layer Pattern Deep Dive](#three-layer-pattern-deep-dive)
6. [Testing Strategy](#testing-strategy)
7. [Common Pitfalls](#common-pitfalls)
8. [Quick Start Examples](#quick-start-examples)

---

## Prerequisites

### Required Knowledge

**Must Have:**
- Python 3.11+ (type hints, Pydantic)
- SQLite basics (SQL queries, migrations)
- Git version control
- Command-line tools

**Nice to Have:**
- Click framework (CLI development)
- Flask (web development)
- Jinja2 templating
- pytest testing framework

### Required Tools

**Core Development:**
```bash
# Python 3.11 or higher
python --version  # Should be 3.11+

# pip package manager
pip --version

# Git
git --version

# SQLite (usually included with Python)
sqlite3 --version
```

**Optional but Recommended:**
```bash
# Virtual environment management
python -m venv --help

# Code quality tools
black --version      # Code formatter
ruff --version       # Linter
mypy --version       # Type checker
```

---

## Development Environment Setup

### Step 1: Clone the Repository

```bash
# Clone the repository
git clone https://github.com/your-org/aipm-v2.git
cd aipm-v2

# Check current branch
git branch
# Should show: * main
```

### Step 2: Create Virtual Environment

```bash
# Create virtual environment
python3.11 -m venv venv

# Activate virtual environment
# On macOS/Linux:
source venv/bin/activate

# On Windows:
venv\Scripts\activate

# Verify activation
which python  # Should show venv/bin/python
```

### Step 3: Install Dependencies

```bash
# Install core dependencies
pip install -e .

# Install development dependencies
pip install -e ".[dev]"

# Verify installation
apm --version
# Should show: APM (Agent Project Manager) version X.X.X
```

### Step 4: Initialize Database

```bash
# Initialize AIPM in a test project
cd /path/to/test/project
apm init

# Verify database creation
ls -la .agentpm/data/
# Should see: agentpm.db

# Check database tables
sqlite3 .agentpm/data/agentpm.db ".tables"
# Should list 40+ tables
```

### Step 5: Verify Installation

```bash
# Run system status check
apm status

# List available commands
apm --help

# Run a simple command
apm work-item list
```

---

## Architecture Walkthrough

### The Big Picture

APM (Agent Project Manager) uses a **three-tier architecture** with clear separation:

```
┌─────────────────────────────────────────────┐
│         User Interfaces (CLI/Web)           │
│  - Click commands (101 commands)            │
│  - Flask routes (77 endpoints)              │
└─────────────┬───────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────┐
│         Core Business Logic                 │
│  - Workflow Service (state machine)         │
│  - Agent System (orchestration)             │
│  - Context Assembly (11-step pipeline)      │
│  - Security Layer (validation)              │
└─────────────┬───────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────┐
│         Data Access Layer                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐    │
│  │ Models  │→ │Adapters │→ │ Methods │    │
│  │Pydantic │  │ DB↔Model│  │Business │    │
│  └─────────┘  └─────────┘  └─────────┘    │
└─────────────┬───────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────┐
│         SQLite Database                     │
│  40+ tables with proper indexing            │
└─────────────────────────────────────────────┘
```

### Key Architectural Principles

#### 1. Database-First Design

**CRITICAL:** Database is the source of truth, NOT files.

```python
# ✅ CORRECT - Load from database
rules = db.rule_methods.list_rules(enabled_only=True)

# ❌ WRONG - Load from YAML files
with open('_RULES/security.yaml') as f:
    rules = yaml.load(f)
```

**Why This Matters:**
- Runtime state must be in database
- Files are documentation/initialization only
- `_RULES/` directory used only during `apm init`

#### 2. Three-Layer Pattern

**Every feature follows this pattern:**

```
Layer 1: Models (agentpm/core/database/models/)
  ↓ Pydantic classes with validation
Layer 2: Adapters (agentpm/core/database/adapters/)
  ↓ Database row ↔ Pydantic model conversion
Layer 3: Methods (agentpm/core/database/methods/)
  ↓ Business logic, workflow enforcement
```

**Example Flow:**
```python
# 1. Model (define structure)
class WorkItem(BaseModel):
    name: str
    type: WorkItemType
    status: WorkItemStatus

# 2. Adapter (convert DB ↔ Model)
def row_to_model(row: sqlite3.Row) -> WorkItem:
    return WorkItem(
        name=row['name'],
        type=WorkItemType(row['type']),
        ...
    )

# 3. Method (business logic)
def create_work_item(db: DatabaseService, wi: WorkItem) -> WorkItem:
    # Validate, enforce rules, insert to DB
    ...
```

#### 3. Agent Orchestration

**Three-Tier Agent Hierarchy:**

```
Master Orchestrator (CLAUDE.md)
  - Routes work by artifact type
  - NEVER executes directly
  - Delegates to phase orchestrators
    ↓
Phase Orchestrators (6)
  - D1: definition-orch
  - P1: planning-orch
  - I1: implementation-orch
  - R1: review-test-orch
  - O1: release-ops-orch
  - E1: evolution-orch
    ↓
Sub-Agents (36)
  - Single-purpose specialists
  - Execute specific tasks
  - Report results to orchestrator
```

**Key Rule:** Master orchestrator NEVER implements directly - always delegates.

### Directory Structure

```
aipm-v2/
├── agentpm/                    # Main package
│   ├── cli/                    # Click CLI commands
│   │   ├── commands/           # Command groups (work_item, task, etc.)
│   │   └── utils/              # CLI utilities
│   ├── core/                   # Core business logic
│   │   ├── agents/             # Agent system
│   │   ├── context/            # Context assembly
│   │   ├── database/           # Database layer
│   │   │   ├── models/         # Pydantic models
│   │   │   ├── adapters/       # DB↔Model conversion
│   │   │   └── methods/        # Business logic
│   │   ├── plugins/            # Plugin system
│   │   ├── security/           # Security layer
│   │   └── workflow/           # Workflow service
│   ├── providers/              # LLM provider integrations
│   ├── templates/              # JSON/Agent templates
│   └── web/                    # Flask web interface
├── .claude/                    # Claude Code integration
│   └── agents/                 # Agent SOP files
├── docs/                       # Documentation
├── tests/                      # Test suite
└── _RULES/                     # Rule documentation (NOT runtime)
```

---

## Development Workflow

### Typical Development Cycle

```bash
# 1. Create feature branch
git checkout -b feature/my-feature

# 2. Make changes (follow three-layer pattern)
# Edit: models/ → adapters/ → methods/ → CLI commands

# 3. Run tests
pytest tests/

# 4. Run type checking
mypy agentpm/

# 5. Format code
black agentpm/

# 6. Commit changes
git add .
git commit -m "feat: add new feature"

# 7. Push and create PR
git push origin feature/my-feature
```

### Best Practices

#### Code Organization

**DO:**
- ✅ Follow three-layer pattern strictly
- ✅ Add type hints to all functions
- ✅ Write docstrings for public APIs
- ✅ Use Pydantic for validation
- ✅ Test at each layer

**DON'T:**
- ❌ Skip layers (CLI → Database directly)
- ❌ Put business logic in CLI commands
- ❌ Bypass validation
- ❌ Use raw SQL queries
- ❌ Modify database schema without migrations

#### Commit Messages

**Format:** `<type>: <description>`

**Types:**
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation only
- `test:` - Add/update tests
- `refactor:` - Code refactoring
- `chore:` - Maintenance tasks

**Examples:**
```bash
git commit -m "feat: add task dependency validation"
git commit -m "fix: correct phase gate validation logic"
git commit -m "docs: update CLI command examples"
```

---

## Three-Layer Pattern Deep Dive

### Layer 1: Models (Pydantic)

**Location:** `agentpm/core/database/models/`

**Purpose:** Type-safe data structures with validation

**Example - Work Item Model:**
```python
# agentpm/core/database/models/work_item.py
from pydantic import BaseModel, Field, field_validator
from typing import Optional
from datetime import datetime

class WorkItem(BaseModel):
    """Work item model with validation"""
    id: Optional[int] = None
    project_id: int
    name: str = Field(min_length=1, max_length=200)
    type: WorkItemType
    status: WorkItemStatus
    phase: Optional[Phase] = None
    business_context: str = Field(default="", min_length=0)
    acceptance_criteria: List[str] = Field(default_factory=list)
    created_at: datetime
    updated_at: datetime

    @field_validator('acceptance_criteria')
    @classmethod
    def validate_ac_count(cls, v):
        """Ensure minimum 3 AC for non-draft work items"""
        if len(v) < 3:
            raise ValueError("Work items require at least 3 acceptance criteria")
        return v
```

**Key Features:**
- Type hints for all fields
- Field validation (min/max length, custom validators)
- Default values
- Immutability (Pydantic models are immutable by default)

### Layer 2: Adapters (Database Conversion)

**Location:** `agentpm/core/database/adapters/`

**Purpose:** Convert between SQLite rows and Pydantic models

**Example - Work Item Adapter:**
```python
# agentpm/core/database/adapters/work_item_adapter.py
import sqlite3
from typing import Optional
from ..models.work_item import WorkItem
import json

class WorkItemAdapter:
    """Adapter for WorkItem model"""

    @staticmethod
    def row_to_model(row: sqlite3.Row) -> WorkItem:
        """Convert database row to WorkItem model"""
        return WorkItem(
            id=row['id'],
            project_id=row['project_id'],
            name=row['name'],
            type=WorkItemType(row['type']),
            status=WorkItemStatus(row['status']),
            phase=Phase(row['phase']) if row['phase'] else None,
            business_context=row['business_context'] or "",
            acceptance_criteria=json.loads(row['acceptance_criteria'] or '[]'),
            created_at=datetime.fromisoformat(row['created_at']),
            updated_at=datetime.fromisoformat(row['updated_at']),
        )

    @staticmethod
    def model_to_row(wi: WorkItem) -> tuple:
        """Convert WorkItem model to database row values"""
        return (
            wi.project_id,
            wi.name,
            wi.type.value,
            wi.status.value,
            wi.phase.value if wi.phase else None,
            wi.business_context,
            json.dumps(wi.acceptance_criteria),
            wi.created_at.isoformat(),
            wi.updated_at.isoformat(),
        )
```

**Key Features:**
- Bidirectional conversion (row ↔ model)
- JSON serialization for complex fields
- Type safety maintained
- Enum conversion

### Layer 3: Methods (Business Logic)

**Location:** `agentpm/core/database/methods/`

**Purpose:** Business logic, validation, workflow enforcement

**Example - Work Item Methods:**
```python
# agentpm/core/database/methods/work_items.py
from typing import List, Optional
from ..service import DatabaseService
from ..models.work_item import WorkItem
from ..adapters.work_item_adapter import WorkItemAdapter

def create_work_item(db: DatabaseService, wi: WorkItem) -> WorkItem:
    """Create new work item with validation"""
    # Validate business rules
    if wi.type == WorkItemType.FEATURE and len(wi.acceptance_criteria) < 3:
        raise ValueError("FEATURE work items require at least 3 AC")

    # Insert to database
    query = """
        INSERT INTO work_items
        (project_id, name, type, status, phase, business_context,
         acceptance_criteria, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    """

    with db.get_connection() as conn:
        cursor = conn.execute(query, WorkItemAdapter.model_to_row(wi))
        wi.id = cursor.lastrowid

    return wi

def list_work_items(
    db: DatabaseService,
    project_id: int,
    status: Optional[WorkItemStatus] = None
) -> List[WorkItem]:
    """List work items with optional filtering"""
    query = """
        SELECT * FROM work_items
        WHERE project_id = ?
    """
    params = [project_id]

    if status:
        query += " AND status = ?"
        params.append(status.value)

    query += " ORDER BY created_at DESC"

    with db.get_connection() as conn:
        cursor = conn.execute(query, params)
        return [WorkItemAdapter.row_to_model(row) for row in cursor.fetchall()]
```

**Key Features:**
- Business rule validation
- Parameterized queries (SQL injection prevention)
- Database connection management
- Error handling

### Connecting the Layers (Example Flow)

**User Command → Three Layers → Database:**

```python
# CLI Command (agentpm/cli/commands/work_item/create.py)
@click.command()
@click.argument('name')
@click.option('--type', required=True)
def create(name, type):
    """Create new work item"""
    # Layer 1: Create model
    wi = WorkItem(
        project_id=1,
        name=name,
        type=WorkItemType(type),
        status=WorkItemStatus.DRAFT,
        acceptance_criteria=[],
    )

    # Get database service
    db = get_database_service()

    # Layer 3: Call method (which uses Layer 2 internally)
    result = work_item_methods.create_work_item(db, wi)

    # Display result
    console.print(f"Created work item #{result.id}")
```

---

## Testing Strategy

### Test Organization

APM (Agent Project Manager) uses a layered testing approach:

```
tests/
├── unit/                    # Unit tests (isolated)
│   ├── cli/                 # CLI command tests
│   ├── database/            # Database layer tests
│   └── plugins/             # Plugin tests
├── integration/             # Integration tests
│   ├── cli/                 # CLI workflow tests
│   ├── database/            # Database integration
│   └── document/            # Document system tests
├── e2e/                     # End-to-end tests
│   ├── memory/              # Memory system E2E
│   └── document/            # Document system E2E
└── services/                # Service layer tests
```

### Writing Tests

**AAA Pattern (Arrange-Act-Assert):**

```python
def test_create_work_item_success(db_service, project):
    """Test successful work item creation"""
    # Arrange
    wi = WorkItem(
        project_id=project.id,
        name="Test Work Item",
        type=WorkItemType.FEATURE,
        status=WorkItemStatus.DRAFT,
        acceptance_criteria=["AC1", "AC2", "AC3"],
    )

    # Act
    result = work_item_methods.create_work_item(db_service, wi)

    # Assert
    assert result.id is not None
    assert result.name == "Test Work Item"
    assert result.type == WorkItemType.FEATURE
    assert len(result.acceptance_criteria) == 3
```

### Test Fixtures

**Common Fixtures (`conftest.py`):**

```python
import pytest
from agentpm.core.database.service import DatabaseService


@pytest.fixture
def db_service(tmp_path):
    """Create isolated database for testing"""
    db_path = tmp_path / "test.db"
    service = DatabaseService(str(db_path))
    yield service
    service.close_all()


@pytest.fixture
def project(db_service):
    """Create test project"""
    from agentpm.core.database.methods import projects
    project = projects.create_project(
        db_service,
        name="Test Project",
        description="Test project description"
    )
    return project


@pytest.fixture
def work_item(db_service, project):
    """Create test work item"""
    from agentpm.core.database.methods import work_items
    wi = work_items.create_work_item(
        db_service,
        WorkItem(
            project_id=project.id,
            name="Test WI",
            type=WorkItemType.FEATURE,
            ...
        )
    )
    return wi
```

### Running Tests

```bash
# Run all tests
pytest

# Run specific test file
pytest tests/unit/database/methods/test_work_items.py

# Run with coverage
pytest --cov=agentpm --cov-report=html

# Run specific test
pytest tests/unit/database/methods/test_work_items.py::test_create_work_item
```

---

## Common Pitfalls

### 1. Skipping the Three-Layer Pattern

**❌ WRONG:**
```python
# CLI command directly accessing database
@click.command()
def create(name):
    conn = sqlite3.connect('.agentpm/data/agentpm.db')
    conn.execute("INSERT INTO work_items ...")  # SQL injection risk!
```

**✅ CORRECT:**
```python
@click.command()
def create(name):
    wi = WorkItem(name=name, ...)
    db = get_database_service()
    result = work_item_methods.create_work_item(db, wi)
```

### 2. Loading Rules from Files at Runtime

**❌ WRONG:**
```python
# Loading rules from YAML at runtime
with open('_RULES/security.yaml') as f:
    rules = yaml.load(f)
```

**✅ CORRECT:**
```python
# Load rules from database
rules = db.rule_methods.list_rules(enabled_only=True)
```

### 3. Using shell=True in subprocess

**❌ WRONG:**
```python
# Command injection vulnerability
subprocess.run(f"git commit -m '{message}'", shell=True)
```

**✅ CORRECT:**
```python
# List format, no shell injection
subprocess.run(['git', 'commit', '-m', message])
```

### 4. Not Using Parameterized Queries

**❌ WRONG:**
```python
# SQL injection vulnerability
query = f"SELECT * FROM work_items WHERE name = '{name}'"
conn.execute(query)
```

**✅ CORRECT:**
```python
# Parameterized query
query = "SELECT * FROM work_items WHERE name = ?"
conn.execute(query, (name,))
```

### 5. Bypassing Validation

**❌ WRONG:**
```python
# Skipping Pydantic validation
data = {'name': '', 'type': 'invalid'}
conn.execute("INSERT INTO work_items ...")
```

**✅ CORRECT:**
```python
# Pydantic validates before database
wi = WorkItem(name='', type='invalid')  # Raises ValidationError
```

### 6. Not Handling Database Connections

**❌ WRONG:**
```python
# Connection leak
conn = db.get_connection()
conn.execute(...)
# Never closed!
```

**✅ CORRECT:**
```python
# Context manager ensures cleanup
with db.get_connection() as conn:
    conn.execute(...)
```

### 7. Implementing in Master Orchestrator

**❌ WRONG:**
```python
# Master orchestrator directly implementing
def orchestrate(request):
    # Write code, run tests directly
    code = generate_code(request)
    run_tests(code)
```

**✅ CORRECT:**
```python
# Master orchestrator delegates only
def orchestrate(request):
    # Delegate to implementation orchestrator
    Task(
        subagent_type="implementation-orch",
        description="Implement feature",
        prompt=f"Complete I1 for: {request}"
    )
```

---

## Quick Start Examples

### Example 1: Add a New CLI Command

**Goal:** Add `apm work-item assign` command

```python
# Step 1: Define model field (if needed)
# agentpm/core/database/models/work_item.py
class WorkItem(BaseModel):
    ...
    assigned_to: Optional[str] = None  # Add field

# Step 2: Update adapter
# agentpm/core/database/adapters/work_item_adapter.py
def row_to_model(row):
    return WorkItem(
        ...
        assigned_to=row['assigned_to'],
    )

# Step 3: Add method
# agentpm/core/database/methods/work_items.py
def assign_work_item(db, wi_id, agent_role):
    """Assign work item to agent"""
    query = "UPDATE work_items SET assigned_to = ? WHERE id = ?"
    with db.get_connection() as conn:
        conn.execute(query, (agent_role, wi_id))
    return get_work_item(db, wi_id)

# Step 4: Add CLI command
# agentpm/cli/commands/work_item/assign.py
@click.command()
@click.argument('work_item_id', type=int)
@click.option('--agent', required=True)
def assign(work_item_id, agent):
    """Assign work item to agent"""
    db = get_database_service()
    result = work_item_methods.assign_work_item(db, work_item_id, agent)
    console.print(f"Assigned #{result.id} to {agent}")

# Step 5: Register command
# agentpm/cli/commands/work_item/__init__.py
from .assign import assign
work_item.add_command(assign)

# Step 6: Test
# tests/unit/cli/commands/test_work_item_assign.py
def test_assign_work_item(db_service, work_item):
    result = work_item_methods.assign_work_item(
        db_service, work_item.id, "test-agent"
    )
    assert result.assigned_to == "test-agent"
```

### Example 2: Add a New Database Table

```python
# Step 1: Create migration
# agentpm/core/database/migrations/0041_add_comments.py
def upgrade(conn):
    conn.execute("""
        CREATE TABLE comments (
            id INTEGER PRIMARY KEY,
            work_item_id INTEGER,
            author TEXT,
            content TEXT,
            created_at TEXT,
            FOREIGN KEY (work_item_id) REFERENCES work_items(id)
        )
    """)

def downgrade(conn):
    conn.execute("DROP TABLE comments")

# Step 2: Create model
# agentpm/core/database/models/comment.py
class Comment(BaseModel):
    id: Optional[int] = None
    work_item_id: int
    author: str
    content: str
    created_at: datetime

# Step 3: Create adapter
# agentpm/core/database/adapters/comment_adapter.py
class CommentAdapter:
    @staticmethod
    def row_to_model(row):
        return Comment(...)

# Step 4: Create methods
# agentpm/core/database/methods/comments.py
def create_comment(db, comment):
    ...

def list_comments(db, work_item_id):
    ...

# Step 5: Run migration
apm migrate
```

### Example 3: Add Security Validation

```python
# Add to agentpm/core/security/input_validator.py
def validate_email(email: str) -> str:
    """Validate email format"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(pattern, email):
        raise SecurityError("Invalid email format")
    return email

# Use in model
class User(BaseModel):
    email: str

    @field_validator('email')
    @classmethod
    def validate_email_format(cls, v):
        return InputValidator.validate_email(v)
```

---

## Next Steps

### Week 1: Familiarization
- [ ] Set up development environment
- [ ] Read SYSTEM_OVERVIEW.md
- [ ] Run all CLI commands (`apm --help`)
- [ ] Explore database schema (`sqlite3 .agentpm/data/agentpm.db`)
- [ ] Read agent SOPs in `.claude/agents/`

### Week 2: Small Contributions
- [ ] Fix documentation typos
- [ ] Add test cases for existing features
- [ ] Improve error messages
- [ ] Add type hints to untypedcode

### Week 3: Feature Development
- [ ] Pick a small feature from backlog
- [ ] Follow three-layer pattern
- [ ] Write comprehensive tests
- [ ] Submit PR for review

### Week 4: Advanced Topics
- [ ] Study agent orchestration patterns
- [ ] Learn workflow state machine
- [ ] Understand context assembly
- [ ] Contribute to core systems

---

## Additional Resources

### Documentation
- **System Overview:** `docs/architecture/SYSTEM_OVERVIEW.md`
- **API Reference:** `docs/api/README.md`
- **Operations Runbook:** `docs/operations/RUNBOOK.md`
- **Readiness Reports:** `docs/architecture/readiness/`

### Code Examples
- **CLI Commands:** `agentpm/cli/commands/`
- **Database Methods:** `agentpm/core/database/methods/`
- **Test Examples:** `tests/`

### Communication
- **Questions:** Ask in team Slack/Discord
- **Bug Reports:** GitHub Issues
- **Feature Requests:** GitHub Discussions
- **Security Issues:** security@aipm.dev (private)

---

## Summary

**Key Takeaways:**
1. **Database-First:** All state in database, not files
2. **Three-Layer Pattern:** Models → Adapters → Methods
3. **Agent Delegation:** Master orchestrates, never implements
4. **Security-First:** Validate inputs, sanitize outputs
5. **Test Everything:** AAA pattern, isolated tests

**Golden Rules:**
- ✅ Always use parameterized queries
- ✅ Always validate with Pydantic
- ✅ Always follow three-layer pattern
- ✅ Always write tests
- ✅ Always delegate (master orchestrator)

**Common Commands:**
```bash
apm init                    # Initialize project
apm status                  # Check system status
apm work-item list          # List work items
apm agents generate --all   # Generate agents
pytest                      # Run tests
```

Welcome to the APM (Agent Project Manager) development team! 🚀

---

**Document Version:** 1.0
**Last Updated:** 2025-10-21
**Next Review:** Quarterly
**Maintained By:** APM (Agent Project Manager) Developer Relations
