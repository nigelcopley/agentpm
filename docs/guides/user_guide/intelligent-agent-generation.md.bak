# Intelligent Agent Generation

**Command**: `apm agents generate-intelligent`

**Purpose**: Automatically analyze your project and create specialized AI agents tailored to your exact tech stack, frameworks, and patterns.

---

## Overview

The intelligent agent generation system uses AI analysis to create **project-specific agents** rather than generic ones. Instead of copying standard templates, it analyzes your project and generates agents optimized for your technology stack.

### Differences from `apm agents generate`

| Feature | `apm agents generate` | `apm agents generate-intelligent` |
|---------|----------------------|----------------------------------|
| **Source** | Reads agents from database | Analyzes project + AI generation |
| **Output** | Provider-specific files | Database + SOP files |
| **Customization** | Static templates | Dynamic, project-specific |
| **Intelligence** | Template-based | AI-driven analysis |
| **Specialization** | Generic agents | Tech-stack specialized agents |
| **Use Case** | Quick file generation | Initial setup, major changes |

---

## How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Project Analysis                 â”‚
â”‚    â€¢ Languages (Python, TypeScript) â”‚
â”‚    â€¢ Frameworks (Django, React)     â”‚
â”‚    â€¢ Database (PostgreSQL, SQLite)  â”‚
â”‚    â€¢ Testing (pytest, Jest)         â”‚
â”‚    â€¢ Project rules (time-boxing)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. AI Analysis                      â”‚
â”‚    â€¢ Decide which agents needed     â”‚
â”‚    â€¢ Create specialized variants    â”‚
â”‚    â€¢ Embed project patterns         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Agent Generation                 â”‚
â”‚    â€¢ backend-implementer (Django)   â”‚
â”‚    â€¢ frontend-implementer (React)   â”‚
â”‚    â€¢ api-implementer (DRF)          â”‚
â”‚    â€¢ pytest-tester                  â”‚
â”‚    â€¢ jest-tester                    â”‚
â”‚    â€¢ database-designer (PostgreSQL) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Storage                          â”‚
â”‚    â€¢ Database records               â”‚
â”‚    â€¢ .claude/agents/*.md files      â”‚
â”‚    â€¢ Embedded project rules         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Usage

### Basic Generation (Fast Mock Mode)

```bash
# Analyze project and generate agents (mock mode - fast)
apm agents generate-intelligent

# Example output:
# ðŸ“Š Project Analysis
# â”œâ”€ Business Domain: AI Project Management
# â”œâ”€ Application Type: CLI Tool
# â”œâ”€ Languages: Python 3.11
# â”œâ”€ Frameworks: Click, Pydantic, pytest
# â”œâ”€ Database: SQLite
# â”œâ”€ Testing: pytest
# â””â”€ Active Rules: 8
#
# âœ… Generated 7 specialized agents
# â”œâ”€ python-cli-developer (implementer)
# â”œâ”€ click-command-builder (implementer)
# â”œâ”€ pydantic-validator (validator)
# â”œâ”€ pytest-tester (tester)
# â”œâ”€ sqlite-database-developer (implementer)
# â”œâ”€ cli-documenter (documenter)
# â””â”€ code-reviewer (reviewer)
```

### Using Real Claude API (Slower, More Intelligent)

```bash
# Use real Claude API for more intelligent analysis
# Requires ANTHROPIC_API_KEY environment variable
apm agents generate-intelligent --use-claude

# Note: Takes 1-2 minutes for Claude to analyze and generate
```

### Dry Run (Preview Without Creating)

```bash
# See what would be generated without creating files
apm agents generate-intelligent --dry-run

# Shows:
# - Project analysis
# - Which agents would be created
# - Agent specializations
# - Tech focus areas
# But doesn't write files or database records
```

### Force Regeneration

```bash
# Regenerate even if agents already exist
apm agents generate-intelligent --force

# Warning: This will DELETE existing agents and replace them
# Use when:
# - Tech stack changed significantly
# - Want to update to latest generation logic
# - Previous generation had errors
```

### Custom Paths

```bash
# Use custom template directory
apm agents generate-intelligent \
  --template-dir=/path/to/templates

# Use custom output directory
apm agents generate-intelligent \
  --output-dir=.cursor/agents

# Combine options
apm agents generate-intelligent \
  --use-claude \
  --output-dir=.custom/agents \
  --force
```

---

## Example Scenarios

### Scenario 1: Django + React Full-Stack

**Project Context:**
```yaml
languages:
  - Python 3.11
  - TypeScript
frameworks:
  - Django 4.2
  - React 18
  - Django REST Framework
database: PostgreSQL
testing:
  - pytest
  - Jest
```

**Generated Agents:**
- `backend-implementer` - Django models, views, URLs, admin
- `frontend-implementer` - React components, hooks, state
- `api-implementer` - DRF serializers, viewsets, permissions
- `database-designer` - PostgreSQL schema, migrations, indexes
- `pytest-tester` - Django test client, fixtures, factories
- `jest-tester` - React Testing Library, component tests
- `integration-tester` - E2E tests, API testing
- `deployment-specialist` - Docker, CI/CD, production setup

### Scenario 2: Python CLI Tool

**Project Context:**
```yaml
languages:
  - Python 3.11
frameworks:
  - Click
  - Rich
  - Pydantic
database: SQLite
testing:
  - pytest
```

**Generated Agents:**
- `cli-implementer` - Click commands, argument parsing
- `terminal-ux-designer` - Rich formatting, tables, progress
- `data-validator` - Pydantic models, validation rules
- `sqlite-developer` - Database schema, queries
- `cli-tester` - CLI testing, command validation
- `documentation-writer` - Help text, user guides
- `package-maintainer` - setup.py, distribution

### Scenario 3: FastAPI Microservice

**Project Context:**
```yaml
languages:
  - Python 3.11
frameworks:
  - FastAPI
  - SQLAlchemy
  - Alembic
database: PostgreSQL
testing:
  - pytest
  - httpx
```

**Generated Agents:**
- `fastapi-implementer` - Routes, dependencies, middleware
- `sqlalchemy-developer` - ORM models, relationships
- `alembic-migrator` - Database migrations, schema changes
- `api-tester` - httpx test client, API testing
- `openapi-documenter` - API documentation, schemas
- `async-specialist` - async/await patterns, concurrency
- `monitoring-specialist` - Logging, metrics, health checks

---

## Project Analysis

The system analyzes multiple sources to build project context:

### 1. Database (Primary Source)
```sql
-- Reads from projects table
SELECT name, description, tech_stack FROM projects;

-- Reads from rules table
SELECT rule_id, name, enforcement_level FROM rules
WHERE project_id = ? AND enabled = 1;
```

### 2. Filesystem Analysis
```
- pyproject.toml â†’ Python package, dependencies
- package.json â†’ Node.js project, frameworks
- requirements.txt â†’ Python dependencies
- Dockerfile â†’ Containerization
- .github/workflows â†’ CI/CD setup
```

### 3. Configuration Files
```python
# Detects from pyproject.toml
[tool.poetry.dependencies]
django = "^4.2"
djangorestframework = "^3.14"
celery = "^5.3"

# Infers: Django web app with async tasks
```

---

## Agent Specialization

Each generated agent is specialized for your tech stack:

### Generic Template (Before)
```markdown
# Implementer Agent

Implement features following project patterns.

[INSTRUCTION: List detected frameworks]
[INSTRUCTION: Show code examples]
```

### Specialized Agent (After - Django)
```markdown
# Backend Implementer (Django Specialist)

Implement Django backend features following project patterns.

## Tech Stack
- Language: Python 3.11
- Framework: Django 4.2
- Database: PostgreSQL 15
- Testing: pytest with Django test client

## Specialization
- Django models (ORM, migrations, signals)
- Class-based views (ListView, DetailView, CreateView)
- Django REST Framework (ModelSerializer, ViewSet)
- Django admin customization
- Celery async tasks

## Project Rules (Embedded)
#### DP-001: time-boxing (BLOCK)
IMPLEMENTATION tasks limited to 4 hours

#### CI-004: testing-quality (BLOCK)
>90% test coverage required

## Code Patterns
**Three-layer architecture**:
- Models (domain) â†’ Adapters (DB) â†’ Methods (logic)

**Testing pattern**:
- AAA: Arrange, Act, Assert
- Fixtures in conftest.py
- Django test client for views

## Anti-Patterns
âŒ Don't bypass ORM for raw SQL
âŒ Don't skip migrations (run makemigrations)
âŒ Don't ignore N+1 queries (use select_related)
```

---

## Rule Embedding

Project rules are automatically embedded into agent SOPs:

### Database Rules
```sql
-- Rules table
rule_id: 'DP-001'
name: 'time-boxing'
enforcement_level: 'BLOCK'
description: 'IMPLEMENTATION tasks â‰¤4 hours'
```

### Embedded in Agent SOP
```markdown
## Quality Gates

#### DP-001: time-boxing (BLOCK)
IMPLEMENTATION tasks limited to 4 hours

**Why**: Forces task decomposition, prevents scope creep

**Enforcement**: Database trigger blocks task creation >4h
```

**Benefit**: Agents automatically know and follow project-specific rules without manual updates.

---

## Mock vs Real Claude

### Mock Mode (Default - Fast)

**How it works:**
1. Uses `AgentSelector` to intelligently choose agents
2. Fills templates with project context
3. Embeds rules and patterns
4. Generates in ~1-2 seconds

**When to use:**
- Initial setup
- Quick iterations
- Testing
- CI/CD pipelines

**Limitations:**
- Less creative specialization
- Template-bound structure
- May miss subtle patterns

### Real Claude Mode (--use-claude)

**How it works:**
1. Sends full project context to Claude API
2. Claude analyzes tech stack and patterns
3. Claude creates custom agent instructions
4. Generates in ~60-120 seconds

**When to use:**
- Production setup
- Complex multi-framework projects
- Want maximum customization
- Initial project setup

**Requirements:**
- `ANTHROPIC_API_KEY` environment variable
- Internet connection
- Anthropic API credits

**Example:**
```bash
# Set API key
export ANTHROPIC_API_KEY="sk-ant-..."

# Generate with Claude
apm agents generate-intelligent --use-claude
```

---

## Troubleshooting

### Error: "Template directory not found"

```bash
# Check templates exist
ls agentpm/core/agents/templates/

# Use custom templates
apm agents generate-intelligent \
  --template-dir=/custom/path
```

### Error: "No agents generated"

**Cause**: Project context insufficient

**Fix**: Ensure project has:
```bash
# Check database has project
apm status

# Check tech_stack populated
sqlite3 .agentpm/data/agentpm.db \
  "SELECT tech_stack FROM projects WHERE id=1;"
```

### Warning: "X agents already exist"

**Cause**: Agents already in database

**Options:**
```bash
# 1. Skip generation (safe)
# Press 'n' when prompted

# 2. Force regenerate (replaces)
apm agents generate-intelligent --force

# 3. Dry run to preview
apm agents generate-intelligent --dry-run
```

### Error: "Claude API rate limit"

**Cause**: Too many Claude API calls

**Fix:**
```bash
# Use mock mode instead
apm agents generate-intelligent  # No --use-claude flag

# Or wait and retry
sleep 60
apm agents generate-intelligent --use-claude
```

---

## Best Practices

### 1. Generate After Tech Stack Changes

```bash
# Added React framework
apm agents generate-intelligent --force

# Result: New frontend-implementer agent created
```

### 2. Dry Run Before Force Regenerate

```bash
# Preview changes
apm agents generate-intelligent --dry-run

# If looks good, regenerate
apm agents generate-intelligent --force
```

### 3. Use Mock Mode for Development

```bash
# Fast iteration during development
apm agents generate-intelligent

# Use Claude for production setup
apm agents generate-intelligent --use-claude
```

### 4. Review Generated Agents

```bash
# Generate agents
apm agents generate-intelligent

# Review what was created
apm agents list

# Check specific agent
apm agents show backend-implementer

# Read SOP file
cat .claude/agents/backend-implementer.md
```

### 5. Customize Templates

```bash
# Copy default templates
cp -r agentpm/core/agents/templates /my/templates

# Modify templates
vi /my/templates/implementer.md

# Generate with custom templates
apm agents generate-intelligent \
  --template-dir=/my/templates
```

---

## Integration with Workflow

### Initial Project Setup

```bash
# 1. Initialize project
apm init "My Django App" /path/to/project

# 2. Detect frameworks (plugin system)
# Automatically done during init

# 3. Generate intelligent agents
apm agents generate-intelligent

# 4. Verify
apm agents list
```

### Tech Stack Evolution

```bash
# Project starts as Django monolith
apm agents generate-intelligent
# â†’ Creates Django-specific agents

# Later, add React frontend
# Update tech_stack in database
# Then regenerate

apm agents generate-intelligent --force
# â†’ Creates React + Django agents
```

### CI/CD Integration

```yaml
# .github/workflows/agents.yml
name: Generate Agents

on:
  push:
    paths:
      - 'pyproject.toml'
      - 'package.json'
      - '.agentpm/**'

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install APM
        run: pip install -e .

      - name: Generate Agents
        run: |
          apm agents generate-intelligent --force

      - name: Commit Changes
        run: |
          git add .claude/agents/
          git commit -m "chore: regenerate agents"
          git push
```

---

## Advanced Usage

### Custom Generation Logic

```python
from agentpm.core.agents.generator import generate_and_store_agents
from agentpm.core.database import get_database
from pathlib import Path

# Custom project context
context = {
    'languages': ['Python', 'TypeScript'],
    'frameworks': ['Django', 'React', 'GraphQL'],
    'database': 'PostgreSQL',
    'testing_frameworks': ['pytest', 'Playwright'],
    'business_domain': 'Healthcare Platform',
    'app_type': 'HIPAA-Compliant Web Application',
    'patterns': [
        {'name': 'CQRS', 'description': 'Command Query Responsibility Segregation'},
        {'name': 'Event Sourcing', 'description': 'Event-driven state management'}
    ],
    'rules': [
        'HIPAA compliance required',
        'PHI data encryption at rest',
        'Audit logging for all data access'
    ]
}

# Generate
db = get_database()
agents = generate_and_store_agents(
    db=db,
    project_id=1,
    project_context=context,
    template_directory=Path('templates'),
    agent_output_dir=Path('.claude/agents'),
    use_real_claude=True
)

print(f"Generated {len(agents)} specialized agents")
for agent in agents:
    print(f"  - {agent.role}: {agent.display_name}")
```

### Filter Generated Agents

```python
# Only generate implementer-type agents
def filter_agents(agent_specs, agent_type='implementer'):
    return [
        spec for spec in agent_specs
        if spec.get('archetype') == agent_type
    ]

# Custom generation with filtering
agent_specs = generate_agents_with_claude(
    project_context=context,
    template_directory=template_dir,
    use_real_claude=False
)

filtered = filter_agents(agent_specs, 'implementer')
# Only store implementer agents
```

---

## See Also

- [Agent System Architecture](../../architecture/design_doc/technical-stack-rationale.md#agent-system)
- [Provider Generator System](./provider-generator-system.md)
- [Agent Templates](../../../agentpm/core/agents/templates/README.md)
- [CLI Commands Reference](../../../README.md#cli-commands)

---

**Version**: 1.0
**Last Updated**: 2025-10-25
**Command**: `apm agents generate-intelligent`
