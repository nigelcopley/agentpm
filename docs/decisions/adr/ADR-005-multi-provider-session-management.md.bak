# ADR-005: Multi-Provider Session Management

**Status:** Proposed
**Date:** 2025-10-12
**Deciders:** AIPM Core Team
**Technical Story:** Enable seamless session continuity across multiple AI coding assistant providers

---

## Context

### The Multi-Provider Challenge

Developers use different AI coding assistants for different tasks:
- **Claude Code**: Complex reasoning, architecture decisions
- **Cursor**: Real-time coding, autocomplete
- **Aider**: Command-line workflows, git integration
- **GitHub Copilot**: IDE integration, suggestions
- **Gemini**: Google ecosystem integration

**Current Problem:**

```
Monday AM: Use Claude Code
â”œâ”€ Work on authentication feature
â”œâ”€ Make decision: "Use JWT tokens"
â”œâ”€ Context stored in... where?
â””â”€ Session ends

Monday PM: Switch to Cursor
â”œâ”€ Continue authentication work
â”œâ”€ No access to JWT decision âŒ
â”œâ”€ Asks: "Should I use sessions or tokens?"
â””â”€ User must re-explain everything

Tuesday: Use Aider for git workflow
â”œâ”€ Need to commit auth changes
â”œâ”€ No context on what was decided âŒ
â”œâ”€ Commit message generic: "Update auth"
â””â”€ Lost architectural context
```

**Result:**
- Context doesn't survive provider switches
- Decisions made in one provider lost to others
- Work fragmented across providers
- No unified project view

### Requirements

1. **Provider-Agnostic Sessions**: Sessions not tied to specific provider
2. **Seamless Handoff**: Switch providers mid-work without context loss
3. **Unified History**: Single timeline across all providers
4. **Provider-Specific Optimization**: Leverage each provider's strengths
5. **Automatic Context Loading**: No manual context transfer

---

## Decision

We will implement a **Universal Session Management System** with:

1. **Provider-Agnostic Session Store**: Database tracks all sessions regardless of provider
2. **Automatic Context Assembly**: Context loaded based on work item/task, not provider
3. **Provider Handoff Protocol**: Explicit handoff commands for provider switches
4. **Unified Audit Trail**: Single timeline showing all provider activity
5. **Provider-Specific Hooks**: Each provider integrates via standard hooks

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              AIPM Universal Session Store                 â”‚
â”‚              (Provider-Agnostic Database)                 â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Sessions                                            â”‚ â”‚
â”‚  â”‚  â”œâ”€ session_id (UUID)                              â”‚ â”‚
â”‚  â”‚  â”œâ”€ project_id, work_item_id, task_id             â”‚ â”‚
â”‚  â”‚  â”œâ”€ provider: claude | cursor | aider | copilot   â”‚ â”‚
â”‚  â”‚  â”œâ”€ started_at, ended_at, duration                â”‚ â”‚
â”‚  â”‚  â”œâ”€ context_loaded: Dict (what was loaded)        â”‚ â”‚
â”‚  â”‚  â”œâ”€ learnings_captured: List (what was learned)   â”‚ â”‚
â”‚  â”‚  â””â”€ files_modified: List (code changes)           â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ Session Timeline (unified across providers)        â”‚ â”‚
â”‚  â”‚  â”œâ”€ timeline_id, session_id                        â”‚ â”‚
â”‚  â”‚  â”œâ”€ event_type: decision | pattern | code_change  â”‚ â”‚
â”‚  â”‚  â”œâ”€ event_data: Dict (what happened)              â”‚ â”‚
â”‚  â”‚  â”œâ”€ provider: which provider was active           â”‚ â”‚
â”‚  â”‚  â””â”€ timestamp: when it happened                   â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ Provider Handoffs                                  â”‚ â”‚
â”‚  â”‚  â”œâ”€ handoff_id                                     â”‚ â”‚
â”‚  â”‚  â”œâ”€ from_provider, to_provider                    â”‚ â”‚
â”‚  â”‚  â”œâ”€ from_session_id, to_session_id               â”‚ â”‚
â”‚  â”‚  â”œâ”€ handoff_context: Dict (state at handoff)     â”‚ â”‚
â”‚  â”‚  â””â”€ handoff_at: timestamp                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚            â”‚            â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Claude Code  â”‚  â”‚  Cursor  â”‚  â”‚  Aider   â”‚
   â”‚  Adapter     â”‚  â”‚  Adapter â”‚  â”‚  Adapter â”‚
   â”‚              â”‚  â”‚          â”‚  â”‚          â”‚
   â”‚ Session Hook â”‚  â”‚ Session  â”‚  â”‚ Session  â”‚
   â”‚   Start â”€â”€â”  â”‚  â”‚  Hook    â”‚  â”‚  Hook    â”‚
   â”‚   End â”€â”€â”€â”€â”¤  â”‚  â”‚  Start   â”‚  â”‚  Start   â”‚
   â”‚           â”‚  â”‚  â”‚  End     â”‚  â”‚  End     â”‚
   â”‚   Handoffâ”€â”˜  â”‚  â”‚  Handoff â”‚  â”‚  Handoff â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                 â”‚              â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
         Automatic Context Loading
         (same for all providers)
```

### Session Lifecycle

```python
class UniversalSessionManager:
    """
    Manages sessions across all AI providers.

    Provider-agnostic: Works with Claude, Cursor, Aider, Copilot, etc.
    """

    def start_session(
        self,
        provider: str,
        work_item_id: Optional[int] = None,
        task_id: Optional[int] = None,
        auto_detect: bool = True
    ) -> Session:
        """
        Start a new session.

        Steps:
        1. Detect active work item/task (if auto_detect)
        2. Load previous session (if exists)
        3. Check for handoff (switching from another provider)
        4. Load full context for work item/task
        5. Create session record
        6. Return session with context

        Example:
        # Claude Code hook calls this
        session = manager.start_session(
            provider="claude-code",
            auto_detect=True
        )

        # Cursor hook calls this
        session = manager.start_session(
            provider="cursor",
            work_item_id=5  # Explicit work item
        )
        """

        # 1. Detect context
        if auto_detect:
            work_item_id, task_id = self._detect_active_work(provider)

        if not work_item_id:
            # No active work, prompt user
            print("No active work item. Use: apm work-item list")
            return None

        # 2. Check for previous session
        previous_session = self._get_latest_session(work_item_id)

        # 3. Check for provider handoff
        handoff = None
        if previous_session and previous_session.provider != provider:
            handoff = self._create_handoff(
                from_session=previous_session,
                to_provider=provider
            )
            print(f"ğŸ”„ Handoff from {previous_session.provider} to {provider}")
            print(f"   Previous session: {previous_session.duration} duration")
            print(f"   Learnings captured: {len(previous_session.learnings_captured)}")

        # 4. Load context (provider-agnostic)
        context = self.context_loader.load_context_for_task(task_id)

        # 5. Create session
        session = Session(
            id=generate_uuid(),
            project_id=context.project.id,
            work_item_id=work_item_id,
            task_id=task_id,
            provider=provider,
            started_at=datetime.now(),
            context_loaded=self._serialize_context(context),
            previous_session_id=previous_session.id if previous_session else None,
            handoff_id=handoff.id if handoff else None
        )

        db.add(session)
        db.commit()

        # 6. Return session with context
        return SessionWithContext(
            session=session,
            context=context,
            handoff=handoff
        )

    def end_session(self, session_id: str) -> SessionSummary:
        """
        End session and capture learnings.

        Steps:
        1. Calculate session duration
        2. Capture all learnings made during session
        3. Record files modified
        4. Generate session summary
        5. Update session record
        6. Return summary

        Example:
        # Claude Code hook calls this
        summary = manager.end_session(session_id)

        print(f"Session summary:")
        print(f"  Duration: {summary.duration}")
        print(f"  Decisions: {len(summary.decisions)}")
        print(f"  Files modified: {len(summary.files_modified)}")
        """

        session = db.query(Session).get(session_id)

        # 1. Calculate duration
        session.ended_at = datetime.now()
        session.duration = session.ended_at - session.started_at

        # 2. Capture learnings (from database, not session)
        learnings = db.query(Learning).filter(
            Learning.session_id == session_id
        ).all()
        session.learnings_captured = [l.id for l in learnings]

        # 3. Record files modified (from git)
        files_modified = self._get_modified_files(session)
        session.files_modified = files_modified

        # 4. Generate summary
        summary = SessionSummary(
            session_id=session_id,
            duration=session.duration,
            decisions=[l for l in learnings if l.learning_type == "decision"],
            patterns=[l for l in learnings if l.learning_type == "pattern"],
            discoveries=[l for l in learnings if l.learning_type == "discovery"],
            files_modified=files_modified,
            lines_added=self._count_lines_added(files_modified),
            lines_deleted=self._count_lines_deleted(files_modified)
        )

        # 5. Update session
        db.commit()

        # 6. Return summary
        return summary

    def handoff_to_provider(
        self,
        current_session_id: str,
        to_provider: str
    ) -> HandoffResult:
        """
        Explicit handoff to another provider.

        Use case: User wants to switch providers mid-work

        Example:
        # Currently in Claude Code
        apm session handoff --to=cursor

        # Captures state, prepares for Cursor
        # Next time Cursor starts, it gets full context
        """

        current_session = db.query(Session).get(current_session_id)

        # End current session
        summary = self.end_session(current_session_id)

        # Create handoff record
        handoff = ProviderHandoff(
            id=generate_uuid(),
            from_provider=current_session.provider,
            to_provider=to_provider,
            from_session_id=current_session_id,
            work_item_id=current_session.work_item_id,
            task_id=current_session.task_id,
            handoff_context={
                "summary": summary.to_dict(),
                "active_files": current_session.files_modified,
                "next_steps": self._suggest_next_steps(summary)
            },
            handoff_at=datetime.now()
        )

        db.add(handoff)
        db.commit()

        return HandoffResult(
            handoff_id=handoff.id,
            to_provider=to_provider,
            message=f"""
            âœ… Handoff prepared for {to_provider}

            Summary:
            - Duration: {summary.duration}
            - Decisions: {len(summary.decisions)}
            - Files modified: {len(summary.files_modified)}

            Next: Open {to_provider} and continue work.
            Context will load automatically.
            """
        )
```

### Provider-Specific Hooks

#### Claude Code Hooks

```python
# .claude/hooks/session-start.py
from agentpm.core.sessions import UniversalSessionManager


def session_start():
    """
    Called automatically when Claude Code starts.
    """

    manager = UniversalSessionManager()

    # Start session (auto-detect work item/task)
    session_ctx = manager.start_session(
        provider="claude-code",
        auto_detect=True
    )

    if not session_ctx:
        print("No active work. Use: apm work-item list")
        return

    # Format context for Claude Code (markdown)
    context_md = format_context_for_claude(session_ctx.context)

    # Show handoff info if switching from another provider
    if session_ctx.handoff:
        print(f"ğŸ”„ Continuing from {session_ctx.handoff.from_provider}")
        print(f"   Last session: {session_ctx.handoff.handoff_context['summary']}")

    # Output context (Claude Code auto-injects)
    print(context_md)


# .claude/hooks/session-end.py
def session_end():
    """
    Called automatically when Claude Code ends.
    """

    manager = UniversalSessionManager()

    # Get current session ID (from environment or file)
    session_id = get_current_session_id()

    # End session (captures learnings automatically)
    summary = manager.end_session(session_id)

    print(f"âœ… Session ended")
    print(f"   Duration: {summary.duration}")
    print(f"   Decisions: {len(summary.decisions)}")
    print(f"   Files modified: {len(summary.files_modified)}")
```

#### Cursor Hooks

```typescript
// .cursor/hooks/session-start.ts
import { AIPMSessionManager } from 'aipm-cursor-adapter';

export async function sessionStart() {
    const manager = new AIPMSessionManager();

    // Start session
    const sessionCtx = await manager.startSession({
        provider: 'cursor',
        autoDetect: true
    });

    if (!sessionCtx) {
        console.log('No active work. Use: apm work-item list');
        return null;
    }

    // Format context for Cursor (JSON)
    const contextJson = formatContextForCursor(sessionCtx.context);

    // Show handoff info
    if (sessionCtx.handoff) {
        console.log(`ğŸ”„ Continuing from ${sessionCtx.handoff.fromProvider}`);
    }

    // Return context (Cursor loads automatically)
    return contextJson;
}

// .cursor/hooks/session-end.ts
export async function sessionEnd() {
    const manager = new AIPMSessionManager();
    const sessionId = getCurrentSessionId();
    const summary = await manager.endSession(sessionId);

    console.log(`âœ… Session ended: ${summary.duration}`);
}
```

#### Aider Hooks

```yaml
# .aider.conf.yml
hooks:
  session_start:
    command: "apm session start --provider=aider --format=aider"
    output_to: "/tmp/aipm-context.md"
    inject_with: "--read /tmp/aipm-context.md"

  session_end:
    command: "apm session end --capture-learning"

  on_commit:
    command: "apm session update --event=commit --data='$COMMIT_HASH'"
```

### Unified Timeline

```python
class SessionTimelineService:
    """
    Creates unified timeline across all providers.
    """

    def get_timeline(
        self,
        work_item_id: int,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Timeline:
        """
        Get complete timeline for work item across all providers.

        Returns unified view of:
        - All sessions (across providers)
        - All decisions made
        - All code changes
        - Provider switches

        Example timeline:
        Mon 9:00 AM  [Claude Code] Session started
        Mon 9:15 AM  [Claude Code] Decision: Use JWT tokens
        Mon 10:30 AM [Claude Code] Session ended (1.5h)
        Mon 2:00 PM  [Cursor] Session started (handoff from Claude Code)
        Mon 2:45 PM  [Cursor] Code: Implemented JWT middleware
        Mon 3:30 PM  [Cursor] Session ended (1.5h)
        Tue 9:00 AM  [Aider] Session started (handoff from Cursor)
        Tue 9:30 AM  [Aider] Commit: "Add JWT authentication"
        Tue 10:00 AM [Aider] Session ended (1h)
        """

        # Get all sessions for work item
        sessions = db.query(Session).filter(
            Session.work_item_id == work_item_id
        ).order_by(Session.started_at).all()

        # Build timeline
        timeline = Timeline(work_item_id=work_item_id, events=[])

        for session in sessions:
            # Session start event
            timeline.add_event(TimelineEvent(
                timestamp=session.started_at,
                event_type="session_start",
                provider=session.provider,
                data={"session_id": session.id}
            ))

            # Learnings during session
            learnings = db.query(Learning).filter(
                Learning.session_id == session.id
            ).order_by(Learning.timestamp).all()

            for learning in learnings:
                timeline.add_event(TimelineEvent(
                    timestamp=learning.timestamp,
                    event_type=learning.learning_type,
                    provider=session.provider,
                    data={
                        "content": learning.content,
                        "confidence": learning.confidence
                    }
                ))

            # Session end event
            if session.ended_at:
                timeline.add_event(TimelineEvent(
                    timestamp=session.ended_at,
                    event_type="session_end",
                    provider=session.provider,
                    data={
                        "duration": str(session.duration),
                        "files_modified": len(session.files_modified)
                    }
                ))

            # Handoff event (if next session is different provider)
            if session.handoff_id:
                handoff = db.query(ProviderHandoff).get(session.handoff_id)
                timeline.add_event(TimelineEvent(
                    timestamp=handoff.handoff_at,
                    event_type="provider_handoff",
                    provider=session.provider,
                    data={
                        "to_provider": handoff.to_provider,
                        "reason": "Manual handoff"
                    }
                ))

        return timeline

    def visualize_timeline(self, timeline: Timeline) -> str:
        """
        Generate ASCII visualization of timeline.

        Output:
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Work Item #5: Multi-Tenant Authentication           â”‚
        â”‚ Timeline: Oct 11-12, 2025                          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        Oct 11, 9:00 AM  â”Œâ”€ [Claude Code] Session start
                         â”‚
        Oct 11, 9:15 AM  â”œâ”€ ğŸ’¡ Decision: Use JWT tokens
                         â”‚
        Oct 11, 10:30 AM â””â”€ Session end (1.5h, 2 decisions)

        Oct 11, 2:00 PM  â”Œâ”€ [Cursor] Session start
                         â”‚  ğŸ”„ Handoff from Claude Code
                         â”‚
        Oct 11, 2:45 PM  â”œâ”€ ğŸ’» Code: JWT middleware
                         â”‚
        Oct 11, 3:30 PM  â””â”€ Session end (1.5h, 3 files)

        Oct 12, 9:00 AM  â”Œâ”€ [Aider] Session start
                         â”‚  ğŸ”„ Handoff from Cursor
                         â”‚
        Oct 12, 9:30 AM  â”œâ”€ ğŸ“ Commit: "Add JWT auth"
                         â”‚
        Oct 12, 10:00 AM â””â”€ Session end (1h)
        """
```

---

## Consequences

### Positive

1. **Seamless Provider Switching**
   - No context loss when changing providers
   - Work continues naturally
   - Best tool for each task

2. **Unified Project View**
   - Single timeline across all providers
   - Complete audit trail
   - Easy to understand project history

3. **Provider-Specific Optimization**
   - Use Claude for architecture decisions
   - Use Cursor for real-time coding
   - Use Aider for git workflows
   - Each provider optimized for its strength

4. **Cross-Team Collaboration**
   - Team members can use different providers
   - Shared context regardless of tool
   - No "Claude team" vs "Cursor team" silos

5. **Future-Proof**
   - Easy to add new providers
   - Not locked into any single tool
   - Migrate providers without data loss

### Negative

1. **Handoff Overhead**
   - Manual handoff command required
   - Small delay during handoff (<1s)
   - Users must remember to handoff

2. **Provider Capability Variance**
   - Not all providers support all features
   - Some features provider-specific
   - Documentation complexity (multiple providers)

3. **Testing Complexity**
   - Must test with all providers
   - Integration tests for each provider
   - Handoff scenarios exponentially complex

4. **Session ID Management**
   - Need to track session ID across providers
   - Environment variable or file-based
   - Risk of orphaned sessions

### Mitigation Strategies

1. **Automatic Handoff Detection**
   - Detect provider switch automatically
   - Prompt user to confirm handoff
   - Auto-handoff after idle timeout (optional)

2. **Feature Parity Documentation**
   - Clear docs on what each provider supports
   - Feature comparison matrix
   - Provider recommendation guide

3. **Comprehensive Testing**
   - Docker-based integration tests
   - Handoff scenario library
   - Automated provider testing

4. **Session Management Automation**
   - Store session ID in .agentpm/session file
   - Auto-cleanup of old sessions
   - Session recovery on crash

---

## Implementation Plan

### Phase 1: Core Session Management (Week 1-2)

```yaml
Week 1: Database & Models
  Tasks:
    - Create sessions table
    - Create timeline_events table
    - Create provider_handoffs table
    - Add indices

  Deliverables:
    - Migration: 0018_add_session_management.py
    - Models: Session, TimelineEvent, ProviderHandoff
    - Tests: test_session_models.py

  Success Criteria:
    - All CRUD operations work
    - Queries <100ms
    - Relationships correct

Week 2: Universal Session Manager
  Tasks:
    - Implement UniversalSessionManager
    - Session lifecycle (start/end)
    - Handoff protocol
    - Context assembly integration

  Deliverables:
    - agentpm/core/sessions/manager.py
    - Session management tests-BAK
    - CLI: apm session start/end/handoff

  Success Criteria:
    - Sessions start/end correctly
    - Context loads automatically
    - Handoffs work
```

### Phase 2: Provider Integration (Week 3-6)

```yaml
Week 3-4: Claude Code Integration
  Tasks:
    - Session start/end hooks
    - Context formatting (markdown)
    - Handoff commands
    - Testing

  Deliverables:
    - .claude/hooks/session-start.py
    - .claude/hooks/session-end.py
    - Integration tests-BAK
    - Documentation

  Success Criteria:
    - Auto-starts sessions
    - Context loads in <1s
    - Handoffs work

Week 5: Cursor Integration
  Tasks:
    - Cursor adapter
    - Session hooks (TypeScript)
    - Context formatting (JSON)
    - Testing

  Deliverables:
    - aipm-cursor-adapter npm package
    - .cursor/hooks/
    - Integration tests-BAK
    - Documentation

  Success Criteria:
    - Cursor sessions work
    - Handoff from/to Claude Code works

Week 6: Aider Integration
  Tasks:
    - Aider adapter
    - YAML config hooks
    - Context formatting (Markdown)
    - Testing

  Deliverables:
    - .aider.conf.yml template
    - Aider integration guide
    - Integration tests-BAK

  Success Criteria:
    - Aider sessions work
    - Handoff to/from other providers works
```

### Phase 3: Timeline & Reporting (Week 7-8)

```yaml
Week 7: Unified Timeline
  Tasks:
    - Implement SessionTimelineService
    - Timeline visualization
    - Cross-provider analytics
    - Dashboard (CLI)

  Deliverables:
    - agentpm/core/sessions/timeline.py
    - CLI: apm session timeline
    - Timeline visualization
    - Analytics reports

  Success Criteria:
    - Timeline shows all providers
    - Visualization readable
    - Analytics accurate

Week 8: Integration Testing
  Tasks:
    - E2E multi-provider tests-BAK
    - Handoff scenario tests-BAK
    - Performance testing
    - Documentation

  Deliverables:
    - E2E test suite
    - Handoff test scenarios
    - Performance benchmarks
    - Multi-provider guide

  Success Criteria:
    - All handoff scenarios work
    - Performance targets met
    - Docs complete
```

---

## Usage Examples

### Example 1: Typical Multi-Provider Workflow

```bash
# Monday morning: Start with Claude Code
# (Hook runs automatically on Claude Code start)

ğŸ¤– Claude Code session started
ğŸ“‹ Work Item: Multi-Tenant Authentication (WI-5)
âœ… Task: Implement JWT middleware (Task-42)

Context loaded:
  - Project: Django e-commerce platform
  - Tech stack: Django 4.2, PostgreSQL 15
  - Decisions: 3 previous decisions loaded
  - Patterns: 5 patterns available

# Work for 1.5 hours, make architectural decisions

# Monday afternoon: Switch to Cursor for implementation
apm session handoff --to=cursor

âœ… Handoff prepared for cursor

Summary:
- Duration: 1h 30m
- Decisions: 2 (JWT tokens, token refresh strategy)
- Files modified: 0 (architecture phase)

Next: Open Cursor and continue work.

# Open Cursor (hook runs automatically)

ğŸ–±ï¸ Cursor session started
ğŸ”„ Continuing from claude-code
ğŸ“‹ Previous session: 1h 30m, 2 decisions

Context loaded (same context as Claude Code):
  - All decisions from Claude Code session
  - JWT token architecture
  - Implementation patterns to follow

# Code for 1.5 hours in Cursor

# Tuesday morning: Switch to Aider for commit
apm session handoff --to=aider

# Open Aider
$ aider

ğŸ“ Aider session started
ğŸ”„ Continuing from cursor
ğŸ“‹ Previous session: 1h 30m, 3 files modified

# Commit with full context
$ /commit

Aider suggests commit message based on context:
"feat: Add JWT authentication middleware

- Implement JWT token generation and verification
- Add token refresh endpoint
- Configure token expiry (15min access, 7 days refresh)

Based on architecture decision from claude-code session.
Implementation follows established ServiceLayer pattern."

âœ… Committed with full context
```

### Example 2: Cross-Provider Timeline

```bash
apm session timeline --work-item=5

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Work Item #5: Multi-Tenant Authentication           â”‚
â”‚ Timeline: Oct 11-12, 2025                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Oct 11, 9:00 AM  â”Œâ”€ [Claude Code] Session start
                 â”‚
Oct 11, 9:15 AM  â”œâ”€ ğŸ’¡ Decision: Use JWT tokens
                 â”‚   Confidence: 0.87
                 â”‚   Evidence: 4 sources
                 â”‚
Oct 11, 9:45 AM  â”œâ”€ ğŸ’¡ Decision: Token refresh strategy
                 â”‚   Confidence: 0.82
                 â”‚
Oct 11, 10:30 AM â””â”€ Session end (1h 30m, 2 decisions)

Oct 11, 2:00 PM  â”Œâ”€ [Cursor] Session start
                 â”‚  ğŸ”„ Handoff from Claude Code
                 â”‚
Oct 11, 2:15 PM  â”œâ”€ ğŸ’» Code: models/jwt_token.py
                 â”‚
Oct 11, 2:45 PM  â”œâ”€ ğŸ’» Code: auth/jwt_middleware.py
                 â”‚
Oct 11, 3:15 PM  â”œâ”€ ğŸ’» Code: auth/services/jwt_service.py
                 â”‚
Oct 11, 3:30 PM  â””â”€ Session end (1h 30m, 3 files)

Oct 12, 9:00 AM  â”Œâ”€ [Aider] Session start
                 â”‚  ğŸ”„ Handoff from Cursor
                 â”‚
Oct 12, 9:30 AM  â”œâ”€ ğŸ“ Commit: "feat: Add JWT authentication"
                 â”‚   Files: 3 modified, +420 lines
                 â”‚
Oct 12, 10:00 AM â””â”€ Session end (1h)

Total: 3 sessions, 3 providers, 4 hours work
Decisions: 2 | Files modified: 3 | Commits: 1
```

---

## Related Documents

- **AIPM-V2-COMPLETE-SPECIFICATION.md**: Overall system
- **ADR-001**: Provider Abstraction Architecture
- **ADR-002**: Context Compression Strategy
- **ADR-003**: Sub-Agent Communication Protocol
- **ADR-004**: Evidence Storage and Retrieval

---

## Decision Log

| Date | Decision | Rationale |
|------|----------|-----------|
| 2025-10-12 | Provider-agnostic session store | Not tied to any single provider |
| 2025-10-12 | Unified timeline across providers | Single source of truth |
| 2025-10-12 | Explicit handoff command | Clear intent, no accidental switches |
| 2025-10-12 | Provider-specific hooks | Leverage each provider's strengths |
| 2025-10-12 | Automatic context loading | Zero configuration for users |

---

**Status:** Proposed (awaiting review)
**Next Steps:**
1. Review with AIPM core team
2. Prototype session management with Claude Code
3. Test handoff to Cursor
4. Approve and begin implementation

**Owner:** AIPM Core Team
**Reviewers:** TBD
**Last Updated:** 2025-10-12
