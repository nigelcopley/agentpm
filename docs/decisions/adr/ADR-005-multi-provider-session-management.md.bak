# ADR-005: Multi-Provider Session Management

**Status:** Proposed
**Date:** 2025-10-12
**Deciders:** AIPM Core Team
**Technical Story:** Enable seamless session continuity across multiple AI coding assistant providers

---

## Context

### The Multi-Provider Challenge

Developers use different AI coding assistants for different tasks:
- **Claude Code**: Complex reasoning, architecture decisions
- **Cursor**: Real-time coding, autocomplete
- **Aider**: Command-line workflows, git integration
- **GitHub Copilot**: IDE integration, suggestions
- **Gemini**: Google ecosystem integration

**Current Problem:**

```
Monday AM: Use Claude Code
├─ Work on authentication feature
├─ Make decision: "Use JWT tokens"
├─ Context stored in... where?
└─ Session ends

Monday PM: Switch to Cursor
├─ Continue authentication work
├─ No access to JWT decision ❌
├─ Asks: "Should I use sessions or tokens?"
└─ User must re-explain everything

Tuesday: Use Aider for git workflow
├─ Need to commit auth changes
├─ No context on what was decided ❌
├─ Commit message generic: "Update auth"
└─ Lost architectural context
```

**Result:**
- Context doesn't survive provider switches
- Decisions made in one provider lost to others
- Work fragmented across providers
- No unified project view

### Requirements

1. **Provider-Agnostic Sessions**: Sessions not tied to specific provider
2. **Seamless Handoff**: Switch providers mid-work without context loss
3. **Unified History**: Single timeline across all providers
4. **Provider-Specific Optimization**: Leverage each provider's strengths
5. **Automatic Context Loading**: No manual context transfer

---

## Decision

We will implement a **Universal Session Management System** with:

1. **Provider-Agnostic Session Store**: Database tracks all sessions regardless of provider
2. **Automatic Context Assembly**: Context loaded based on work item/task, not provider
3. **Provider Handoff Protocol**: Explicit handoff commands for provider switches
4. **Unified Audit Trail**: Single timeline showing all provider activity
5. **Provider-Specific Hooks**: Each provider integrates via standard hooks

### Architecture

```
┌──────────────────────────────────────────────────────────┐
│              AIPM Universal Session Store                 │
│              (Provider-Agnostic Database)                 │
│                                                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ Sessions                                            │ │
│  │  ├─ session_id (UUID)                              │ │
│  │  ├─ project_id, work_item_id, task_id             │ │
│  │  ├─ provider: claude | cursor | aider | copilot   │ │
│  │  ├─ started_at, ended_at, duration                │ │
│  │  ├─ context_loaded: Dict (what was loaded)        │ │
│  │  ├─ learnings_captured: List (what was learned)   │ │
│  │  └─ files_modified: List (code changes)           │ │
│  ├─────────────────────────────────────────────────────┤ │
│  │ Session Timeline (unified across providers)        │ │
│  │  ├─ timeline_id, session_id                        │ │
│  │  ├─ event_type: decision | pattern | code_change  │ │
│  │  ├─ event_data: Dict (what happened)              │ │
│  │  ├─ provider: which provider was active           │ │
│  │  └─ timestamp: when it happened                   │ │
│  ├─────────────────────────────────────────────────────┤ │
│  │ Provider Handoffs                                  │ │
│  │  ├─ handoff_id                                     │ │
│  │  ├─ from_provider, to_provider                    │ │
│  │  ├─ from_session_id, to_session_id               │ │
│  │  ├─ handoff_context: Dict (state at handoff)     │ │
│  │  └─ handoff_at: timestamp                         │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────┬────────────┬────────────┬─────────────────┘
              │            │            │
   ┌──────────▼───┐  ┌────▼─────┐  ┌──▼───────┐
   │ Claude Code  │  │  Cursor  │  │  Aider   │
   │  Adapter     │  │  Adapter │  │  Adapter │
   │              │  │          │  │          │
   │ Session Hook │  │ Session  │  │ Session  │
   │   Start ──┐  │  │  Hook    │  │  Hook    │
   │   End ────┤  │  │  Start   │  │  Start   │
   │           │  │  │  End     │  │  End     │
   │   Handoff─┘  │  │  Handoff │  │  Handoff │
   └──────────────┘  └──────────┘  └──────────┘
         │                 │              │
         └─────────┬───────┴──────────────┘
                   │
         Automatic Context Loading
         (same for all providers)
```

### Session Lifecycle

```python
class UniversalSessionManager:
    """
    Manages sessions across all AI providers.

    Provider-agnostic: Works with Claude, Cursor, Aider, Copilot, etc.
    """

    def start_session(
        self,
        provider: str,
        work_item_id: Optional[int] = None,
        task_id: Optional[int] = None,
        auto_detect: bool = True
    ) -> Session:
        """
        Start a new session.

        Steps:
        1. Detect active work item/task (if auto_detect)
        2. Load previous session (if exists)
        3. Check for handoff (switching from another provider)
        4. Load full context for work item/task
        5. Create session record
        6. Return session with context

        Example:
        # Claude Code hook calls this
        session = manager.start_session(
            provider="claude-code",
            auto_detect=True
        )

        # Cursor hook calls this
        session = manager.start_session(
            provider="cursor",
            work_item_id=5  # Explicit work item
        )
        """

        # 1. Detect context
        if auto_detect:
            work_item_id, task_id = self._detect_active_work(provider)

        if not work_item_id:
            # No active work, prompt user
            print("No active work item. Use: apm work-item list")
            return None

        # 2. Check for previous session
        previous_session = self._get_latest_session(work_item_id)

        # 3. Check for provider handoff
        handoff = None
        if previous_session and previous_session.provider != provider:
            handoff = self._create_handoff(
                from_session=previous_session,
                to_provider=provider
            )
            print(f"🔄 Handoff from {previous_session.provider} to {provider}")
            print(f"   Previous session: {previous_session.duration} duration")
            print(f"   Learnings captured: {len(previous_session.learnings_captured)}")

        # 4. Load context (provider-agnostic)
        context = self.context_loader.load_context_for_task(task_id)

        # 5. Create session
        session = Session(
            id=generate_uuid(),
            project_id=context.project.id,
            work_item_id=work_item_id,
            task_id=task_id,
            provider=provider,
            started_at=datetime.now(),
            context_loaded=self._serialize_context(context),
            previous_session_id=previous_session.id if previous_session else None,
            handoff_id=handoff.id if handoff else None
        )

        db.add(session)
        db.commit()

        # 6. Return session with context
        return SessionWithContext(
            session=session,
            context=context,
            handoff=handoff
        )

    def end_session(self, session_id: str) -> SessionSummary:
        """
        End session and capture learnings.

        Steps:
        1. Calculate session duration
        2. Capture all learnings made during session
        3. Record files modified
        4. Generate session summary
        5. Update session record
        6. Return summary

        Example:
        # Claude Code hook calls this
        summary = manager.end_session(session_id)

        print(f"Session summary:")
        print(f"  Duration: {summary.duration}")
        print(f"  Decisions: {len(summary.decisions)}")
        print(f"  Files modified: {len(summary.files_modified)}")
        """

        session = db.query(Session).get(session_id)

        # 1. Calculate duration
        session.ended_at = datetime.now()
        session.duration = session.ended_at - session.started_at

        # 2. Capture learnings (from database, not session)
        learnings = db.query(Learning).filter(
            Learning.session_id == session_id
        ).all()
        session.learnings_captured = [l.id for l in learnings]

        # 3. Record files modified (from git)
        files_modified = self._get_modified_files(session)
        session.files_modified = files_modified

        # 4. Generate summary
        summary = SessionSummary(
            session_id=session_id,
            duration=session.duration,
            decisions=[l for l in learnings if l.learning_type == "decision"],
            patterns=[l for l in learnings if l.learning_type == "pattern"],
            discoveries=[l for l in learnings if l.learning_type == "discovery"],
            files_modified=files_modified,
            lines_added=self._count_lines_added(files_modified),
            lines_deleted=self._count_lines_deleted(files_modified)
        )

        # 5. Update session
        db.commit()

        # 6. Return summary
        return summary

    def handoff_to_provider(
        self,
        current_session_id: str,
        to_provider: str
    ) -> HandoffResult:
        """
        Explicit handoff to another provider.

        Use case: User wants to switch providers mid-work

        Example:
        # Currently in Claude Code
        apm session handoff --to=cursor

        # Captures state, prepares for Cursor
        # Next time Cursor starts, it gets full context
        """

        current_session = db.query(Session).get(current_session_id)

        # End current session
        summary = self.end_session(current_session_id)

        # Create handoff record
        handoff = ProviderHandoff(
            id=generate_uuid(),
            from_provider=current_session.provider,
            to_provider=to_provider,
            from_session_id=current_session_id,
            work_item_id=current_session.work_item_id,
            task_id=current_session.task_id,
            handoff_context={
                "summary": summary.to_dict(),
                "active_files": current_session.files_modified,
                "next_steps": self._suggest_next_steps(summary)
            },
            handoff_at=datetime.now()
        )

        db.add(handoff)
        db.commit()

        return HandoffResult(
            handoff_id=handoff.id,
            to_provider=to_provider,
            message=f"""
            ✅ Handoff prepared for {to_provider}

            Summary:
            - Duration: {summary.duration}
            - Decisions: {len(summary.decisions)}
            - Files modified: {len(summary.files_modified)}

            Next: Open {to_provider} and continue work.
            Context will load automatically.
            """
        )
```

### Provider-Specific Hooks

#### Claude Code Hooks

```python
# .claude/hooks/session-start.py
from agentpm.core.sessions import UniversalSessionManager


def session_start():
    """
    Called automatically when Claude Code starts.
    """

    manager = UniversalSessionManager()

    # Start session (auto-detect work item/task)
    session_ctx = manager.start_session(
        provider="claude-code",
        auto_detect=True
    )

    if not session_ctx:
        print("No active work. Use: apm work-item list")
        return

    # Format context for Claude Code (markdown)
    context_md = format_context_for_claude(session_ctx.context)

    # Show handoff info if switching from another provider
    if session_ctx.handoff:
        print(f"🔄 Continuing from {session_ctx.handoff.from_provider}")
        print(f"   Last session: {session_ctx.handoff.handoff_context['summary']}")

    # Output context (Claude Code auto-injects)
    print(context_md)


# .claude/hooks/session-end.py
def session_end():
    """
    Called automatically when Claude Code ends.
    """

    manager = UniversalSessionManager()

    # Get current session ID (from environment or file)
    session_id = get_current_session_id()

    # End session (captures learnings automatically)
    summary = manager.end_session(session_id)

    print(f"✅ Session ended")
    print(f"   Duration: {summary.duration}")
    print(f"   Decisions: {len(summary.decisions)}")
    print(f"   Files modified: {len(summary.files_modified)}")
```

#### Cursor Hooks

```typescript
// .cursor/hooks/session-start.ts
import { AIPMSessionManager } from 'aipm-cursor-adapter';

export async function sessionStart() {
    const manager = new AIPMSessionManager();

    // Start session
    const sessionCtx = await manager.startSession({
        provider: 'cursor',
        autoDetect: true
    });

    if (!sessionCtx) {
        console.log('No active work. Use: apm work-item list');
        return null;
    }

    // Format context for Cursor (JSON)
    const contextJson = formatContextForCursor(sessionCtx.context);

    // Show handoff info
    if (sessionCtx.handoff) {
        console.log(`🔄 Continuing from ${sessionCtx.handoff.fromProvider}`);
    }

    // Return context (Cursor loads automatically)
    return contextJson;
}

// .cursor/hooks/session-end.ts
export async function sessionEnd() {
    const manager = new AIPMSessionManager();
    const sessionId = getCurrentSessionId();
    const summary = await manager.endSession(sessionId);

    console.log(`✅ Session ended: ${summary.duration}`);
}
```

#### Aider Hooks

```yaml
# .aider.conf.yml
hooks:
  session_start:
    command: "apm session start --provider=aider --format=aider"
    output_to: "/tmp/aipm-context.md"
    inject_with: "--read /tmp/aipm-context.md"

  session_end:
    command: "apm session end --capture-learning"

  on_commit:
    command: "apm session update --event=commit --data='$COMMIT_HASH'"
```

### Unified Timeline

```python
class SessionTimelineService:
    """
    Creates unified timeline across all providers.
    """

    def get_timeline(
        self,
        work_item_id: int,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> Timeline:
        """
        Get complete timeline for work item across all providers.

        Returns unified view of:
        - All sessions (across providers)
        - All decisions made
        - All code changes
        - Provider switches

        Example timeline:
        Mon 9:00 AM  [Claude Code] Session started
        Mon 9:15 AM  [Claude Code] Decision: Use JWT tokens
        Mon 10:30 AM [Claude Code] Session ended (1.5h)
        Mon 2:00 PM  [Cursor] Session started (handoff from Claude Code)
        Mon 2:45 PM  [Cursor] Code: Implemented JWT middleware
        Mon 3:30 PM  [Cursor] Session ended (1.5h)
        Tue 9:00 AM  [Aider] Session started (handoff from Cursor)
        Tue 9:30 AM  [Aider] Commit: "Add JWT authentication"
        Tue 10:00 AM [Aider] Session ended (1h)
        """

        # Get all sessions for work item
        sessions = db.query(Session).filter(
            Session.work_item_id == work_item_id
        ).order_by(Session.started_at).all()

        # Build timeline
        timeline = Timeline(work_item_id=work_item_id, events=[])

        for session in sessions:
            # Session start event
            timeline.add_event(TimelineEvent(
                timestamp=session.started_at,
                event_type="session_start",
                provider=session.provider,
                data={"session_id": session.id}
            ))

            # Learnings during session
            learnings = db.query(Learning).filter(
                Learning.session_id == session.id
            ).order_by(Learning.timestamp).all()

            for learning in learnings:
                timeline.add_event(TimelineEvent(
                    timestamp=learning.timestamp,
                    event_type=learning.learning_type,
                    provider=session.provider,
                    data={
                        "content": learning.content,
                        "confidence": learning.confidence
                    }
                ))

            # Session end event
            if session.ended_at:
                timeline.add_event(TimelineEvent(
                    timestamp=session.ended_at,
                    event_type="session_end",
                    provider=session.provider,
                    data={
                        "duration": str(session.duration),
                        "files_modified": len(session.files_modified)
                    }
                ))

            # Handoff event (if next session is different provider)
            if session.handoff_id:
                handoff = db.query(ProviderHandoff).get(session.handoff_id)
                timeline.add_event(TimelineEvent(
                    timestamp=handoff.handoff_at,
                    event_type="provider_handoff",
                    provider=session.provider,
                    data={
                        "to_provider": handoff.to_provider,
                        "reason": "Manual handoff"
                    }
                ))

        return timeline

    def visualize_timeline(self, timeline: Timeline) -> str:
        """
        Generate ASCII visualization of timeline.

        Output:
        ┌─────────────────────────────────────────────────────┐
        │ Work Item #5: Multi-Tenant Authentication           │
        │ Timeline: Oct 11-12, 2025                          │
        └─────────────────────────────────────────────────────┘

        Oct 11, 9:00 AM  ┌─ [Claude Code] Session start
                         │
        Oct 11, 9:15 AM  ├─ 💡 Decision: Use JWT tokens
                         │
        Oct 11, 10:30 AM └─ Session end (1.5h, 2 decisions)

        Oct 11, 2:00 PM  ┌─ [Cursor] Session start
                         │  🔄 Handoff from Claude Code
                         │
        Oct 11, 2:45 PM  ├─ 💻 Code: JWT middleware
                         │
        Oct 11, 3:30 PM  └─ Session end (1.5h, 3 files)

        Oct 12, 9:00 AM  ┌─ [Aider] Session start
                         │  🔄 Handoff from Cursor
                         │
        Oct 12, 9:30 AM  ├─ 📝 Commit: "Add JWT auth"
                         │
        Oct 12, 10:00 AM └─ Session end (1h)
        """
```

---

## Consequences

### Positive

1. **Seamless Provider Switching**
   - No context loss when changing providers
   - Work continues naturally
   - Best tool for each task

2. **Unified Project View**
   - Single timeline across all providers
   - Complete audit trail
   - Easy to understand project history

3. **Provider-Specific Optimization**
   - Use Claude for architecture decisions
   - Use Cursor for real-time coding
   - Use Aider for git workflows
   - Each provider optimized for its strength

4. **Cross-Team Collaboration**
   - Team members can use different providers
   - Shared context regardless of tool
   - No "Claude team" vs "Cursor team" silos

5. **Future-Proof**
   - Easy to add new providers
   - Not locked into any single tool
   - Migrate providers without data loss

### Negative

1. **Handoff Overhead**
   - Manual handoff command required
   - Small delay during handoff (<1s)
   - Users must remember to handoff

2. **Provider Capability Variance**
   - Not all providers support all features
   - Some features provider-specific
   - Documentation complexity (multiple providers)

3. **Testing Complexity**
   - Must test with all providers
   - Integration tests for each provider
   - Handoff scenarios exponentially complex

4. **Session ID Management**
   - Need to track session ID across providers
   - Environment variable or file-based
   - Risk of orphaned sessions

### Mitigation Strategies

1. **Automatic Handoff Detection**
   - Detect provider switch automatically
   - Prompt user to confirm handoff
   - Auto-handoff after idle timeout (optional)

2. **Feature Parity Documentation**
   - Clear docs on what each provider supports
   - Feature comparison matrix
   - Provider recommendation guide

3. **Comprehensive Testing**
   - Docker-based integration tests
   - Handoff scenario library
   - Automated provider testing

4. **Session Management Automation**
   - Store session ID in .agentpm/session file
   - Auto-cleanup of old sessions
   - Session recovery on crash

---

## Implementation Plan

### Phase 1: Core Session Management (Week 1-2)

```yaml
Week 1: Database & Models
  Tasks:
    - Create sessions table
    - Create timeline_events table
    - Create provider_handoffs table
    - Add indices

  Deliverables:
    - Migration: 0018_add_session_management.py
    - Models: Session, TimelineEvent, ProviderHandoff
    - Tests: test_session_models.py

  Success Criteria:
    - All CRUD operations work
    - Queries <100ms
    - Relationships correct

Week 2: Universal Session Manager
  Tasks:
    - Implement UniversalSessionManager
    - Session lifecycle (start/end)
    - Handoff protocol
    - Context assembly integration

  Deliverables:
    - agentpm/core/sessions/manager.py
    - Session management tests-BAK
    - CLI: apm session start/end/handoff

  Success Criteria:
    - Sessions start/end correctly
    - Context loads automatically
    - Handoffs work
```

### Phase 2: Provider Integration (Week 3-6)

```yaml
Week 3-4: Claude Code Integration
  Tasks:
    - Session start/end hooks
    - Context formatting (markdown)
    - Handoff commands
    - Testing

  Deliverables:
    - .claude/hooks/session-start.py
    - .claude/hooks/session-end.py
    - Integration tests-BAK
    - Documentation

  Success Criteria:
    - Auto-starts sessions
    - Context loads in <1s
    - Handoffs work

Week 5: Cursor Integration
  Tasks:
    - Cursor adapter
    - Session hooks (TypeScript)
    - Context formatting (JSON)
    - Testing

  Deliverables:
    - aipm-cursor-adapter npm package
    - .cursor/hooks/
    - Integration tests-BAK
    - Documentation

  Success Criteria:
    - Cursor sessions work
    - Handoff from/to Claude Code works

Week 6: Aider Integration
  Tasks:
    - Aider adapter
    - YAML config hooks
    - Context formatting (Markdown)
    - Testing

  Deliverables:
    - .aider.conf.yml template
    - Aider integration guide
    - Integration tests-BAK

  Success Criteria:
    - Aider sessions work
    - Handoff to/from other providers works
```

### Phase 3: Timeline & Reporting (Week 7-8)

```yaml
Week 7: Unified Timeline
  Tasks:
    - Implement SessionTimelineService
    - Timeline visualization
    - Cross-provider analytics
    - Dashboard (CLI)

  Deliverables:
    - agentpm/core/sessions/timeline.py
    - CLI: apm session timeline
    - Timeline visualization
    - Analytics reports

  Success Criteria:
    - Timeline shows all providers
    - Visualization readable
    - Analytics accurate

Week 8: Integration Testing
  Tasks:
    - E2E multi-provider tests-BAK
    - Handoff scenario tests-BAK
    - Performance testing
    - Documentation

  Deliverables:
    - E2E test suite
    - Handoff test scenarios
    - Performance benchmarks
    - Multi-provider guide

  Success Criteria:
    - All handoff scenarios work
    - Performance targets met
    - Docs complete
```

---

## Usage Examples

### Example 1: Typical Multi-Provider Workflow

```bash
# Monday morning: Start with Claude Code
# (Hook runs automatically on Claude Code start)

🤖 Claude Code session started
📋 Work Item: Multi-Tenant Authentication (WI-5)
✅ Task: Implement JWT middleware (Task-42)

Context loaded:
  - Project: Django e-commerce platform
  - Tech stack: Django 4.2, PostgreSQL 15
  - Decisions: 3 previous decisions loaded
  - Patterns: 5 patterns available

# Work for 1.5 hours, make architectural decisions

# Monday afternoon: Switch to Cursor for implementation
apm session handoff --to=cursor

✅ Handoff prepared for cursor

Summary:
- Duration: 1h 30m
- Decisions: 2 (JWT tokens, token refresh strategy)
- Files modified: 0 (architecture phase)

Next: Open Cursor and continue work.

# Open Cursor (hook runs automatically)

🖱️ Cursor session started
🔄 Continuing from claude-code
📋 Previous session: 1h 30m, 2 decisions

Context loaded (same context as Claude Code):
  - All decisions from Claude Code session
  - JWT token architecture
  - Implementation patterns to follow

# Code for 1.5 hours in Cursor

# Tuesday morning: Switch to Aider for commit
apm session handoff --to=aider

# Open Aider
$ aider

📝 Aider session started
🔄 Continuing from cursor
📋 Previous session: 1h 30m, 3 files modified

# Commit with full context
$ /commit

Aider suggests commit message based on context:
"feat: Add JWT authentication middleware

- Implement JWT token generation and verification
- Add token refresh endpoint
- Configure token expiry (15min access, 7 days refresh)

Based on architecture decision from claude-code session.
Implementation follows established ServiceLayer pattern."

✅ Committed with full context
```

### Example 2: Cross-Provider Timeline

```bash
apm session timeline --work-item=5

┌─────────────────────────────────────────────────────┐
│ Work Item #5: Multi-Tenant Authentication           │
│ Timeline: Oct 11-12, 2025                          │
└─────────────────────────────────────────────────────┘

Oct 11, 9:00 AM  ┌─ [Claude Code] Session start
                 │
Oct 11, 9:15 AM  ├─ 💡 Decision: Use JWT tokens
                 │   Confidence: 0.87
                 │   Evidence: 4 sources
                 │
Oct 11, 9:45 AM  ├─ 💡 Decision: Token refresh strategy
                 │   Confidence: 0.82
                 │
Oct 11, 10:30 AM └─ Session end (1h 30m, 2 decisions)

Oct 11, 2:00 PM  ┌─ [Cursor] Session start
                 │  🔄 Handoff from Claude Code
                 │
Oct 11, 2:15 PM  ├─ 💻 Code: models/jwt_token.py
                 │
Oct 11, 2:45 PM  ├─ 💻 Code: auth/jwt_middleware.py
                 │
Oct 11, 3:15 PM  ├─ 💻 Code: auth/services/jwt_service.py
                 │
Oct 11, 3:30 PM  └─ Session end (1h 30m, 3 files)

Oct 12, 9:00 AM  ┌─ [Aider] Session start
                 │  🔄 Handoff from Cursor
                 │
Oct 12, 9:30 AM  ├─ 📝 Commit: "feat: Add JWT authentication"
                 │   Files: 3 modified, +420 lines
                 │
Oct 12, 10:00 AM └─ Session end (1h)

Total: 3 sessions, 3 providers, 4 hours work
Decisions: 2 | Files modified: 3 | Commits: 1
```

---

## Related Documents

- **AIPM-V2-COMPLETE-SPECIFICATION.md**: Overall system
- **ADR-001**: Provider Abstraction Architecture
- **ADR-002**: Context Compression Strategy
- **ADR-003**: Sub-Agent Communication Protocol
- **ADR-004**: Evidence Storage and Retrieval

---

## Decision Log

| Date | Decision | Rationale |
|------|----------|-----------|
| 2025-10-12 | Provider-agnostic session store | Not tied to any single provider |
| 2025-10-12 | Unified timeline across providers | Single source of truth |
| 2025-10-12 | Explicit handoff command | Clear intent, no accidental switches |
| 2025-10-12 | Provider-specific hooks | Leverage each provider's strengths |
| 2025-10-12 | Automatic context loading | Zero configuration for users |

---

**Status:** Proposed (awaiting review)
**Next Steps:**
1. Review with AIPM core team
2. Prototype session management with Claude Code
3. Test handoff to Cursor
4. Approve and begin implementation

**Owner:** AIPM Core Team
**Reviewers:** TBD
**Last Updated:** 2025-10-12
