"""
Integration tests for Cursor provider system.

Tests complete workflows across all layers:
- Full installation cycle
- Provider verification
- Memory sync workflow
- Uninstall cleanup
- Configuration customization

Coverage target: 90%
"""

import pytest
from pathlib import Path
import hashlib

from agentpm.providers.cursor.provider import CursorProvider
from agentpm.core.database.models.provider import (
    ProviderType,
    InstallationStatus,
)
from agentpm.core.database.models import Project, WorkItem
from agentpm.core.database.methods import projects as project_methods
from agentpm.core.database.methods import work_items as wi_methods
from agentpm.core.database.enums import WorkItemType, WorkItemStatus


class TestFullInstallationCycle:
    """Test complete installation lifecycle."""

    def test_full_installation_cycle(self, db_service, project, temp_project_dir):
        """
        GIVEN new project
        WHEN running complete installation cycle
        THEN all components are installed correctly
        """
        # Arrange
        provider = CursorProvider(db_service)
        cursor_dir = temp_project_dir / ".cursor"

        # Act - Install
        install_result = provider.install(
            temp_project_dir,
            config={
                "tech_stack": ["Python", "SQLite"],
                "rules_enabled": True,
                "memory_sync_enabled": True,
                "modes_enabled": True,
                "indexing_enabled": True,
            },
        )

        # Assert - Installation succeeded
        assert install_result.success is True
        assert install_result.installation_id is not None
        assert len(install_result.installed_files) > 0
        assert len(install_result.errors) == 0

        # Assert - Directory structure created
        assert cursor_dir.exists()
        assert (cursor_dir / "rules").exists()
        assert (cursor_dir / "memories").exists()
        assert (cursor_dir / "modes").exists()

        # Assert - Files installed
        assert (cursor_dir / ".cursorignore").exists()
        rule_files = list((cursor_dir / "rules").glob("*.mdc"))
        assert len(rule_files) > 0

        # Assert - Database records created
        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM provider_installations WHERE id = ?",
                (install_result.installation_id,),
            )
            install_row = cursor.fetchone()
        assert install_row is not None
        assert install_row["project_id"] == project.id
        assert install_row["provider_type"] == "cursor"
        assert install_row["status"] == "installed"

        # Assert - File records created
        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM provider_files WHERE installation_id = ?",
                (install_result.installation_id,),
            )
            file_rows = cursor.fetchall()
        assert len(file_rows) == len(install_result.installed_files)

        # Assert - Verify works
        verify_result = provider.verify(temp_project_dir)
        assert verify_result.success is True
        assert verify_result.verified_files == len(install_result.installed_files)

        # Assert - Status reflects installation
        status = provider.get_status(temp_project_dir)
        assert status["status"] == "installed"
        assert status["installed_files"] == len(install_result.installed_files)


class TestProviderVerification:
    """Test provider verification workflows."""

    def test_provider_verification_detects_issues(
        self, db_service, project, temp_project_dir
    ):
        """
        GIVEN installed provider
        WHEN files are modified/deleted
        THEN verification detects all issues
        """
        # Arrange
        provider = CursorProvider(db_service)
        provider.install(temp_project_dir)
        cursor_dir = temp_project_dir / ".cursor"

        # Act - Modify a file
        cursorignore = cursor_dir / ".cursorignore"
        original_content = cursorignore.read_text()
        cursorignore.write_text("# Modified content\n")

        # Delete a file
        rule_files = list((cursor_dir / "rules").glob("*.mdc"))
        if rule_files:
            deleted_file = rule_files[0]
            deleted_file_name = deleted_file.name
            deleted_file.unlink()

        # Act - Verify
        verify_result = provider.verify(temp_project_dir)

        # Assert
        assert verify_result.success is False
        assert len(verify_result.modified_files) > 0
        assert ".cursorignore" in verify_result.modified_files
        assert len(verify_result.missing_files) > 0
        assert any(deleted_file_name in f for f in verify_result.missing_files)

    def test_verification_updates_timestamp(
        self, db_service, project, temp_project_dir
    ):
        """
        GIVEN installed provider
        WHEN verification runs
        THEN last_verified_at timestamp is updated
        """
        # Arrange
        provider = CursorProvider(db_service)
        install_result = provider.install(temp_project_dir)

        # Get initial status
        status_before = provider.get_status(temp_project_dir)
        initial_verified_at = status_before.get("last_verified_at")

        # Act - Verify
        verify_result = provider.verify(temp_project_dir)

        # Get status after verification
        status_after = provider.get_status(temp_project_dir)
        updated_verified_at = status_after.get("last_verified_at")

        # Assert
        assert verify_result.success is True
        assert updated_verified_at is not None
        # Timestamp should be updated (or set if was None)
        assert updated_verified_at != initial_verified_at or initial_verified_at is None


class TestMemorySyncWorkflow:
    """Test memory sync workflows."""

    def test_memory_sync_workflow(
        self, db_service, project, temp_project_dir, mock_database_with_learnings
    ):
        """
        GIVEN installed provider and learnings
        WHEN running memory sync
        THEN learnings are synced to Cursor memories
        """
        # Arrange
        provider = CursorProvider(db_service)
        provider.install(temp_project_dir)
        memories_dir = temp_project_dir / ".cursor" / "memories"

        # Verify learnings exist
        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM learnings WHERE project_id = ?",
                (project.id,),
            )
            learnings = cursor.fetchall()
        assert len(learnings) == 3

        # Act - Sync memories
        sync_result = provider.sync_memories(temp_project_dir, direction="to_cursor")

        # Assert - Sync succeeded
        assert sync_result.success is True
        assert sync_result.synced_to_cursor == 3
        assert sync_result.synced_from_cursor == 0
        assert len(sync_result.errors) == 0

        # Assert - Memory files created
        memory_files = list(memories_dir.glob("*.md"))
        assert len(memory_files) == 3

        # Assert - Database records created
        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM cursor_memories WHERE project_id = ?",
                (project.id,),
            )
            memory_rows = cursor.fetchall()
        assert len(memory_rows) == 3

        # Assert - Each memory has correct metadata
        for memory_row in memory_rows:
            assert memory_row["project_id"] == project.id
            assert memory_row["source_learning_id"] is not None
            assert memory_row["file_hash"] is not None
            assert memory_row["last_synced_at"] is not None

            # Verify file exists and hash matches
            memory_file = memories_dir / memory_row["file_path"]
            assert memory_file.exists()

            actual_hash = hashlib.sha256(
                memory_file.read_text().encode()
            ).hexdigest()
            assert actual_hash == memory_row["file_hash"]

    def test_memory_sync_idempotent(
        self, db_service, project, temp_project_dir, mock_database_with_learnings
    ):
        """
        GIVEN learnings already synced
        WHEN running memory sync again
        THEN already synced learnings are skipped
        """
        # Arrange
        provider = CursorProvider(db_service)
        provider.install(temp_project_dir)

        # Act - First sync
        sync_result_1 = provider.sync_memories(temp_project_dir)
        assert sync_result_1.synced_to_cursor == 3

        # Act - Second sync (should skip already synced)
        sync_result_2 = provider.sync_memories(temp_project_dir)

        # Assert
        assert sync_result_2.success is True
        assert sync_result_2.synced_to_cursor == 0  # All already synced
        assert sync_result_2.skipped == 0  # No new learnings to skip


class TestUninstallCleanup:
    """Test uninstall cleanup workflows."""

    def test_uninstall_cleanup(self, db_service, project, temp_project_dir):
        """
        GIVEN fully installed and configured provider
        WHEN uninstalling
        THEN all resources are cleaned up
        """
        # Arrange
        provider = CursorProvider(db_service)
        install_result = provider.install(
            temp_project_dir,
            config={
                "rules_enabled": True,
                "memory_sync_enabled": True,
                "indexing_enabled": True,
            },
        )
        installation_id = install_result.installation_id

        # Verify installation exists
        cursor_dir = temp_project_dir / ".cursor"
        assert cursor_dir.exists()
        assert len(list(cursor_dir.rglob("*"))) > 0

        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM provider_installations WHERE id = ?",
                (installation_id,),
            )
            install_row = cursor.fetchone()
        assert install_row is not None

        # Act - Uninstall
        uninstall_success = provider.uninstall(temp_project_dir)

        # Assert - Uninstall succeeded
        assert uninstall_success is True

        # Assert - Files removed
        assert not cursor_dir.exists()

        # Assert - Database records removed
        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM provider_installations WHERE id = ?",
                (installation_id,),
            )
            install_row = cursor.fetchone()
        assert install_row is None

        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM provider_files WHERE installation_id = ?",
                (installation_id,),
            )
            file_rows = cursor.fetchall()
        assert len(file_rows) == 0

        # Assert - Status reflects uninstallation
        status = provider.get_status(temp_project_dir)
        assert status["status"] == "not_installed"

    def test_uninstall_with_memories(
        self, db_service, project, temp_project_dir, mock_database_with_learnings
    ):
        """
        GIVEN installed provider with synced memories
        WHEN uninstalling
        THEN memory records are cleaned up
        """
        # Arrange
        provider = CursorProvider(db_service)
        install_result = provider.install(temp_project_dir)
        sync_result = provider.sync_memories(temp_project_dir)
        assert sync_result.synced_to_cursor > 0

        # Verify memories exist
        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM cursor_memories WHERE project_id = ?",
                (project.id,),
            )
            memory_rows = cursor.fetchall()
        assert len(memory_rows) > 0

        # Act - Uninstall
        uninstall_success = provider.uninstall(temp_project_dir)

        # Assert
        assert uninstall_success is True

        # Note: cursor_memories table doesn't have CASCADE on provider_installations,
        # so memories might persist. This tests actual behavior.
        # If we want cascade, we'd need to update the migration.


class TestConfigurationCustomization:
    """Test configuration customization workflows."""

    def test_minimal_installation(self, db_service, project, temp_project_dir):
        """
        GIVEN minimal configuration
        WHEN installing
        THEN only essential components are installed
        """
        # Arrange
        provider = CursorProvider(db_service)
        config = {
            "rules_enabled": True,
            "memory_sync_enabled": False,
            "modes_enabled": False,
            "indexing_enabled": False,
            "guardrails_enabled": False,
        }

        # Act
        install_result = provider.install(temp_project_dir, config=config)

        # Assert
        assert install_result.success is True

        cursor_dir = temp_project_dir / ".cursor"
        assert cursor_dir.exists()
        assert (cursor_dir / "rules").exists()

        # Modes dir should not be created
        assert not (cursor_dir / "modes").exists()

        # .cursorignore should not be created
        assert not (cursor_dir / ".cursorignore").exists()

    def test_custom_tech_stack(self, db_service, project, temp_project_dir):
        """
        GIVEN custom tech_stack configuration
        WHEN installing
        THEN configuration is saved
        """
        # Arrange
        provider = CursorProvider(db_service)
        config = {
            "tech_stack": ["Python", "PostgreSQL", "React"],
        }

        # Act
        install_result = provider.install(temp_project_dir, config=config)

        # Assert
        assert install_result.success is True

        # Verify config was saved
        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM provider_installations WHERE id = ?",
                (install_result.installation_id,),
            )
            install_row = cursor.fetchone()
        import json

        saved_config = json.loads(install_row["config"])
        assert saved_config["tech_stack"] == ["Python", "PostgreSQL", "React"]

    def test_custom_exclude_patterns(self, db_service, project, temp_project_dir):
        """
        GIVEN custom exclude_patterns
        WHEN installing with indexing_enabled
        THEN custom patterns are in .cursorignore
        """
        # Arrange
        provider = CursorProvider(db_service)
        config = {
            "indexing_enabled": True,
            "exclude_patterns": [
                ".git/",
                "node_modules/",
                "custom_dir/",
                "*.log",
            ],
        }

        # Act
        install_result = provider.install(temp_project_dir, config=config)

        # Assert
        assert install_result.success is True

        cursorignore = temp_project_dir / ".cursor" / ".cursorignore"
        assert cursorignore.exists()

        content = cursorignore.read_text()
        assert ".git/" in content
        assert "node_modules/" in content
        assert "custom_dir/" in content
        assert "*.log" in content


class TestErrorHandling:
    """Test error handling in integration scenarios."""

    def test_install_project_not_found_error(self, db_service, temp_project_dir):
        """
        GIVEN project not in database
        WHEN attempting installation
        THEN clear error is returned
        """
        # Arrange
        provider = CursorProvider(db_service)
        unknown_path = temp_project_dir / "unknown"
        unknown_path.mkdir()

        # Act
        install_result = provider.install(unknown_path)

        # Assert
        assert install_result.success is False
        assert "not found" in install_result.message.lower()
        assert len(install_result.errors) > 0

    def test_verify_before_install_error(self, db_service, project, temp_project_dir):
        """
        GIVEN project without provider installed
        WHEN attempting verification
        THEN clear error is returned
        """
        # Arrange
        provider = CursorProvider(db_service)

        # Act
        verify_result = provider.verify(temp_project_dir)

        # Assert
        assert verify_result.success is False
        assert "not installed" in verify_result.message.lower()

    def test_sync_before_install_error(self, db_service, project, temp_project_dir):
        """
        GIVEN project without provider installed
        WHEN attempting memory sync
        THEN clear error is returned
        """
        # Arrange
        provider = CursorProvider(db_service)

        # Act
        sync_result = provider.sync_memories(temp_project_dir)

        # Assert
        assert sync_result.success is False
        assert "not installed" in sync_result.message.lower()


class TestConcurrentOperations:
    """Test behavior with concurrent/multiple operations."""

    def test_multiple_verifications(self, db_service, project, temp_project_dir):
        """
        GIVEN installed provider
        WHEN running verify multiple times
        THEN all succeed and timestamps update
        """
        # Arrange
        provider = CursorProvider(db_service)
        provider.install(temp_project_dir)

        # Act - Multiple verifications
        results = []
        for _ in range(3):
            result = provider.verify(temp_project_dir)
            results.append(result)

        # Assert
        for result in results:
            assert result.success is True
            assert result.verified_files > 0

    def test_multiple_syncs(
        self, db_service, project, temp_project_dir, mock_database_with_learnings
    ):
        """
        GIVEN installed provider with learnings
        WHEN running sync multiple times
        THEN first sync succeeds, subsequent skips already synced
        """
        # Arrange
        provider = CursorProvider(db_service)
        provider.install(temp_project_dir)

        # Act - Multiple syncs
        result1 = provider.sync_memories(temp_project_dir)
        result2 = provider.sync_memories(temp_project_dir)
        result3 = provider.sync_memories(temp_project_dir)

        # Assert
        assert result1.success is True
        assert result1.synced_to_cursor > 0

        assert result2.success is True
        assert result2.synced_to_cursor == 0  # Already synced

        assert result3.success is True
        assert result3.synced_to_cursor == 0  # Still already synced


class TestRealWorldScenarios:
    """Test real-world usage scenarios."""

    def test_new_project_setup(self, db_service, temp_project_dir):
        """
        GIVEN brand new APM project
        WHEN setting up Cursor provider
        THEN complete workflow succeeds
        """
        # Arrange - Create project
        proj = Project(
            name="New Project",
            description="Test new project setup",
            root_path=str(temp_project_dir),
        )
        project = project_methods.create_project(db_service, proj)

        provider = CursorProvider(db_service)

        # Act - Install provider
        install_result = provider.install(
            temp_project_dir,
            config={
                "tech_stack": ["Python"],
                "rules_enabled": True,
            },
        )

        # Act - Verify installation
        verify_result = provider.verify(temp_project_dir)

        # Act - Check status
        status = provider.get_status(temp_project_dir)

        # Assert
        assert install_result.success is True
        assert verify_result.success is True
        assert status["status"] == "installed"

    def test_existing_project_migration(self, db_service, project, temp_project_dir):
        """
        GIVEN existing project with work items
        WHEN installing Cursor provider
        THEN installation succeeds without affecting existing data
        """
        # Arrange - Create work items
        wi1 = WorkItem(
            project_id=project.id,
            title="Feature 1",
            description="Test feature",
            work_item_type=WorkItemType.FEATURE,
            status=WorkItemStatus.PROPOSED,
        )
        work_item_1 = wi_methods.create_work_item(db_service, wi1)

        provider = CursorProvider(db_service)

        # Act - Install provider
        install_result = provider.install(temp_project_dir)

        # Assert - Installation succeeded
        assert install_result.success is True

        # Assert - Work items unchanged
        with db_service.connect() as conn:
            conn.row_factory = lambda cursor, row: dict(
                zip([col[0] for col in cursor.description], row)
            )
            cursor = conn.execute(
                "SELECT * FROM work_items WHERE id = ?",
                (work_item_1.id,),
            )
            wi_check = cursor.fetchone()
        assert wi_check is not None
        assert wi_check["title"] == "Feature 1"
