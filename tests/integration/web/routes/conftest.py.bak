"""
Fixtures for web routes integration tests.

Provides Flask test client and database fixtures for testing the refactored
web routes structure.
"""

import pytest
from pathlib import Path
import os
import sys

from agentpm.core.database.service import DatabaseService
from agentpm.core.database.methods import (
    projects,
    work_items as work_items_methods,
    tasks as tasks_methods,
    rules as rules_methods,
    agents as agent_methods,
)
from agentpm.core.database.models import (
    Project,
    WorkItem,
    Task,
    Rule,
    Agent,
)
from agentpm.core.database.enums import (
    WorkItemStatus,
    WorkItemType,
    TaskStatus,
    EnforcementLevel,
    AgentTier,
)


@pytest.fixture
def test_db_path(tmp_path):
    """Create temporary database path."""
    db_path = tmp_path / ".agentpm" / "data" / "test.db"
    db_path.parent.mkdir(parents=True, exist_ok=True)
    return str(db_path)


@pytest.fixture
def test_db_service(test_db_path):
    """
    Create a test database service with clean schema.

    Returns:
        DatabaseService: Initialized database service for testing
    """
    service = DatabaseService(test_db_path)
    yield service
    # Cleanup handled by tmp_path


@pytest.fixture
def test_project(test_db_service):
    """
    Create a test project in the database.

    Returns:
        Project: Created test project
    """
    project = Project(
        name="Test Project",
        description="Test project for web routes testing",
        path="/tmp/test-project",
        tech_stack=["Python", "Flask", "SQLite"],
        status="active",
        business_domain="Testing"
    )
    return projects.create_project(test_db_service, project)


@pytest.fixture
def test_rules(test_db_service, test_project):
    """
    Create test rules in the database.

    Returns:
        List[Rule]: Created test rules
    """
    test_rules_data = [
        Rule(
            project_id=test_project.id,
            rule_id='DP-001',
            name='time-boxing',
            description='All work must be time-boxed',
            category='Development Principles',
            enforcement_level=EnforcementLevel.BLOCK,
            error_message='Work must be time-boxed',
            config={"max_hours": 4},
            enabled=True
        ),
        Rule(
            project_id=test_project.id,
            rule_id='TES-001',
            name='test-coverage',
            description='Minimum 90% test coverage',
            category='Testing Standards',
            enforcement_level=EnforcementLevel.LIMIT,
            error_message='Coverage below 90%',
            config={"threshold": 0.90},
            enabled=True
        ),
        Rule(
            project_id=test_project.id,
            rule_id='SEC-001',
            name='input-validation',
            description='All inputs must be validated',
            category='Security',
            enforcement_level=EnforcementLevel.BLOCK,
            error_message='Input validation required',
            config={},
            enabled=True
        ),
    ]
    created_rules = []
    for rule in test_rules_data:
        created_rules.append(rules_methods.create_rule(test_db_service, rule))
    return created_rules


@pytest.fixture
def test_agents(test_db_service, test_project):
    """
    Create test agents in the database.

    Returns:
        List[Agent]: Created test agents
    """
    test_agents_data = [
        Agent(
            project_id=test_project.id,
            role='testing-specialist',
            display_name='Testing Specialist',
            description='Specialist for testing tasks',
            sop_content='SOP for testing specialist',
            capabilities=["test", "validate", "quality-check"],
            is_active=True,
            agent_type='specialist',
            tier=AgentTier.TIER_1
        ),
        Agent(
            project_id=test_project.id,
            role='implementation-agent',
            display_name='Implementation Agent',
            description='Agent for implementation tasks',
            sop_content='SOP for implementation agent',
            capabilities=["code", "implement", "refactor"],
            is_active=True,
            agent_type='specialist',
            tier=AgentTier.TIER_2
        ),
    ]
    created_agents = []
    for agent in test_agents_data:
        created_agents.append(agent_methods.create_agent(test_db_service, agent))
    return created_agents


@pytest.fixture
def test_work_items(test_db_service, test_project):
    """
    Create test work items in the database.

    Returns:
        List[WorkItem]: Created test work items
    """
    test_work_items_data = [
        WorkItem(
            project_id=test_project.id,
            name='Test Feature Implementation',
            description='Implement test feature for testing',
            type=WorkItemType.FEATURE,
            status=WorkItemStatus.ACTIVE,
            phase='I1_implementation',
            effort_estimate_hours=8.0,
            priority=1,
            business_context='Testing feature for web routes'
        ),
        WorkItem(
            project_id=test_project.id,
            name='Fix Test Bug',
            description='Fix bug in test code',
            type=WorkItemType.FIX,
            status=WorkItemStatus.DONE,
            phase='R1_review',
            effort_estimate_hours=2.0,
            priority=2
        ),
    ]
    created_work_items = []
    for wi in test_work_items_data:
        created_work_items.append(work_items_methods.create_work_item(test_db_service, wi))
    return created_work_items


@pytest.fixture
def test_tasks(test_db_service, test_work_items):
    """
    Create test tasks in the database.

    Returns:
        List[Task]: Created test tasks
    """
    test_tasks_data = [
        Task(
            work_item_id=test_work_items[0].id,
            name='Implement Feature',
            description='Implementation task',
            type='implementation',
            status=TaskStatus.IN_PROGRESS,
            assigned_to='test-agent',
            effort_hours=4.0,
            priority=1
        ),
        Task(
            work_item_id=test_work_items[0].id,
            name='Write Tests',
            description='Testing task',
            type='testing',
            status=TaskStatus.TODO,
            assigned_to='test-agent',
            effort_hours=2.0,
            priority=2
        ),
    ]
    created_tasks = []
    for task in test_tasks_data:
        created_tasks.append(tasks_methods.create_task(test_db_service, task))
    return created_tasks


@pytest.fixture
def app(test_db_service, test_db_path, monkeypatch):
    """
    Create Flask app configured for testing.

    Args:
        test_db_service: Test database service
        test_db_path: Path to test database
        monkeypatch: Pytest monkeypatch fixture

    Returns:
        Flask app configured for testing
    """
    # Set environment variable for database path BEFORE importing app
    monkeypatch.setenv('AIPM_DB_PATH', test_db_path)

    # Import app module (this will create the Flask app with test DB)
    # We need to import AFTER setting env var so database detection works
    import importlib

    # Remove app module if already imported to force reload with new env var
    if 'agentpm.web.app' in sys.modules:
        del sys.modules['agentpm.web.app']
    # Also remove all web submodules
    modules_to_remove = [key for key in sys.modules if key.startswith('agentpm.web')]
    for module in modules_to_remove:
        del sys.modules[module]

    # Now import the app with test database path set
    from agentpm.web import app as app_module
    importlib.reload(app_module)

    flask_app = app_module.app
    flask_app.config['TESTING'] = True
    flask_app.config['WTF_CSRF_ENABLED'] = False  # Disable CSRF for testing

    yield flask_app


@pytest.fixture
def client(app):
    """
    Create Flask test client.

    Args:
        app: Flask app fixture

    Returns:
        Flask test client
    """
    return app.test_client()
