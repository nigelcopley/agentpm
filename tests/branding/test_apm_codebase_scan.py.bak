"""
Codebase scanning tests for APM branding validation.

Scans source files for:
- User-facing AIPM references that should be APM
- Configuration file branding
- Help text and docstring consistency
- Error messages and status output

These are more thorough than unit tests - they scan actual file contents.
"""

import pytest
from pathlib import Path
import re


class TestCodebaseBrandingScan:
    """Scan codebase for branding inconsistencies."""

    @pytest.fixture
    def project_root(self):
        """Get project root directory."""
        return Path(__file__).parent.parent.parent

    @pytest.fixture
    def cli_dir(self, project_root):
        """Get CLI directory."""
        return project_root / 'agentpm' / 'cli'

    def test_cli_main_uses_apm_prog_name(self, cli_dir):
        """Verify CLI main.py uses 'apm' as program name."""
        main_file = cli_dir / 'main.py'

        assert main_file.exists(), "main.py not found"

        content = main_file.read_text()

        # Should have @click.version_option with prog_name='apm'
        assert "prog_name='apm'" in content, "CLI should use prog_name='apm'"

    def test_status_dashboard_title(self, cli_dir):
        """Verify status dashboard uses appropriate title."""
        status_file = cli_dir / 'commands' / 'status.py'

        if not status_file.exists():
            pytest.skip("status.py not found")

        content = status_file.read_text()

        # Check dashboard title
        # Currently shows "ðŸ¤– APM (Agent Project Manager) Project Dashboard"
        # Should eventually be "ðŸ¤– APM Project Dashboard"

        if 'title=' in content and 'Dashboard' in content:
            # Found dashboard title - track it
            dashboard_match = re.search(r'title=["\']([^"\']+)["\']', content)
            if dashboard_match:
                title = dashboard_match.group(1)
                print(f"Dashboard title: {title}")

                # Don't fail, just track
                if 'APM (Agent Project Manager)' in title:
                    print("INFO: Dashboard still uses 'APM (Agent Project Manager)' - should migrate to 'APM'")

    def test_init_command_references(self, cli_dir):
        """Verify init command uses appropriate branding."""
        init_file = cli_dir / 'commands' / 'init.py'

        if not init_file.exists():
            pytest.skip("init.py not found")

        content = init_file.read_text()

        # Check for help text
        if '@click.command' in content:
            # Command exists
            assert 'def init' in content or 'Initialize' in content

    def test_search_command_descriptions(self, cli_dir):
        """Check search command descriptions for legacy references."""
        search_file = cli_dir / 'commands' / 'search.py'

        if not search_file.exists():
            pytest.skip("search.py not found")

        content = search_file.read_text()

        # Currently shows "Unified vector search across all APM (Agent Project Manager) entities"
        # Track but don't fail
        if 'APM (Agent Project Manager) entities' in content:
            print("INFO: Search command references 'APM (Agent Project Manager) entities' - consider 'APM entities'")

    def test_help_text_in_command_files(self, cli_dir):
        """Scan all command files for help text branding."""
        if not cli_dir.exists():
            pytest.skip("CLI directory not found")

        command_files = list((cli_dir / 'commands').rglob('*.py'))

        findings = {
            'agentpm_references': [],
            'aipm_project_references': [],
            'apm_references': [],
        }

        for cmd_file in command_files:
            try:
                content = cmd_file.read_text()

                # Count references
                if 'APM (Agent Project Manager)' in content:
                    findings['agentpm_references'].append(str(cmd_file.name))
                if 'APM project' in content:
                    findings['aipm_project_references'].append(str(cmd_file.name))
                if 'APM' in content and 'AIPM' not in content:
                    findings['apm_references'].append(str(cmd_file.name))

            except Exception:
                continue

        # Report findings
        print(f"\nBranding scan results:")
        print(f"  Files with 'APM (Agent Project Manager)': {len(findings['agentpm_references'])}")
        print(f"  Files with 'APM project': {len(findings['aipm_project_references'])}")
        print(f"  Files with 'APM' (pure): {len(findings['apm_references'])}")

        # Don't fail - this is informational during transition


class TestUserFacingStrings:
    """Test user-facing strings for branding."""

    @pytest.fixture
    def project_root(self):
        """Get project root directory."""
        return Path(__file__).parent.parent.parent

    def test_click_echo_statements(self, project_root):
        """Scan for click.echo statements with AIPM references."""
        cli_dir = project_root / 'agentpm' / 'cli'

        if not cli_dir.exists():
            pytest.skip("CLI directory not found")

        files_with_echo = []

        for py_file in cli_dir.rglob('*.py'):
            try:
                content = py_file.read_text()
                lines = content.split('\n')

                for line_num, line in enumerate(lines, 1):
                    if 'click.echo' in line and 'AIPM' in line:
                        files_with_echo.append({
                            'file': str(py_file.relative_to(project_root)),
                            'line': line_num,
                            'content': line.strip()[:80]
                        })
            except Exception:
                continue

        if files_with_echo:
            print(f"\nFound {len(files_with_echo)} click.echo with AIPM:")
            for item in files_with_echo[:5]:
                print(f"  {item['file']}:{item['line']}")

    def test_console_print_statements(self, project_root):
        """Scan for console.print statements with AIPM references."""
        cli_dir = project_root / 'agentpm' / 'cli'

        if not cli_dir.exists():
            pytest.skip("CLI directory not found")

        files_with_print = []

        for py_file in cli_dir.rglob('*.py'):
            try:
                content = py_file.read_text()
                lines = content.split('\n')

                for line_num, line in enumerate(lines, 1):
                    if 'console.print' in line and 'AIPM' in line:
                        files_with_print.append({
                            'file': str(py_file.relative_to(project_root)),
                            'line': line_num,
                            'content': line.strip()[:80]
                        })
            except Exception:
                continue

        if files_with_print:
            print(f"\nFound {len(files_with_print)} console.print with AIPM:")
            for item in files_with_print[:5]:
                print(f"  {item['file']}:{item['line']}")

    def test_help_strings_in_decorators(self, project_root):
        """Scan for @click.option help strings with AIPM."""
        cli_dir = project_root / 'agentpm' / 'cli'

        if not cli_dir.exists():
            pytest.skip("CLI directory not found")

        help_strings = []

        for py_file in cli_dir.rglob('*.py'):
            try:
                content = py_file.read_text()

                # Find help= parameters
                help_matches = re.finditer(r"help=['\"]([^'\"]+)['\"]", content)
                for match in help_matches:
                    help_text = match.group(1)
                    if 'AIPM' in help_text:
                        help_strings.append({
                            'file': str(py_file.relative_to(project_root)),
                            'help': help_text[:60]
                        })
            except Exception:
                continue

        if help_strings:
            print(f"\nFound {len(help_strings)} help strings with AIPM:")
            for item in help_strings[:5]:
                print(f"  {item['file']}: {item['help']}")


class TestDocstringBranding:
    """Test docstrings for branding consistency."""

    @pytest.fixture
    def project_root(self):
        """Get project root directory."""
        return Path(__file__).parent.parent.parent

    def test_module_docstrings(self, project_root):
        """Check module-level docstrings in CLI commands."""
        cli_dir = project_root / 'agentpm' / 'cli'

        if not cli_dir.exists():
            pytest.skip("CLI directory not found")

        modules_checked = 0
        modules_with_agentpm = 0

        for py_file in cli_dir.rglob('*.py'):
            try:
                content = py_file.read_text()

                # Extract module docstring (first """...""" block)
                docstring_match = re.search(r'^["\']{{3}}(.+?)["\']{{3}}', content, re.DOTALL | re.MULTILINE)
                if docstring_match:
                    modules_checked += 1
                    docstring = docstring_match.group(1)

                    if 'APM (Agent Project Manager)' in docstring:
                        modules_with_agentpm += 1

            except Exception:
                continue

        print(f"\nModule docstring scan:")
        print(f"  Modules checked: {modules_checked}")
        print(f"  Modules with 'APM (Agent Project Manager)': {modules_with_agentpm}")

        # Informational - don't fail

    def test_function_docstrings(self, project_root):
        """Check function docstrings in CLI commands."""
        cli_dir = project_root / 'agentpm' / 'cli' / 'commands'

        if not cli_dir.exists():
            pytest.skip("CLI commands directory not found")

        functions_checked = 0
        functions_with_aipm = 0

        for py_file in cli_dir.rglob('*.py'):
            try:
                content = py_file.read_text()

                # Find all function docstrings
                func_pattern = r'def \w+\([^)]*\):\s+["\']{{3}}(.+?)["\']{{3}}'
                matches = re.finditer(func_pattern, content, re.DOTALL)

                for match in matches:
                    functions_checked += 1
                    docstring = match.group(1)

                    if 'AIPM' in docstring:
                        functions_with_aipm += 1

            except Exception:
                continue

        print(f"\nFunction docstring scan:")
        print(f"  Functions checked: {functions_checked}")
        print(f"  Functions with 'AIPM': {functions_with_aipm}")


class TestBrandingMetrics:
    """Generate metrics on branding consistency."""

    @pytest.fixture
    def project_root(self):
        """Get project root directory."""
        return Path(__file__).parent.parent.parent

    def test_generate_branding_report(self, project_root):
        """Generate comprehensive branding report."""
        cli_dir = project_root / 'agentpm' / 'cli'

        if not cli_dir.exists():
            pytest.skip("CLI directory not found")

        metrics = {
            'total_files': 0,
            'files_with_agentpm': 0,
            'files_with_aipm': 0,
            'files_with_apm_only': 0,
            'user_facing_aipm_count': 0,
        }

        for py_file in cli_dir.rglob('*.py'):
            try:
                metrics['total_files'] += 1
                content = py_file.read_text()

                has_agentpm = 'APM (Agent Project Manager)' in content
                has_aipm = 'AIPM' in content
                has_apm = 'APM' in content and not has_aipm

                if has_agentpm:
                    metrics['files_with_agentpm'] += 1
                if has_aipm:
                    metrics['files_with_aipm'] += 1
                if has_apm:
                    metrics['files_with_apm_only'] += 1

                # Count user-facing AIPM references
                user_facing_patterns = [
                    r'click\.echo.*AIPM',
                    r'console\.print.*AIPM',
                    r'help=["\'].*AIPM',
                    r'title=["\'].*AIPM',
                ]

                for pattern in user_facing_patterns:
                    matches = re.findall(pattern, content)
                    metrics['user_facing_aipm_count'] += len(matches)

            except Exception:
                continue

        # Print report
        print("\n" + "=" * 60)
        print("APM BRANDING REPORT")
        print("=" * 60)
        print(f"Total CLI files scanned: {metrics['total_files']}")
        print(f"Files with 'APM (Agent Project Manager)': {metrics['files_with_agentpm']}")
        print(f"Files with 'AIPM': {metrics['files_with_aipm']}")
        print(f"Files with 'APM' only: {metrics['files_with_apm_only']}")
        print(f"User-facing AIPM references: {metrics['user_facing_aipm_count']}")
        print("=" * 60)

        # Calculate branding score (0-100)
        if metrics['total_files'] > 0:
            # Ideal: 0 APM (Agent Project Manager) references in user-facing strings
            # Score based on reduction of user-facing AIPM
            score = max(0, 100 - (metrics['user_facing_aipm_count'] * 10))
            print(f"Branding Consistency Score: {score}/100")
            print("=" * 60)

        # Pass test - this is informational
        assert metrics['total_files'] > 0, "Should have scanned at least one file"


# Pytest markers
pytestmark = [
    pytest.mark.branding,
    pytest.mark.codebase_scan,
]


if __name__ == '__main__':
    pytest.main([__file__, '-v', '--tb=short'])
