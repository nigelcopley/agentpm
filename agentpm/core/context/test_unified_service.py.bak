"""
Tests for UnifiedContextService

Production-quality test suite with:
- Unit tests for each entity type
- Integration tests with production database
- Performance benchmarks (<100ms target)
- Security validation (SQL injection, path traversal)
- Error handling and edge cases

Pattern: pytest with fixtures, parametrization, and mocking
Industry Standards: pytest, pytest-benchmark, pytest-mock

Author: Python Expert
Date: 2025-10-17
"""

import pytest
from pathlib import Path
from datetime import datetime, timedelta
from typing import List

from .unified_service import (
    UnifiedContextService,
    ContextPayload,
    ConfidenceScore,
    CompletenessScore,
    FreshnessScore
)
from ..database.service import DatabaseService
from ..database.enums import EntityType, ConfidenceBand, ProjectStatus, WorkItemStatus, TaskStatus, IdeaStatus
from ..database.models import Project, WorkItem, Task, Idea, Context, UnifiedSixW


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def db_service(tmp_path):
    """Create temporary database for testing."""
    db_path = tmp_path / "test.db"
    db = DatabaseService(str(db_path))
    db.initialize()
    return db


@pytest.fixture
def project_path(tmp_path):
    """Create temporary project directory structure."""
    project_dir = tmp_path / "test_project"
    project_dir.mkdir()

    # Create .agentpm/contexts directory
    contexts_dir = project_dir / ".agentpm" / "contexts"
    contexts_dir.mkdir(parents=True)

    # Create sample amalgamation files
    (contexts_dir / "lang_python_classes.txt").write_text("class Sample: pass")
    (contexts_dir / "lang_python_functions.txt").write_text("def sample(): pass")

    return project_dir


@pytest.fixture
def service(db_service, project_path):
    """Create UnifiedContextService instance."""
    return UnifiedContextService(db_service, project_path)


@pytest.fixture
def sample_project(db_service):
    """Create sample project in database."""
    from ..database.methods import projects

    project = Project(
        name="Test Project",
        path="/tmp/test",
        tech_stack=["python", "pytest"],
        detected_frameworks=["pytest"],
        status=ProjectStatus.ACTIVE
    )

    project_id = projects.create_project(db_service, project)
    project.id = project_id

    return project


@pytest.fixture
def sample_work_item(db_service, sample_project):
    """Create sample work item in database."""
    from ..database.methods import work_items

    work_item = WorkItem(
        project_id=sample_project.id,
        name="Test Feature",
        description="Test feature description",
        business_context="Important feature",
        status=WorkItemStatus.DRAFT,
        effort_estimate_hours=8.0
    )

    work_item_id = work_items.create_work_item(db_service, work_item)
    work_item.id = work_item_id

    return work_item


@pytest.fixture
def sample_task(db_service, sample_work_item):
    """Create sample task in database."""
    from ..database.methods import tasks

    task = Task(
        work_item_id=sample_work_item.id,
        name="Test Task",
        description="Test task description",
        status=TaskStatus.DRAFT,
        effort_hours=4.0,
        assigned_to="test-agent"
    )

    task_id = tasks.create_task(db_service, task)
    task.id = task_id

    return task


@pytest.fixture
def sample_idea(db_service, sample_project):
    """Create sample idea in database."""
    from ..database.methods import ideas

    idea = Idea(
        project_id=sample_project.id,
        title="Test Idea",
        description="Test idea description",
        status=IdeaStatus.IDEA,
        votes=5,
        tags=["feature", "ux"]
    )

    idea_id = ideas.create_idea(db_service, idea)
    idea.id = idea_id

    return idea


@pytest.fixture
def sample_six_w():
    """Create sample UnifiedSixW structure."""
    return UnifiedSixW(
        end_users=["developers", "users"],
        implementers=["python-expert"],
        reviewers=["code-reviewer"],
        functional_requirements=["Must support X", "Must handle Y"],
        technical_constraints=["Python 3.8+", "No external deps"],
        acceptance_criteria=["AC1: Feature works", "AC2: Tests pass"],
        affected_services=["api", "database"],
        repositories=["main-repo"],
        deployment_targets=["production"],
        deadline=datetime.utcnow() + timedelta(days=7),
        dependencies_timeline=["After migration", "Before release"],
        business_value="High impact feature",
        risk_if_delayed="Customer churn",
        suggested_approach="Incremental implementation",
        existing_patterns=["factory pattern", "observer pattern"]
    )


# ============================================================================
# Unit Tests: ContextPayload
# ============================================================================


class TestContextPayload:
    """Test ContextPayload data structure."""

    def test_create_payload_with_project(self, sample_project):
        """Test creating payload with project entity."""
        payload = ContextPayload(
            entity=sample_project,
            entity_type=EntityType.PROJECT
        )

        assert payload.entity == sample_project
        assert payload.entity_type == EntityType.PROJECT
        assert payload.documents == []
        assert payload.evidence == []
        assert payload.amalgamations == {}

    def test_payload_to_dict(self, sample_project, sample_six_w):
        """Test payload serialization to dictionary."""
        confidence = ConfidenceScore(score=0.85, band=ConfidenceBand.GREEN)
        freshness = FreshnessScore.calculate(datetime.utcnow())

        payload = ContextPayload(
            entity=sample_project,
            entity_type=EntityType.PROJECT,
            six_w=sample_six_w,
            confidence=confidence,
            freshness=freshness
        )

        result = payload.to_dict()

        assert result['entity_type'] == 'project'
        assert result['confidence']['score'] == 0.85
        assert result['confidence']['band'] == 'green'
        assert result['six_w']['who']['implementers'] == ['python-expert']
        assert result['freshness']['is_stale'] is False


# ============================================================================
# Unit Tests: Quality Metrics
# ============================================================================


class TestConfidenceScore:
    """Test ConfidenceScore calculation."""

    def test_valid_score(self):
        """Test creating confidence score with valid value."""
        score = ConfidenceScore(score=0.75, band=ConfidenceBand.YELLOW)
        assert score.score == 0.75
        assert score.band == ConfidenceBand.YELLOW

    def test_invalid_score_too_high(self):
        """Test validation rejects score >1.0."""
        with pytest.raises(ValueError, match="must be 0.0-1.0"):
            ConfidenceScore(score=1.5, band=ConfidenceBand.GREEN)

    def test_invalid_score_negative(self):
        """Test validation rejects negative score."""
        with pytest.raises(ValueError, match="must be 0.0-1.0"):
            ConfidenceScore(score=-0.1, band=ConfidenceBand.RED)


class TestCompletenessScore:
    """Test CompletenessScore calculation."""

    def test_sufficient_completeness(self):
        """Test completeness check with >70% and no critical gaps."""
        score = CompletenessScore(
            percentage=85.0,
            missing_fields=['description'],
            critical_gaps=[]
        )
        assert score.is_sufficient() is True

    def test_insufficient_percentage(self):
        """Test completeness check fails with <70%."""
        score = CompletenessScore(
            percentage=65.0,
            missing_fields=['name', 'description', 'business_value'],
            critical_gaps=[]
        )
        assert score.is_sufficient() is False

    def test_critical_gaps_present(self):
        """Test completeness check fails with critical gaps."""
        score = CompletenessScore(
            percentage=75.0,
            missing_fields=['business_value'],
            critical_gaps=['business_value']
        )
        assert score.is_sufficient() is False


class TestFreshnessScore:
    """Test FreshnessScore calculation."""

    def test_fresh_content(self):
        """Test freshness with recent update."""
        recent = datetime.utcnow() - timedelta(hours=6)
        score = FreshnessScore.calculate(recent)

        assert score.age_hours == pytest.approx(6.0, abs=0.1)
        assert score.is_stale is False

    def test_stale_content(self):
        """Test freshness with old update."""
        old = datetime.utcnow() - timedelta(hours=72)
        score = FreshnessScore.calculate(old)

        assert score.age_hours == pytest.approx(72.0, abs=0.1)
        assert score.is_stale is True


# ============================================================================
# Integration Tests: UnifiedContextService
# ============================================================================


class TestUnifiedContextService:
    """Test UnifiedContextService with database."""

    # ========================================================================
    # Input Validation
    # ========================================================================

    def test_invalid_entity_type(self, service, sample_project):
        """Test error handling for invalid entity type."""
        with pytest.raises(TypeError, match="must be EntityType enum"):
            service.get_context("PROJECT", sample_project.id)

    def test_invalid_entity_id_negative(self, service):
        """Test error handling for negative entity ID."""
        with pytest.raises(ValueError, match="must be positive integer"):
            service.get_context(EntityType.PROJECT, -1)

    def test_invalid_entity_id_zero(self, service):
        """Test error handling for zero entity ID."""
        with pytest.raises(ValueError, match="must be positive integer"):
            service.get_context(EntityType.PROJECT, 0)

    def test_nonexistent_entity(self, service):
        """Test error handling for nonexistent entity."""
        with pytest.raises(ValueError, match="not found"):
            service.get_context(EntityType.PROJECT, 99999)

    # ========================================================================
    # Project Context
    # ========================================================================

    def test_get_project_context_basic(self, service, sample_project):
        """Test basic project context retrieval."""
        ctx = service.get_context(
            EntityType.PROJECT,
            sample_project.id,
            include_supporting=False,
            include_code=False
        )

        assert isinstance(ctx, ContextPayload)
        assert ctx.entity_type == EntityType.PROJECT
        assert ctx.entity.id == sample_project.id
        assert ctx.entity.name == "Test Project"
        assert ctx.documents == []
        assert ctx.evidence == []
        assert ctx.amalgamations == {}

    def test_get_project_context_with_code(self, service, sample_project, project_path):
        """Test project context with code amalgamations."""
        ctx = service.get_context(
            EntityType.PROJECT,
            sample_project.id,
            include_supporting=False,
            include_code=True
        )

        assert ctx.amalgamations != {}
        # Should find python amalgamations
        assert any('python' in key for key in ctx.amalgamations.keys())

    def test_get_project_context_with_six_w(self, service, sample_project, sample_six_w):
        """Test project context with UnifiedSixW."""
        from ..database.methods import contexts

        # Create project context
        context = Context(
            project_id=sample_project.id,
            context_type=ContextType.PROJECT_CONTEXT,
            entity_type=EntityType.PROJECT,
            entity_id=sample_project.id,
            six_w=sample_six_w,
            confidence_score=0.85,
            confidence_band=ConfidenceBand.GREEN
        )
        contexts.create_context(service.db, context)

        # Get context
        ctx = service.get_context(EntityType.PROJECT, sample_project.id)

        assert ctx.six_w is not None
        assert ctx.six_w.implementers == ['python-expert']
        assert ctx.confidence is not None
        assert ctx.confidence.score == 0.85

    # ========================================================================
    # Work Item Context
    # ========================================================================

    def test_get_work_item_context_basic(self, service, sample_work_item):
        """Test basic work item context retrieval."""
        ctx = service.get_context(
            EntityType.WORK_ITEM,
            sample_work_item.id,
            include_supporting=False,
            include_code=False
        )

        assert isinstance(ctx, ContextPayload)
        assert ctx.entity_type == EntityType.WORK_ITEM
        assert ctx.entity.id == sample_work_item.id
        assert ctx.entity.name == "Test Feature"

    def test_get_work_item_context_with_inheritance(self, service, sample_project, sample_work_item, sample_six_w):
        """Test work item context inherits project context."""
        from ..database.methods import contexts

        # Create project context
        project_context = Context(
            project_id=sample_project.id,
            context_type=ContextType.PROJECT_CONTEXT,
            entity_type=EntityType.PROJECT,
            entity_id=sample_project.id,
            six_w=sample_six_w
        )
        contexts.create_context(service.db, project_context)

        # Get work item context
        ctx = service.get_context(EntityType.WORK_ITEM, sample_work_item.id)

        # Should have parent and project 6W
        assert ctx.parent_six_w is not None
        assert ctx.project_six_w is not None
        assert ctx.parent_six_w == ctx.project_six_w  # Same for work item

    def test_get_work_item_context_with_completeness(self, service, sample_work_item):
        """Test work item context includes completeness score."""
        ctx = service.get_context(EntityType.WORK_ITEM, sample_work_item.id)

        assert ctx.completeness is not None
        assert 0 <= ctx.completeness.percentage <= 100
        # Should have missing fields (no 6W context)
        assert len(ctx.completeness.missing_fields) > 0

    # ========================================================================
    # Task Context
    # ========================================================================

    def test_get_task_context_basic(self, service, sample_task):
        """Test basic task context retrieval."""
        ctx = service.get_context(
            EntityType.TASK,
            sample_task.id,
            include_supporting=False,
            include_code=False
        )

        assert isinstance(ctx, ContextPayload)
        assert ctx.entity_type == EntityType.TASK
        assert ctx.entity.id == sample_task.id
        assert ctx.entity.name == "Test Task"

    def test_get_task_context_full_hierarchy(self, service, sample_project, sample_work_item, sample_task, sample_six_w):
        """Test task context with full hierarchy (task → work_item → project)."""
        from ..database.methods import contexts

        # Create all 3 contexts
        project_six_w = sample_six_w
        wi_six_w = UnifiedSixW(
            implementers=["feature-dev"],
            functional_requirements=["Feature requirement"],
            business_value="Feature value"
        )
        task_six_w = UnifiedSixW(
            implementers=["task-dev"],
            functional_requirements=["Task requirement"],
            acceptance_criteria=["Task AC1"]
        )

        contexts.create_context(service.db, Context(
            project_id=sample_project.id,
            context_type=ContextType.PROJECT_CONTEXT,
            entity_type=EntityType.PROJECT,
            entity_id=sample_project.id,
            six_w=project_six_w
        ))

        contexts.create_context(service.db, Context(
            project_id=sample_project.id,
            context_type=ContextType.WORK_ITEM_CONTEXT,
            entity_type=EntityType.WORK_ITEM,
            entity_id=sample_work_item.id,
            six_w=wi_six_w
        ))

        contexts.create_context(service.db, Context(
            project_id=sample_project.id,
            context_type=ContextType.TASK_CONTEXT,
            entity_type=EntityType.TASK,
            entity_id=sample_task.id,
            six_w=task_six_w
        ))

        # Get task context
        ctx = service.get_context(EntityType.TASK, sample_task.id)

        # Verify full hierarchy
        assert ctx.six_w is not None
        assert ctx.six_w.implementers == ['task-dev']

        assert ctx.parent_six_w is not None
        assert ctx.parent_six_w.implementers == ['feature-dev']

        assert ctx.project_six_w is not None
        assert ctx.project_six_w.implementers == ['python-expert']

    # ========================================================================
    # Idea Context
    # ========================================================================

    def test_get_idea_context_basic(self, service, sample_idea):
        """Test basic idea context retrieval."""
        ctx = service.get_context(
            EntityType.IDEA,
            sample_idea.id,
            include_supporting=False,
            include_code=False
        )

        assert isinstance(ctx, ContextPayload)
        assert ctx.entity_type == EntityType.IDEA
        assert ctx.entity.id == sample_idea.id
        assert ctx.entity.title == "Test Idea"

    # ========================================================================
    # Supporting Data
    # ========================================================================

    def test_load_documents(self, service, db_service, sample_task):
        """Test loading document references."""
        from ..database.models import DocumentReference
        from ..database.enums import DocumentType, DocumentFormat

        # Create sample document
        doc = DocumentReference(
            entity_type=EntityType.TASK,
            entity_id=sample_task.id,
            file_path="docs/design.md",
            document_type=DocumentType.DESIGN,
            format=DocumentFormat.MARKDOWN
        )

        # Insert into database
        query = """
            INSERT INTO document_references (entity_type, entity_id, file_path, document_type, format, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """
        db_service.execute_update(query, (
            doc.entity_type.value,
            doc.entity_id,
            doc.file_path,
            doc.document_type.value,
            doc.format.value,
            datetime.utcnow().isoformat(),
            datetime.utcnow().isoformat()
        ))

        # Get context with documents
        ctx = service.get_context(EntityType.TASK, sample_task.id, include_supporting=True)

        assert len(ctx.documents) == 1
        assert ctx.documents[0].file_path == "docs/design.md"

    # ========================================================================
    # Performance Tests
    # ========================================================================

    @pytest.mark.benchmark
    def test_performance_project_context(self, service, sample_project, benchmark):
        """Benchmark project context retrieval (<40ms target)."""
        result = benchmark(
            lambda: service.get_context(EntityType.PROJECT, sample_project.id)
        )
        assert isinstance(result, ContextPayload)

    @pytest.mark.benchmark
    def test_performance_task_context(self, service, sample_task, benchmark):
        """Benchmark task context retrieval (<80ms target)."""
        result = benchmark(
            lambda: service.get_context(EntityType.TASK, sample_task.id)
        )
        assert isinstance(result, ContextPayload)

    # ========================================================================
    # Security Tests
    # ========================================================================

    def test_sql_injection_prevention(self, service):
        """Test SQL injection attempt is safely handled."""
        # Attempt SQL injection via entity_id
        with pytest.raises((ValueError, TypeError)):
            service.get_context(EntityType.PROJECT, "1; DROP TABLE projects;")

    def test_path_traversal_prevention(self, service, sample_project, project_path):
        """Test path traversal in amalgamations is prevented."""
        # Create malicious path outside contexts directory
        malicious_path = project_path / ".agentpm" / "contexts" / ".." / ".." / "secrets.txt"
        malicious_path.parent.mkdir(parents=True, exist_ok=True)
        malicious_path.write_text("secret data")

        # Get context with code
        ctx = service.get_context(
            EntityType.PROJECT,
            sample_project.id,
            include_code=True
        )

        # Malicious path should not be included
        assert not any("secrets.txt" in path for path in ctx.amalgamations.values())
        # Only paths within .agentpm/contexts should be included
        assert all(".agentpm/contexts" in path for path in ctx.amalgamations.values())


# ============================================================================
# Integration Tests: Production Database
# ============================================================================


@pytest.mark.integration
class TestProductionDatabase:
    """Test UnifiedContextService with real production database."""

    @pytest.fixture
    def prod_db(self):
        """Connect to production database."""
        db_path = Path("/Users/nigelcopley/.project_manager/aipm-v2/agentpm.db")
        if not db_path.exists():
            pytest.skip("Production database not found")

        return DatabaseService(str(db_path))

    @pytest.fixture
    def prod_service(self, prod_db):
        """Create service with production database."""
        project_path = Path("/Users/nigelcopley/.project_manager/aipm-v2")
        return UnifiedContextService(prod_db, project_path)

    def test_prod_project_context(self, prod_service):
        """Test retrieving context for production project (ID=1)."""
        ctx = prod_service.get_context(EntityType.PROJECT, 1)

        assert ctx.entity_type == EntityType.PROJECT
        assert ctx.entity.name is not None
        print(f"\n✓ Project: {ctx.entity.name}")
        print(f"✓ Tech Stack: {ctx.entity.tech_stack}")
        print(f"✓ Amalgamations: {len(ctx.amalgamations)} files")

    def test_prod_work_item_context(self, prod_service):
        """Test retrieving context for production work item (ID=60)."""
        ctx = prod_service.get_context(EntityType.WORK_ITEM, 60)

        assert ctx.entity_type == EntityType.WORK_ITEM
        assert ctx.entity.name is not None
        print(f"\n✓ Work Item: {ctx.entity.name}")
        print(f"✓ Status: {ctx.entity.status.value}")
        if ctx.completeness:
            print(f"✓ Completeness: {ctx.completeness.percentage:.1f}%")

    def test_prod_task_context(self, prod_service):
        """Test retrieving context for production task (ID=355)."""
        ctx = prod_service.get_context(EntityType.TASK, 355)

        assert ctx.entity_type == EntityType.TASK
        assert ctx.entity.name is not None
        print(f"\n✓ Task: {ctx.entity.name}")
        print(f"✓ Status: {ctx.entity.status.value}")
        print(f"✓ Has 6W: {ctx.six_w is not None}")
        print(f"✓ Has parent 6W: {ctx.parent_six_w is not None}")
        print(f"✓ Has project 6W: {ctx.project_six_w is not None}")

    def test_prod_context_payload_serialization(self, prod_service):
        """Test full context payload serialization to dict."""
        ctx = prod_service.get_context(EntityType.TASK, 355, include_supporting=True)

        result = ctx.to_dict()

        assert 'entity' in result
        assert 'entity_type' in result
        assert 'six_w' in result
        assert 'documents' in result
        assert 'evidence' in result

        print(f"\n✓ Serialized payload keys: {list(result.keys())}")
        print(f"✓ Documents: {len(result['documents'])}")
        print(f"✓ Evidence: {len(result['evidence'])}")
        print(f"✓ Recent events: {len(result['recent_events'])}")
