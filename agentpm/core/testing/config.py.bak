"""
Testing Configuration Management

Handles loading and merging of testing configurations from multiple sources:
1. Global default configuration (shipped with APM (Agent Project Manager))
2. Project-specific configuration (.agentpm/testing_config.json)
3. Environment-specific overrides

Configuration Priority (highest to lowest):
1. Project-specific config (.agentpm/testing_config.json)
2. Global default config (agentpm/core/testing/default_config.json)
3. Hardcoded fallback defaults
"""

import json
import os
from pathlib import Path
from typing import Dict, Any, Optional
from dataclasses import dataclass


@dataclass
class TestingConfig:
    """Testing configuration container"""
    categories: Dict[str, Dict[str, Any]]
    version: str
    source: str  # Where this config was loaded from


class TestingConfigManager:
    """Manages testing configuration loading and merging"""
    
    def __init__(self):
        self._global_config_path = self._get_global_config_path()
        self._default_config = self._get_hardcoded_defaults()
    
    def _get_global_config_path(self) -> Path:
        """Get path to global testing configuration"""
        # Get the package directory
        package_dir = Path(__file__).parent.parent.parent
        return package_dir / "core" / "testing" / "default_config.json"
    
    def _get_hardcoded_defaults(self) -> Dict[str, Any]:
        """Get hardcoded default configuration as fallback"""
        return {
            "version": "1.0.0",
            "testing_categories": {
                "critical_paths": {
                    "min_coverage": 95.0,
                    "path_patterns": [
                        "**/core/**",
                        "**/business/**",
                        "**/critical/**",
                        "**/engine/**"
                    ],
                    "description": "Core business logic that drives the application"
                },
                "user_facing": {
                    "min_coverage": 85.0,
                    "path_patterns": [
                        "**/api/**",
                        "**/cli/**",
                        "**/web/**",
                        "**/ui/**",
                        "**/endpoints/**"
                    ],
                    "description": "Code that directly interacts with users"
                },
                "data_layer": {
                    "min_coverage": 90.0,
                    "path_patterns": [
                        "**/database/**",
                        "**/models/**",
                        "**/storage/**",
                        "**/persistence/**"
                    ],
                    "description": "Data persistence and integrity"
                },
                "security": {
                    "min_coverage": 95.0,
                    "path_patterns": [
                        "**/security/**",
                        "**/auth/**",
                        "**/validation/**",
                        "**/crypto/**"
                    ],
                    "description": "Security-critical code"
                },
                "utilities": {
                    "min_coverage": 70.0,
                    "path_patterns": [
                        "**/utils/**",
                        "**/helpers/**",
                        "**/common/**"
                    ],
                    "description": "Helper functions and common utilities"
                },
                "framework_integration": {
                    "min_coverage": 50.0,
                    "path_patterns": [
                        "**/framework/**",
                        "**/integration/**",
                        "**/adapters/**"
                    ],
                    "description": "Integration with external frameworks"
                }
            }
        }
    
    def load_global_config(self) -> Optional[TestingConfig]:
        """Load global testing configuration
        
        Returns:
            TestingConfig if found, None otherwise
        """
        if not self._global_config_path.exists():
            return None
        
        try:
            with open(self._global_config_path, 'r') as f:
                config_data = json.load(f)
            
            return TestingConfig(
                categories=config_data.get('testing_categories', {}),
                version=config_data.get('version', '1.0.0'),
                source='global'
            )
        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: Could not load global testing config: {e}")
            return None
    
    def load_project_config(self, project_path: str) -> Optional[TestingConfig]:
        """Load project-specific testing configuration
        
        Args:
            project_path: Path to project root
            
        Returns:
            TestingConfig if found, None otherwise
        """
        config_path = Path(project_path) / '.agentpm' / 'testing_config.json'
        
        if not config_path.exists():
            return None
        
        try:
            with open(config_path, 'r') as f:
                config_data = json.load(f)
            
            return TestingConfig(
                categories=config_data.get('testing_categories', {}),
                version=config_data.get('version', '1.0.0'),
                source='project'
            )
        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: Could not load project testing config: {e}")
            return None
    
    def load_merged_config(self, project_path: str) -> TestingConfig:
        """Load and merge testing configuration from all sources
        
        Args:
            project_path: Path to project root
            
        Returns:
            Merged TestingConfig with project overrides applied
        """
        # Start with hardcoded defaults
        merged_config = self._default_config.copy()
        source_info = ["hardcoded_defaults"]
        
        # Apply global config if available
        global_config = self.load_global_config()
        if global_config:
            merged_config = self._merge_configs(merged_config, global_config.categories)
            source_info.append("global")
        
        # Apply project config if available (highest priority)
        project_config = self.load_project_config(project_path)
        if project_config:
            merged_config = self._merge_configs(merged_config, project_config.categories)
            source_info.append("project")
        
        return TestingConfig(
            categories=merged_config['testing_categories'],
            version=merged_config['version'],
            source=" + ".join(source_info)
        )
    
    def _merge_configs(self, base_config: Dict[str, Any], override_config: Dict[str, Any]) -> Dict[str, Any]:
        """Merge configuration dictionaries with override taking precedence
        
        Args:
            base_config: Base configuration
            override_config: Override configuration
            
        Returns:
            Merged configuration
        """
        merged = base_config.copy()
        
        if 'testing_categories' in override_config:
            merged['testing_categories'] = merged['testing_categories'].copy()
            
            for category_name, category_config in override_config['testing_categories'].items():
                if category_name in merged['testing_categories']:
                    # Merge individual category configs
                    merged_category = merged['testing_categories'][category_name].copy()
                    merged_category.update(category_config)
                    merged['testing_categories'][category_name] = merged_category
                else:
                    # Add new category
                    merged['testing_categories'][category_name] = category_config
        
        return merged
    
    def create_project_config(self, project_path: str, config_data: Dict[str, Any]) -> bool:
        """Create project-specific testing configuration
        
        Args:
            project_path: Path to project root
            config_data: Configuration data to write
            
        Returns:
            True if successful, False otherwise
        """
        config_path = Path(project_path) / '.agentpm' / 'testing_config.json'
        
        try:
            # Ensure .agentpm directory exists
            config_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write configuration
            with open(config_path, 'w') as f:
                json.dump(config_data, f, indent=2)
            
            return True
        except IOError as e:
            print(f"Error: Could not create project testing config: {e}")
            return False
    
    def create_global_config(self, config_data: Dict[str, Any]) -> bool:
        """Create global testing configuration
        
        Args:
            config_data: Configuration data to write
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Ensure directory exists
            self._global_config_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write configuration
            with open(self._global_config_path, 'w') as f:
                json.dump(config_data, f, indent=2)
            
            return True
        except IOError as e:
            print(f"Error: Could not create global testing config: {e}")
            return False
    
    def get_config_info(self, project_path: str) -> Dict[str, Any]:
        """Get information about loaded configuration
        
        Args:
            project_path: Path to project root
            
        Returns:
            Configuration information
        """
        config = self.load_merged_config(project_path)
        
        return {
            'version': config.version,
            'source': config.source,
            'categories': list(config.categories.keys()),
            'global_config_exists': self._global_config_path.exists(),
            'project_config_exists': (Path(project_path) / '.agentpm' / 'testing_config.json').exists(),
            'global_config_path': str(self._global_config_path),
            'project_config_path': str(Path(project_path) / '.agentpm' / 'testing_config.json')
        }


# Global instance
_config_manager = TestingConfigManager()


def load_project_testing_config(project_path: str) -> Dict[str, Any]:
    """Load project testing configuration (backward compatibility)
    
    Args:
        project_path: Path to project root
        
    Returns:
        Project configuration dictionary
    """
    config = _config_manager.load_merged_config(project_path)
    return {
        'testing_categories': config.categories,
        'version': config.version
    }


def create_agentpm_testing_config() -> Dict[str, Any]:
    """Create APM (Agent Project Manager) specific testing configuration
    
    Returns:
        APM (Agent Project Manager) testing configuration
    """
    return {
        "version": "1.0.0",
        "testing_categories": {
            "critical_paths": {
                "min_coverage": 95.0,
                "path_patterns": [
                    "agentpm/core/workflow/**",
                    "agentpm/core/context/**",
                    "agentpm/core/database/**",
                    "agentpm/core/rules/**"
                ],
                "description": "Core APM (Agent Project Manager) business logic and workflow engine"
            },
            "user_facing": {
                "min_coverage": 85.0,
                "path_patterns": [
                    "agentpm/cli/**",
                    "agentpm/web/**"
                ],
                "description": "CLI commands and web interface"
            },
            "data_layer": {
                "min_coverage": 90.0,
                "path_patterns": [
                    "agentpm/core/database/**",
                    "agentpm/core/models/**"
                ],
                "description": "Database operations and data models"
            },
            "security": {
                "min_coverage": 95.0,
                "path_patterns": [
                    "agentpm/core/security/**",
                    "agentpm/cli/utils/security.py"
                ],
                "description": "Security validation and authentication"
            },
            "utilities": {
                "min_coverage": 70.0,
                "path_patterns": [
                    "agentpm/utils/**",
                    "agentpm/hooks/**"
                ],
                "description": "Helper functions and utilities"
            },
            "framework_integration": {
                "min_coverage": 50.0,
                "path_patterns": [
                    "agentpm/templates/**",
                    "agentpm/web/static/**"
                ],
                "description": "Template and static file handling"
            }
        }
    }


def ensure_testing_config_installed(project_path: str) -> bool:
    """Ensure testing configuration is installed for a project
    
    This function should be called during project initialization.
    
    Args:
        project_path: Path to project root
        
    Returns:
        True if configuration is available, False otherwise
    """
    # Check if project config already exists
    project_config_path = Path(project_path) / '.agentpm' / 'testing_config.json'
    if project_config_path.exists():
        return True
    
    # Create project config based on detected project type
    if _is_agentpm_project(project_path):
        config_data = create_agentpm_testing_config()
    else:
        # Use default configuration
        config_data = _config_manager._default_config
    
    return _config_manager.create_project_config(project_path, config_data)


def _is_agentpm_project(project_path: str) -> bool:
    """Check if this is an APM (Agent Project Manager) project
    
    Args:
        project_path: Path to project root
        
    Returns:
        True if this appears to be an APM (Agent Project Manager) project
    """
    project_path = Path(project_path)
    
    # Check for APM (Agent Project Manager) indicators
    indicators = [
        'agentpm' in str(project_path),
        (project_path / 'agentpm').exists(),
        (project_path / 'agentpm' / 'core').exists(),
        (project_path / 'agentpm' / 'cli').exists()
    ]
    
    return any(indicators)


# Example usage
if __name__ == "__main__":
    # Test configuration loading
    manager = TestingConfigManager()
    
    # Test with current directory
    project_path = "."
    config = manager.load_merged_config(project_path)
    
    print(f"Loaded config from: {config.source}")
    print(f"Version: {config.version}")
    print(f"Categories: {list(config.categories.keys())}")
    
    # Show config info
    info = manager.get_config_info(project_path)
    print(f"\nConfig Info:")
    for key, value in info.items():
        print(f"  {key}: {value}")
