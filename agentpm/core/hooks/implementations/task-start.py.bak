#!/usr/bin/env python3
"""
Claude Code TaskStart Hook - Context Assembly on Task Start

Triggered when a task transitions to ACTIVE state.
Assembles complete hierarchical context using Context Delivery Agent.

Performance: <200ms (CRITICAL PATH - blocks workflow)

Hook Input (JSON):
{
    "task_id": 45,
    "agent_role": "python-expert",  # optional override
    "session_id": "uuid"
}

Hook Output (stdout): Complete task context with hierarchical 6W, plugin facts, SOP
"""

import json
import sys
from pathlib import Path
from datetime import datetime

# Add project to path
PROJECT_ROOT = Path(__file__).parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Import Context Agent integration
from agentpm.core.hooks.context_integration import ContextHookAdapter


def read_hook_input() -> dict:
    """Read JSON hook input from stdin."""
    try:
        return json.loads(sys.stdin.read())
    except json.JSONDecodeError:
        return {}


def main():
    """
    Main hook entry point.

    CRITICAL: This hook is on the workflow's critical path.
    Performance target: <200ms (p95)
    """
    try:
        start_time = datetime.now()

        # Read hook input
        hook_data = read_hook_input()
        task_id = hook_data.get('task_id')
        agent_role = hook_data.get('agent_role')
        session_id = hook_data.get('session_id', 'unknown')

        # Validate required parameters
        if not task_id:
            print("‚ùå TaskStart hook error: task_id is required", file=sys.stderr)
            sys.exit(1)

        # Log to stderr (debugging)
        print(f"ü™ù TaskStart: task={task_id}, agent={agent_role}, session={session_id}",
              file=sys.stderr)

        # Initialize Context Agent adapter
        adapter = ContextHookAdapter(PROJECT_ROOT)

        # Assemble complete task context using Context Delivery Agent
        # This uses the 11-step assembly pipeline:
        # 1. Load entities (task, work item, project)
        # 2. Load 6W contexts (all three levels)
        # 3. Merge 6W hierarchically (task > work_item > project)
        # 4. Load plugin facts (tech stack)
        # 5. Get amalgamation paths (code files)
        # 6. Calculate freshness
        # 7. Calculate confidence score
        # 8. Inject agent SOP
        # 9. Load temporal context (session summaries)
        # 10. Filter by agent role (capability-based)
        # 11. Return payload
        context_text = adapter.format_task_context(task_id=task_id, agent_role=agent_role)

        # Calculate execution time
        duration_ms = (datetime.now() - start_time).total_seconds() * 1000

        # Log performance (monitoring SLA)
        print(f"‚è±Ô∏è  TaskStart completed in {duration_ms:.0f}ms", file=sys.stderr)

        if duration_ms > 200:
            print(f"‚ö†Ô∏è  TaskStart exceeded 200ms SLA!", file=sys.stderr)

        # Output context to stdout (injected into Claude's context)
        print(context_text)

        sys.exit(0)

    except Exception as e:
        # Graceful degradation - provide minimal context
        print(f"‚ùå TaskStart hook error: {e}", file=sys.stderr)

        # Output minimal fallback context
        fallback_text = f"""
---
## ‚ö†Ô∏è Task Context Loading Failed

Task #{task_id if 'task_id' in locals() else 'unknown'}: Context assembly failed

**Error**: {e}

**Fallback Actions**:
- Use `apm task show {task_id if 'task_id' in locals() else '<id>'}` for task details
- Check `.agentpm/contexts/` for available context files
- Verify database is not locked

Continuing without full context assembly...
---
"""
        print(fallback_text)
        sys.exit(1)


if __name__ == "__main__":
    main()
