"""
Workflow Service - State Transition Coordination

Manages state transitions for projects, work items, and tasks with complete validation.

Uses:
- StateMachine for transition rules
- StateRequirements for state-specific validation
- DependencyValidator for completion checks

Pattern: Service coordinator with comprehensive validation
"""

from typing import Optional, Any
from datetime import datetime

from ..database.service import DatabaseService
from ..database.models import Project, WorkItem, Task
from ..database.enums import ProjectStatus, WorkItemStatus, TaskStatus, TaskType, EntityType, EnforcementLevel, WorkItemType, Phase
from .state_machine import StateMachine
from .validators import StateRequirements, DependencyValidator, ValidationResult
from .phase_validator import PhaseValidator


class WorkflowError(Exception):
    """Workflow validation or transition error"""
    pass


class WorkflowService:
    """
    Workflow service coordinator for state management.

    Provides validated state transitions for all entity types.
    """

    def __init__(self, db_service: DatabaseService):
        """
        Initialize workflow service.

        Args:
            db_service: Database service instance
        """
        self.db = db_service
        self.phase_validator = PhaseValidator()

        # Define type-specific phase-status combinations
        # Each work item type has different valid phase-status combinations
        self.TYPE_PHASE_STATUS_MAPPING = {
            # FEATURE: Full lifecycle (D1→P1→I1→R1→O1→E1)
            WorkItemType.FEATURE: {
                Phase.D1_DISCOVERY: [WorkItemStatus.DRAFT],
                Phase.P1_PLAN: [WorkItemStatus.READY],
                Phase.I1_IMPLEMENTATION: [WorkItemStatus.ACTIVE],
                Phase.R1_REVIEW: [WorkItemStatus.REVIEW],
                Phase.O1_OPERATIONS: [WorkItemStatus.DONE],
                Phase.E1_EVOLUTION: [WorkItemStatus.ARCHIVED],
            },
            
            # ENHANCEMENT: D1→P1→I1→R1→E1 (skip O1)
            WorkItemType.ENHANCEMENT: {
                Phase.D1_DISCOVERY: [WorkItemStatus.DRAFT],
                Phase.P1_PLAN: [WorkItemStatus.READY],
                Phase.I1_IMPLEMENTATION: [WorkItemStatus.ACTIVE],
                Phase.R1_REVIEW: [WorkItemStatus.REVIEW],
                Phase.E1_EVOLUTION: [WorkItemStatus.DONE, WorkItemStatus.ARCHIVED],
            },
            
            # BUGFIX: I1→R1 (skip discovery, planning)
            WorkItemType.BUGFIX: {
                Phase.I1_IMPLEMENTATION: [WorkItemStatus.ACTIVE],
                Phase.R1_REVIEW: [WorkItemStatus.REVIEW, WorkItemStatus.DONE],
            },
            
            # RESEARCH: D1→P1 (no implementation)
            WorkItemType.RESEARCH: {
                Phase.D1_DISCOVERY: [WorkItemStatus.DRAFT],
                Phase.P1_PLAN: [WorkItemStatus.READY, WorkItemStatus.DONE],
            },
            
            # PLANNING: D1→P1 (no implementation)
            WorkItemType.PLANNING: {
                Phase.D1_DISCOVERY: [WorkItemStatus.DRAFT],
                Phase.P1_PLAN: [WorkItemStatus.READY, WorkItemStatus.DONE],
            },
            
            # ANALYSIS: D1→P1 (no implementation, can be ACTIVE in P1 for task execution)
            WorkItemType.ANALYSIS: {
                Phase.D1_DISCOVERY: [WorkItemStatus.DRAFT],
                Phase.P1_PLAN: [WorkItemStatus.READY, WorkItemStatus.ACTIVE, WorkItemStatus.DONE],
            },
            
            # REFACTORING: P1→I1→R1 (skip discovery)
            WorkItemType.REFACTORING: {
                Phase.P1_PLAN: [WorkItemStatus.READY],
                Phase.I1_IMPLEMENTATION: [WorkItemStatus.ACTIVE],
                Phase.R1_REVIEW: [WorkItemStatus.REVIEW, WorkItemStatus.DONE],
            },
            
            # INFRASTRUCTURE: D1→P1→I1→R1→O1 (no evolution)
            WorkItemType.INFRASTRUCTURE: {
                Phase.D1_DISCOVERY: [WorkItemStatus.DRAFT],
                Phase.P1_PLAN: [WorkItemStatus.READY],
                Phase.I1_IMPLEMENTATION: [WorkItemStatus.ACTIVE],
                Phase.R1_REVIEW: [WorkItemStatus.REVIEW],
                Phase.O1_OPERATIONS: [WorkItemStatus.DONE, WorkItemStatus.ARCHIVED],
            },
            
            # MAINTENANCE: I1→O1→E1 (ongoing work)
            WorkItemType.MAINTENANCE: {
                Phase.I1_IMPLEMENTATION: [WorkItemStatus.ACTIVE],
                Phase.O1_OPERATIONS: [WorkItemStatus.DONE],
                Phase.E1_EVOLUTION: [WorkItemStatus.ARCHIVED],
            },
            
            # MONITORING: O1→E1 (ongoing monitoring)
            WorkItemType.MONITORING: {
                Phase.O1_OPERATIONS: [WorkItemStatus.ACTIVE, WorkItemStatus.DONE],
                Phase.E1_EVOLUTION: [WorkItemStatus.ARCHIVED],
            },
            
            # DOCUMENTATION: I1→R1→E1 (document existing work)
            WorkItemType.DOCUMENTATION: {
                Phase.I1_IMPLEMENTATION: [WorkItemStatus.ACTIVE],
                Phase.R1_REVIEW: [WorkItemStatus.REVIEW],
                Phase.E1_EVOLUTION: [WorkItemStatus.DONE, WorkItemStatus.ARCHIVED],
            },
            
            # SECURITY: Full lifecycle with security focus
            WorkItemType.SECURITY: {
                Phase.D1_DISCOVERY: [WorkItemStatus.DRAFT],
                Phase.P1_PLAN: [WorkItemStatus.READY],
                Phase.I1_IMPLEMENTATION: [WorkItemStatus.ACTIVE],
                Phase.R1_REVIEW: [WorkItemStatus.REVIEW],
                Phase.O1_OPERATIONS: [WorkItemStatus.DONE],
                Phase.E1_EVOLUTION: [WorkItemStatus.ARCHIVED],
            },
            
            # FIX_BUGS_ISSUES: I1→R1→O1→E1 (continuous bug fixing)
            WorkItemType.FIX_BUGS_ISSUES: {
                Phase.I1_IMPLEMENTATION: [WorkItemStatus.ACTIVE],
                Phase.R1_REVIEW: [WorkItemStatus.REVIEW],
                Phase.O1_OPERATIONS: [WorkItemStatus.DONE],
                Phase.E1_EVOLUTION: [WorkItemStatus.ARCHIVED],
            },
        }

    # ========== PROJECT TRANSITIONS ==========

    def transition_project(
        self,
        project_id: int,
        new_status: ProjectStatus,
        reason: Optional[str] = None
    ) -> Project:
        """
        Transition project to new status with validation.

        Args:
            project_id: Project ID
            new_status: Desired new status
            reason: Optional reason for transition

        Returns:
            Updated Project

        Raises:
            WorkflowError: If validation fails

        Example:
            project = workflow.transition_project(
                project_id=1,
                new_status=ProjectStatus.ACTIVE,
                reason="Starting development"
            )
        """
        from ..database.methods import projects

        # Load project with error handling
        try:
            project = projects.get_project(self.db, project_id)
        except Exception as e:
            raise WorkflowError(f"Failed to load project {project_id}: {str(e)}")
        
        if not project:
            raise WorkflowError(f"Project {project_id} not found")

        # Validate transition
        try:
            validation = self._validate_transition(
                EntityType.PROJECT,
                project_id,
                project.status,
                new_status,
                reason
            )
        except Exception as e:
            raise WorkflowError(f"Validation error: {str(e)}")

        if not validation.valid:
            raise WorkflowError(f"Transition validation failed: {validation.reason}")

        # Execute transition with error handling
        try:
            updated = projects.update_project(self.db, project_id, status=new_status)
        except Exception as e:
            raise WorkflowError(f"Failed to update project {project_id}: {str(e)}")

        if not updated:
            raise WorkflowError(f"Failed to update project {project_id}")

        return updated

    # ========== WORK ITEM TRANSITIONS ==========

    def transition_work_item(
        self,
        work_item_id: int,
        new_status: WorkItemStatus,
        reason: Optional[str] = None
    ) -> WorkItem:
        """
        Transition work item to new status with validation.

        Args:
            work_item_id: Work item ID
            new_status: Desired new status
            reason: Optional reason (required for backward transitions)

        Returns:
            Updated WorkItem

        Raises:
            WorkflowError: If validation fails
        """
        from ..database.methods import work_items

        # Load work item with error handling
        try:
            work_item = work_items.get_work_item(self.db, work_item_id)
        except Exception as e:
            raise WorkflowError(f"Failed to load work item {work_item_id}: {str(e)}")
        
        if not work_item:
            raise WorkflowError(f"Work item {work_item_id} not found")

        # NEW: Check phase-status alignment before validation (fail fast)
        if hasattr(work_item, 'phase') and work_item.phase:
            self._validate_phase_status_alignment(work_item, new_status)

        # Check governance rules (WI-19)
        if work_item.status != new_status:
            self._check_rules(
                entity_type=EntityType.WORK_ITEM,
                entity=work_item,
                transition={'from': work_item.status.value, 'to': new_status.value}
            )

        if (work_item.is_continuous or WorkItemType.is_continuous_type(work_item.type)) and new_status in {
            WorkItemStatus.DONE,
            WorkItemStatus.ARCHIVED,
            WorkItemStatus.CANCELLED,
        }:
            raise WorkflowError(
                "Continuous work items cannot transition to completed, archived, or cancelled. "
                "They remain active backlogs."
            )

        # Validate transition with error handling
        try:
            validation = self._validate_transition(
                EntityType.WORK_ITEM,
                work_item_id,
                work_item.status,
                new_status,
                reason,
                entity=work_item
            )
        except Exception as e:
            raise WorkflowError(f"Validation error: {str(e)}")

        if not validation.valid:
            raise WorkflowError(f"Transition validation failed: {validation.reason}")

        # Execute transition with error handling
        try:
            updated = work_items.update_work_item(self.db, work_item_id, status=new_status)
        except Exception as e:
            raise WorkflowError(f"Failed to update work item {work_item_id}: {str(e)}")

        if not updated:
            raise WorkflowError(f"Failed to update work item {work_item_id}")

        # NEW (WI-35 Task #173): Emit workflow event for state transition
        self._emit_workflow_event(
            entity_type='work_item',
            entity_id=updated.id,
            entity_name=updated.name,
            previous_status=work_item.status.value,
            new_status=new_status.value,
            work_item_id=updated.id,
            project_id=updated.project_id
        )

        return updated

    # ========== TASK TRANSITIONS ==========

    def transition_task(
        self,
        task_id: int,
        new_status: TaskStatus,
        reason: Optional[str] = None,
        blocked_reason: Optional[str] = None
    ) -> Task:
        """
        Transition task to new status with validation.

        Args:
            task_id: Task ID
            new_status: Desired new status
            reason: Optional reason for transition
            blocked_reason: Required if new_status is BLOCKED

        Returns:
            Updated Task

        Raises:
            WorkflowError: If validation fails

        Example:
            task = workflow.transition_task(
                task_id=123,
                new_status=TaskStatus.BLOCKED,
                blocked_reason="Waiting for API approval"
            )
        """
        from ..database.methods import tasks, work_items

        # Load task with error handling
        try:
            task = tasks.get_task(self.db, task_id)
        except Exception as e:
            raise WorkflowError(f"Failed to load task {task_id}: {str(e)}")
        
        if not task:
            raise WorkflowError(f"Task {task_id} not found")

        # NEW: Terminal state gate - prevent updates to completed tasks
        # Check if task is already in terminal state (DONE, CANCELLED, ARCHIVED)
        # This must happen BEFORE other validations to provide clear error messages
        if TaskStatus.is_terminal_state(task.status):
            raise WorkflowError(
                f"Cannot update task #{task_id}: Task is already {task.status.value} "
                f"(terminal state). Completed tasks cannot be modified.\n\n"
                f"Task: {task.name}\n"
                f"Current status: {task.status.value}\n"
                f"Requested status: {new_status.value}\n\n"
                f"Note: Tasks in terminal states (done, cancelled, archived) are "
                f"historical records and cannot be updated."
            )

        # NEW (WI-33): Agent validation with smart error messaging (CI-001 gate)
        # Validate agent exists and active before starting work
        if new_status == TaskStatus.ACTIVE and task.status != TaskStatus.ACTIVE:
            from .agent_validators import AgentAssignmentValidator, SmartErrorMessageBuilder

            # Validate agent assignment
            validation = AgentAssignmentValidator.validate_agent_assignment(
                self.db,
                task,
                new_status
            )

            if not validation.valid:
                # Load work item for project_id (needed for smart error)
                work_item = work_items.get_work_item(self.db, task.work_item_id)
                if work_item:
                    # Build comprehensive error with suggestions
                    error_msg = SmartErrorMessageBuilder.build_agent_error(
                        validation,
                        task,
                        self.db,
                        work_item.project_id
                    )
                else:
                    # Fallback to simple error if work item not found
                    error_msg = validation.error_message

                raise WorkflowError(error_msg)

        # Work item state gate validation (fail fast)
        # Only validate when status actually changing (not for metadata updates)
        if task.status != new_status:
            self._validate_work_item_state(task, new_status)

        # Special validation for BLOCKED state
        if new_status == TaskStatus.BLOCKED and not blocked_reason:
            raise WorkflowError("blocked_reason required when transitioning to BLOCKED")

        # Check governance rules (WI-19)
        if task.status != new_status:
            self._check_rules(
                entity_type=EntityType.TASK,
                entity=task,
                transition={'from': task.status.value, 'to': new_status.value}
            )

        # Validate transition with error handling
        try:
            validation = self._validate_transition(
                EntityType.TASK,
                task_id,
                task.status,
                new_status,
                reason,
                entity=task
            )
        except Exception as e:
            raise WorkflowError(f"Validation error: {str(e)}")

        if not validation.valid:
            raise WorkflowError(f"Transition validation failed: {validation.reason}")

        # Build update parameters
        update_params = {'status': new_status}
        if blocked_reason:
            update_params['blocked_reason'] = blocked_reason

        # Clear blocked_reason if unblocking
        if task.status == TaskStatus.BLOCKED and new_status != TaskStatus.BLOCKED:
            update_params['blocked_reason'] = None

        # Set completed_at if completing
        if new_status == TaskStatus.DONE and task.status != TaskStatus.DONE:
            update_params['completed_at'] = datetime.now()

        # Execute transition with error handling
        try:
            updated = tasks.update_task(self.db, task_id, **update_params)
        except Exception as e:
            raise WorkflowError(f"Failed to update task {task_id}: {str(e)}")

        if not updated:
            raise WorkflowError(f"Failed to update task {task_id}")

        # NEW (WI-35): Automatic session tracking integration
        # Track work in current session (if one exists)
        self._track_session_activity(updated, new_status, task.status)

        # NEW (WI-35 Task #173): Emit workflow event for state transition
        # Get work item for project_id
        work_item = work_items.get_work_item(self.db, updated.work_item_id)
        if work_item:
            self._emit_workflow_event(
                entity_type='task',
                entity_id=updated.id,
                entity_name=updated.name,
                previous_status=task.status.value,
                new_status=new_status.value,
                work_item_id=updated.work_item_id,
                project_id=work_item.project_id,
                agent_assigned=updated.assigned_to
            )

        # NEW (Task #147): Trigger TaskStart hook on ACTIVE transition
        # This assembles context using Context Delivery Agent
        if new_status == TaskStatus.ACTIVE and task.status != TaskStatus.ACTIVE:
            self._trigger_task_start_hook(updated)

        return updated

    # ========== CONVENIENCE METHODS ==========

    def start_work_item(self, work_item_id: int) -> WorkItem:
        """Transition work item to ACTIVE"""
        return self.transition_work_item(work_item_id, WorkItemStatus.ACTIVE)

    def complete_work_item(self, work_item_id: int) -> WorkItem:
        """Transition work item to DONE (validates all tasks done)"""
        return self.transition_work_item(work_item_id, WorkItemStatus.DONE)

    def start_task(self, task_id: int) -> Task:
        """Transition task to ACTIVE"""
        return self.transition_task(task_id, TaskStatus.ACTIVE)

    def complete_task(self, task_id: int) -> Task:
        """Transition task to DONE (sets completed_at)"""
        return self.transition_task(task_id, TaskStatus.DONE)

    def block_task(self, task_id: int, blocked_reason: str) -> Task:
        """Transition task to BLOCKED with reason"""
        return self.transition_task(
            task_id,
            TaskStatus.BLOCKED,
            blocked_reason=blocked_reason
        )

    def unblock_task(self, task_id: int, reason: str = "Blocker resolved") -> Task:
        """Unblock task (BLOCKED → ACTIVE)"""
        return self.transition_task(task_id, TaskStatus.ACTIVE, reason=reason)

    def cancel_task(self, task_id: int, reason: str) -> Task:
        """Cancel task"""
        return self.transition_task(task_id, TaskStatus.CANCELLED, reason=reason)

    # ========== VALIDATION ORCHESTRATION ==========

    def _validate_transition(
        self,
        entity_type: EntityType,
        entity_id: int,
        current_status: Any,
        new_status: Any,
        reason: Optional[str] = None,
        entity: Optional[Any] = None
    ) -> ValidationResult:
        """
        Complete transition validation.

        Checks (in order):
        1. Forbidden transitions
        2. State machine (forward or backward)
        3. State-specific requirements
        4. Dependency validation

        Args:
            entity_type: Entity type
            entity_id: Entity ID
            current_status: Current status
            new_status: Desired status
            reason: Transition reason
            entity: Entity object (if already loaded)

        Returns:
            ValidationResult
        """
        # Step 1: Check forbidden
        is_forbidden, forbidden_reason = StateMachine.is_forbidden(current_status, new_status)
        if is_forbidden:
            return ValidationResult(valid=False, reason=f"Forbidden: {forbidden_reason}")

        # Step 2: Check state machine (forward)
        if StateMachine.can_transition(entity_type, current_status, new_status):
            pass  # Valid forward transition

        # Step 3: Check backward transitions
        elif StateMachine.is_backward_transition(current_status, new_status):
            is_allowed, error = StateMachine.is_backward_allowed(current_status, new_status, reason)
            if not is_allowed:
                return ValidationResult(valid=False, reason=error)

        else:
            # Invalid transition
            valid_next = StateMachine.get_valid_transitions(entity_type, current_status)
            valid_names = [s.value for s in valid_next]
            return ValidationResult(
                valid=False,
                reason=f"Invalid transition {current_status.value} → {new_status.value}. Valid next states: {valid_names}"
            )

        entity_is_continuous = False
        if entity_type == EntityType.WORK_ITEM and entity is not None:
            entity_is_continuous = bool(
                getattr(entity, 'is_continuous', False)
                or (hasattr(entity, 'type') and isinstance(entity.type, WorkItemType)
                    and WorkItemType.is_continuous_type(entity.type))
            )

        # Step 4: State-specific requirements
        if entity_type == EntityType.WORK_ITEM and entity:
            req_result = StateRequirements.validate_work_item_requirements(entity, new_status, self.db)
            if not req_result.valid:
                return req_result

        elif entity_type == EntityType.TASK and entity:
            req_result = StateRequirements.validate_task_requirements(entity, new_status, self.db)
            if not req_result.valid:
                return req_result

        # Step 5: Dependency validation for completion
        if (
            entity_type == EntityType.WORK_ITEM
            and new_status in [WorkItemStatus.DONE, WorkItemStatus.REVIEW]
            and not entity_is_continuous
        ):
            dep_result = DependencyValidator.validate_work_item_completion(entity_id, self.db)
            if not dep_result.valid:
                return dep_result

        if entity_type == EntityType.PROJECT and new_status == ProjectStatus.DONE:
            dep_result = DependencyValidator.validate_project_completion(entity_id, self.db)
            if not dep_result.valid:
                return dep_result

        # Step 5: Phase gate validation for work items (NEW)
        if entity_type == EntityType.WORK_ITEM and entity and hasattr(entity, 'phase') and entity.phase:
            phase_result = self._validate_phase_gate(entity, new_status)
            if not phase_result.valid:
                return phase_result

        # Step 6: Task dependency and blocker validation (WI-008)
        if entity_type == EntityType.TASK:
            dep_result = DependencyValidator.validate_task_dependencies(
                entity_id,
                current_status,
                new_status,
                self.db
            )
            if not dep_result.valid:
                return dep_result

        # All validations passed
        return ValidationResult(valid=True)

    # ========== WORK ITEM STATE GATE VALIDATION ==========

    def _validate_work_item_state(self, task: Task, new_status: TaskStatus) -> None:
        """
        Validate task transition against work item state requirements.

        Enforces work item state gates to ensure proper workflow progression.
        Tasks cannot progress beyond their parent work item's state.

        Args:
            task: Task entity (contains work_item_id)
            new_status: Desired task status

        Raises:
            WorkflowError: If work item state doesn't support task transition

        Example:
            # Task wants to start (ACTIVE → ACTIVE)
            # Work item must be ACTIVE or later
            >>> self._validate_work_item_state(task, TaskStatus.ACTIVE)
            # Raises: "Cannot start task: Work item #13 must be 'in_progress'..."
        """
        from ..database.methods import work_items

        # Step 1: Load parent work item with error handling
        try:
            work_item = work_items.get_work_item(self.db, task.work_item_id)
        except Exception as e:
            raise WorkflowError(
                f"Failed to load work item #{task.work_item_id}: {str(e)}. "
                f"Task #{task.id} references invalid work item."
            )
        
        if not work_item:
            raise WorkflowError(
                f"Data integrity error: Work item #{task.work_item_id} not found. "
                f"Task #{task.id} references missing work item."
            )

        # Step 2: Handle administrative transitions (special rules)
        if new_status == TaskStatus.CANCELLED:
            # Can cancel unless work item is terminal (historical record)
            if work_item.status in [WorkItemStatus.DONE, WorkItemStatus.ARCHIVED]:
                raise WorkflowError(
                    f"\n❌ Cannot cancel task: Work item #{work_item.id} is "
                    f"completed/archived (historical record)\n\n"
                    f"Note: Tasks in completed work items are historical and "
                    f"cannot be modified."
                )
            return  # Skip other checks for cancelling

        if new_status == TaskStatus.ARCHIVED:
            # Can only archive if work item completed/archived
            if work_item.status not in [WorkItemStatus.DONE, WorkItemStatus.ARCHIVED]:
                raise WorkflowError(
                    f"\n❌ Cannot archive task: Work item #{work_item.id} must be "
                    f"'completed' or 'archived' (currently '{work_item.status.value}')\n\n"
                    f"Fix: apm work-item complete {work_item.id}\n"
                )
            return  # Skip other checks for archiving

        # Step 3: Get required work item states for this task transition
        required_states = self._get_required_work_item_states(new_status)

        # Step 4: Validate work item state
        if work_item.status not in required_states:
            error_msg = self._build_work_item_state_error(
                task, work_item, new_status, required_states
            )
            raise WorkflowError(error_msg)

    def _get_required_work_item_states(self, new_task_status: TaskStatus) -> list[WorkItemStatus]:
        """
        Get required work item states for task transition.

        Implements the validation matrix from state-validation-rules-specification.md.

        Args:
            new_task_status: Desired task status

        Returns:
            List of work item statuses that allow this task transition

        Example:
            >>> # Task going ACTIVE → ACTIVE (CRITICAL RULE)
            >>> self._get_required_work_item_states(TaskStatus.ACTIVE)
            [WorkItemStatus.ACTIVE, WorkItemStatus.REVIEW, WorkItemStatus.DONE]
        """
        # DRAFT tasks: always allowed (brainstorming phase)
        if new_task_status == TaskStatus.DRAFT:
            return list(WorkItemStatus)  # All states allowed

        # READY tasks: work item must be validated or later
        if new_task_status == TaskStatus.READY:
            return [
                WorkItemStatus.READY,
                WorkItemStatus.ACTIVE,
                WorkItemStatus.ACTIVE,
                WorkItemStatus.REVIEW,
                WorkItemStatus.DONE,
            ]

        # ACTIVE tasks: work item must be accepted or later
        if new_task_status == TaskStatus.ACTIVE:
            return [
                WorkItemStatus.ACTIVE,
                WorkItemStatus.ACTIVE,
                WorkItemStatus.REVIEW,
                WorkItemStatus.DONE,
            ]

        # ACTIVE tasks: work item must be in_progress or later (CRITICAL)
        # This prevents the broken dogfooding behavior
        if new_task_status == TaskStatus.ACTIVE:
            return [
                WorkItemStatus.ACTIVE,
                WorkItemStatus.REVIEW,
                WorkItemStatus.DONE,
            ]

        # REVIEW tasks: work item must be active
        if new_task_status == TaskStatus.REVIEW:
            return [
                WorkItemStatus.ACTIVE,
                WorkItemStatus.REVIEW,
                WorkItemStatus.DONE,
            ]

        # DONE tasks: work item must be active or completing
        if new_task_status == TaskStatus.DONE:
            return [
                WorkItemStatus.ACTIVE,
                WorkItemStatus.REVIEW,
                WorkItemStatus.DONE,
            ]

        # BLOCKED tasks: work item must be active
        if new_task_status == TaskStatus.BLOCKED:
            return [
                WorkItemStatus.ACTIVE,
                WorkItemStatus.REVIEW,
            ]

        # CANCELLED handled in _validate_work_item_state() (administrative)
        # ARCHIVED handled in _validate_work_item_state() (administrative)

        # Default: no restrictions (fallback, shouldn't reach here if logic complete)
        return list(WorkItemStatus)

    def _build_work_item_state_error(
        self,
        task: Task,
        work_item: WorkItem,
        new_task_status: TaskStatus,
        required_states: list[WorkItemStatus]
    ) -> str:
        """
        Build actionable error message for work item state violation.

        Creates user-friendly error with:
        - Clear problem statement
        - Current and required states
        - Exact CLI command to fix

        Args:
            task: Task being transitioned
            work_item: Parent work item
            new_task_status: Desired task status
            required_states: List of required work item states

        Returns:
            Formatted error message with fix command
        """
        # Map task status to action description
        action_map = {
            TaskStatus.READY: "validate task",
            TaskStatus.ACTIVE: "accept task",
            TaskStatus.ACTIVE: "start task",
            TaskStatus.REVIEW: "submit task for review",
            TaskStatus.DONE: "complete task",
            TaskStatus.BLOCKED: "block task",
        }
        action = action_map.get(
            new_task_status,
            f"transition task to {new_task_status.value}"
        )

        # Determine primary required state (most likely fix)
        primary_required = self._get_primary_required_state(
            work_item.status,
            required_states
        )

        # Map work item state to fix command
        fix_command_map = {
            WorkItemStatus.READY: f"apm work-item validate {work_item.id}",
            WorkItemStatus.ACTIVE: f"apm work-item accept {work_item.id}",
            WorkItemStatus.ACTIVE: f"apm work-item start {work_item.id}",
            WorkItemStatus.REVIEW: f"apm work-item submit-review {work_item.id}",
            WorkItemStatus.DONE: f"apm work-item complete {work_item.id}",
        }
        fix_command = fix_command_map.get(
            primary_required,
            f"apm work-item show {work_item.id}"
        )

        # Build error message
        return (
            f"\n❌ Cannot {action}: Work item #{work_item.id} must be "
            f"'{primary_required.value}' (currently '{work_item.status.value}')\n\n"
            f"Fix: {fix_command}\n"
        )

    def _get_primary_required_state(
        self,
        current_wi_status: WorkItemStatus,
        required_states: list[WorkItemStatus]
    ) -> WorkItemStatus:
        """
        Get the most actionable required state for fix command.

        Returns the immediate next state in workflow progression.

        Args:
            current_wi_status: Current work item status
            required_states: List of states that would satisfy validation

        Returns:
            Most actionable required state for error message

        Example:
            >>> # Work item is ACTIVE, task needs ACTIVE or later
            >>> self._get_primary_required_state(
            ...     WorkItemStatus.ACTIVE,
            ...     [WorkItemStatus.ACTIVE, WorkItemStatus.REVIEW, WorkItemStatus.DONE]
            ... )
            WorkItemStatus.ACTIVE  # Next step in progression
        """
        # State progression order (normal workflow)
        progression = [
            WorkItemStatus.DRAFT,
            WorkItemStatus.READY,
            WorkItemStatus.ACTIVE,
            WorkItemStatus.ACTIVE,
            WorkItemStatus.REVIEW,
            WorkItemStatus.DONE,
        ]

        # Find current position in progression
        try:
            current_idx = progression.index(current_wi_status)
        except ValueError:
            # Current state not in normal progression (blocked, cancelled, archived)
            # Return first required state as best guess
            return required_states[0] if required_states else WorkItemStatus.ACTIVE

        # Find first required state after current position
        for state in progression[current_idx + 1:]:
            if state in required_states:
                return state

        # If none found after current, return first required state
        return required_states[0] if required_states else WorkItemStatus.ACTIVE

    # ========== RULE ENFORCEMENT ==========

    def _check_rules(
        self,
        entity_type: EntityType,
        entity: Task | WorkItem,
        transition: dict[str, str]
    ) -> None:
        """Check applicable rules before workflow transition.

        Args:
            entity_type: TASK or WORK_ITEM
            entity: The task or work item being transitioned
            transition: {'from': old_status, 'to': new_status}

        Raises:
            WorkflowError: If BLOCK-level rule violated

        Side Effects:
            - Prints warnings for LIMIT rules (via Rich console)
            - Prints info for GUIDE rules (via Rich console)
        """
        from ..database.methods import rules as rule_methods
        from ..database.methods import work_items as work_item_methods

        # Get project ID
        if entity_type == EntityType.TASK:
            work_item = work_item_methods.get_work_item(self.db, entity.work_item_id)
            if not work_item:
                return  # Can't load work item, skip rules
            project_id = work_item.project_id
        else:  # WORK_ITEM
            project_id = entity.project_id

        # Load project rules (enabled only)
        try:
            rules = rule_methods.list_rules(self.db, project_id=project_id, enabled_only=True)
        except Exception as exc:
            # Rule loading failed - fail open (don't block)
            return

        # If no rules exist, load default rules
        if not rules:
            self._ensure_default_rules_loaded(project_id)
            try:
                rules = rule_methods.list_rules(self.db, project_id=project_id, enabled_only=True)
            except Exception as exc:
                # Still fail open if we can't load rules
                return

        if not rules:
            return  # Still no rules configured

        # Evaluate rules by enforcement level
        violations = []
        warnings = []
        guides = []

        for rule in rules:
            result = self._evaluate_rule(rule, entity, transition)

            if result['violated']:
                if rule.enforcement_level == EnforcementLevel.BLOCK:
                    violations.append((rule, result))
                elif rule.enforcement_level == EnforcementLevel.LIMIT:
                    warnings.append((rule, result))
                elif rule.enforcement_level == EnforcementLevel.GUIDE:
                    guides.append((rule, result))

        # Handle BLOCK violations
        if violations:
            error_msg = self._format_blocking_error(violations)
            raise WorkflowError(error_msg)

        # Show LIMIT warnings
        if warnings:
            self._show_warnings(warnings)

        # Show GUIDE information
        if guides:
            self._show_guidance(guides)

    def _ensure_default_rules_loaded(self, project_id: int) -> None:
        """Ensure default rules are loaded for the project.
        
        Loads minimal default rules if no rules exist in the database.
        This ensures workflow validation always has rules to work with.
        
        Args:
            project_id: Project ID to load rules for
        """
        try:
            from ..rules import DefaultRulesLoader
            
            loader = DefaultRulesLoader(self.db)
            loader.load_defaults(project_id=project_id, overwrite=False)
        except Exception:
            # If we can't load default rules, that's OK - workflow will continue
            # without rule enforcement (fail open)
            pass

    def _evaluate_rule(
        self,
        rule,
        entity: Task | WorkItem,
        transition: dict[str, str]
    ) -> dict[str, Any]:
        """Evaluate if entity/transition violates a rule.

        Args:
            rule: Rule to check
            entity: Task or WorkItem being evaluated
            transition: Status transition details

        Returns:
            {
                'violated': bool,
                'message': str (if violated),
                'current': Any (actual value),
                'required': Any (required value),
                'remediation': str (if violated)
            }
        """
        import re

        if not rule.validation_logic:
            return {'violated': False}

        logic = rule.validation_logic

        # Pattern 1: Time-boxing rules (from config)
        if rule.config and 'max_hours' in rule.config and isinstance(entity, Task):
            limit = rule.config['max_hours']
            task_type = rule.config.get('task_type', 'ALL')
            
            # Check if this rule applies to this task type
            # Note: Case-insensitive comparison needed because entity.type.value is lowercase
            # (e.g., "implementation") while task_type from config is uppercase (e.g., "IMPLEMENTATION")
            if task_type == 'ALL' or (hasattr(entity, 'type') and entity.type.value.upper() == task_type):
                if entity.effort_hours and entity.effort_hours > limit:
                    return {
                        'violated': True,
                        'message': rule.error_message or f"{entity.type.value} tasks limited to {limit} hours",
                        'current': f"{entity.effort_hours}h",
                        'required': f"≤ {limit}h",
                        'remediation': f"Break task into smaller units (<= {limit}h each)"
                    }

        # Pattern 1b: Legacy time-boxing rules (from validation_logic)
        # IMPORTANT: Skip if Pattern 1 already handled this rule (config-based time-boxing)
        # This prevents duplicate checking where BOTH patterns apply the same rule to ALL tasks
        if 'effort_hours >' in logic and isinstance(entity, Task):
            # If rule has task_type filter in config, respect it in Pattern 1b too
            if rule.config and 'task_type' in rule.config:
                task_type = rule.config['task_type']
                # Skip if rule doesn't apply to this task type
                if task_type != 'ALL' and entity.type.value.upper() != task_type:
                    # Rule has task type filter and doesn't match - skip Pattern 1b
                    pass
                else:
                    # Rule applies to this task type - check effort limit
                    match = re.search(r'effort_hours > ([\d.]+)', logic)
                    if match:
                        limit = float(match.group(1))
                        if entity.effort_hours and entity.effort_hours > limit:
                            return {
                                'violated': True,
                                'message': rule.error_message or f"{entity.type.value} tasks limited to {limit} hours",
                                'current': f"{entity.effort_hours}h",
                                'required': f"≤ {limit}h",
                                'remediation': f"Break task into smaller units (<= {limit}h each)"
                            }
            else:
                # No task_type filter in config - apply to all tasks (legacy behavior)
                match = re.search(r'effort_hours > ([\d.]+)', logic)
                if match:
                    limit = float(match.group(1))
                    if entity.effort_hours and entity.effort_hours > limit:
                        return {
                            'violated': True,
                            'message': rule.error_message or f"{entity.type.value} tasks limited to {limit} hours",
                            'current': f"{entity.effort_hours}h",
                            'required': f"≤ {limit}h",
                            'remediation': f"Break task into smaller units (<= {limit}h each)"
                        }

        # Pattern 2: Test coverage (only for TESTING tasks)
        if 'test_coverage <' in logic and isinstance(entity, Task) and entity.type == TaskType.TESTING:
            match = re.search(r'test_coverage < ([\d.]+)', logic)
            if match:
                threshold = float(match.group(1))
                coverage = entity.quality_metadata.get('coverage_percent', 0) if entity.quality_metadata else 0
                if coverage < threshold:
                    return {
                        'violated': True,
                        'message': rule.error_message or f"Test coverage must be >= {threshold}%",
                        'current': f"{coverage}%",
                        'required': f">= {threshold}%",
                        'remediation': f"Add tests to reach {threshold}% coverage threshold"
                    }

        # Pattern 2b: Category-specific coverage (only for TESTING tasks)
        if 'category_coverage(' in logic and isinstance(entity, Task) and entity.type == TaskType.TESTING:
            match = re.search(r'category_coverage\("([^"]+)"\) < ([\w.]+)', logic)
            if match:
                category_name = match.group(1)
                min_coverage_var = match.group(2)
                
                # Get min_coverage from rule config
                min_coverage = rule.config.get('min_coverage', 95.0) if rule.config else 95.0
                
                # Get project path for validation
                project_path = "."
                if hasattr(entity, 'work_item_id'):
                    try:
                        from ..database.methods import work_items as work_item_methods
                        work_item = work_item_methods.get_work_item(self.db, entity.work_item_id)
                        if work_item:
                            from ..database.methods import projects as project_methods
                            project = project_methods.get_project(self.db, work_item.project_id)
                            if project and project.path:
                                project_path = project.path
                    except Exception:
                        pass  # Use default project path
                
                # Validate category coverage for this specific testing task
                try:
                    from ..workflow.validation_functions import task_specific_coverage_validation
                    coverage_met = task_specific_coverage_validation(
                        entity, category_name, min_coverage, project_path, 
                        rule.config.get('path_patterns') if rule.config else None
                    )
                    
                    if not coverage_met:
                        return {
                            'violated': True,
                            'message': rule.error_message or f"Testing task must achieve >= {min_coverage}% coverage for {category_name.replace('_', ' ')} code",
                            'current': f"Below {min_coverage}%",
                            'required': f">= {min_coverage}%",
                            'remediation': f"Add tests for the specific {category_name.replace('_', ' ')} code this task is testing"
                        }
                except Exception as e:
                    # If validation fails, don't block the workflow
                    print(f"Warning: Task-specific coverage validation failed: {e}")
                    pass

        # Pattern 3: Legacy task type requirements (deprecated - now handled by phase gates)
        # These patterns are no longer used in the new status/phase-based workflow
        if 'missing_required_task_types' in logic or 'has_forbidden_task_types' in logic:
            # Skip these legacy validations - they're handled by the new phase gate system
            pass

        # No violation detected
        return {'violated': False}

    def _format_blocking_error(
        self,
        violations: list[tuple[Any, dict[str, Any]]]
    ) -> str:
        """Format blocking error with multiple violations.

        Args:
            violations: List of (rule, result) tuples

        Returns:
            Formatted multi-line error message
        """
        lines = ["Blocked by governance rules:", ""]

        for rule, result in violations:
            lines.append(f"❌ {rule.rule_id}: {result['message']}")

            if 'current' in result:
                lines.append(f"   Current: {result['current']}")
            if 'required' in result:
                lines.append(f"   Required: {result['required']}")
            if 'remediation' in result:
                lines.append(f"   Fix: {result['remediation']}")

            lines.append("")  # Blank line between violations

        lines.append(f"💡 View rules: apm rules show <rule-id>")

        return "\n".join(lines)

    def _show_warnings(self, warnings: list[tuple[Any, dict[str, Any]]]) -> None:
        """Display LIMIT-level warnings (non-blocking)."""
        from rich.console import Console

        console = Console()
        console.print("\n[yellow]⚠️  Rule Warnings:[/yellow]")

        for rule, result in warnings:
            console.print(f"  [yellow]{rule.rule_id}[/yellow]: {result['message']}")
            if 'current' in result:
                console.print(f"    Current: {result['current']}")

        console.print("[dim]These are warnings - operation will proceed[/dim]\n")

    def _show_guidance(self, guides: list[tuple[Any, dict[str, Any]]]) -> None:
        """Display GUIDE-level information."""
        from rich.console import Console

        console = Console()
        console.print("\n[cyan]ℹ️  Guidelines:[/cyan]")

        for rule, result in guides:
            console.print(f"  [cyan]{rule.rule_id}[/cyan]: {result['message']}")

        console.print("[dim]These are recommendations - no enforcement[/dim]\n")

    # ========== PHASE-STATUS ALIGNMENT VALIDATION ==========

    def _validate_phase_status_alignment(
        self,
        work_item: WorkItem,
        new_status: WorkItemStatus
    ) -> None:
        """
        Validate that status transition aligns with current phase for work item type.

        Uses type-specific phase-status mappings to validate combinations.
        Administrative states (BLOCKED, CANCELLED) are always allowed.

        Args:
            work_item: Work item entity (must have phase and type)
            new_status: Desired new status

        Raises:
            WorkflowError: If phase-status combination is invalid for work item type

        Example:
            >>> # ANALYSIS work item in P1_PLAN trying to go ACTIVE (allowed)
            >>> self._validate_phase_status_alignment(wi, WorkItemStatus.ACTIVE)
            # Passes validation
            
            >>> # FEATURE work item in P1_PLAN trying to go ACTIVE (forbidden)
            >>> self._validate_phase_status_alignment(wi, WorkItemStatus.ACTIVE)
            # Raises: "FEATURE work item in P1_PLAN phase cannot be ACTIVE..."
        """
        # Administrative states are always allowed (override phase)
        if new_status in {WorkItemStatus.BLOCKED, WorkItemStatus.CANCELLED}:
            return

        # Get type-specific valid combinations
        type_mapping = self.TYPE_PHASE_STATUS_MAPPING.get(work_item.type)
        if not type_mapping:
            # Unknown work item type - allow transition (backward compatibility)
            return

        # Check if current phase allows this status
        valid_statuses = type_mapping.get(work_item.phase, [])
        if new_status not in valid_statuses:
            # Build helpful error message
            phase_name = work_item.phase.name if work_item.phase else "NULL"
            status_name = new_status.value
            type_name = work_item.type.value.upper()
            valid_status_list = [s.value for s in valid_statuses]

            raise WorkflowError(
                f"\n❌ Invalid phase-status combination: {type_name} work item in {phase_name} phase cannot be '{status_name}'\n\n"
                f"Valid statuses for {type_name} work items in {phase_name} phase: {', '.join(valid_status_list)}\n\n"
                f"Fix: Use appropriate status for current phase or advance to next phase\n"
                f"   Phase advancement: apm work-item next {work_item.id}\n"
                f"   Status info: apm work-item phase-status {work_item.id}\n"
            )

    def _validate_phase_gate(
        self,
        work_item: WorkItem,
        new_status: WorkItemStatus
    ) -> ValidationResult:
        """
        Validate phase gate requirements before status transition.

        Uses PhaseValidator to check if work item can progress based on
        current phase completion requirements.

        Args:
            work_item: Work item entity (must have phase and type)
            new_status: Desired new status

        Returns:
            ValidationResult with pass/fail and missing requirements

        Example:
            >>> # Work item in P1_PLAN trying to go ACTIVE (needs I1)
            >>> result = self._validate_phase_gate(wi, WorkItemStatus.ACTIVE)
            >>> if not result.valid:
            >>>     print(result.reason)  # "Planning phase not complete..."
        """
        # Administrative states bypass phase gates
        if new_status in {WorkItemStatus.BLOCKED, WorkItemStatus.CANCELLED}:
            return ValidationResult(valid=True)

        # Status transitions that require phase advancement
        # These trigger phase gate validation
        phase_advancement_transitions = {
            WorkItemStatus.DRAFT: WorkItemStatus.READY,       # D1 → P1
            WorkItemStatus.READY: WorkItemStatus.ACTIVE,      # P1 → I1
            WorkItemStatus.ACTIVE: WorkItemStatus.REVIEW,     # I1 → R1
            WorkItemStatus.REVIEW: WorkItemStatus.DONE,       # R1 → O1
            WorkItemStatus.DONE: WorkItemStatus.ARCHIVED,     # O1 → E1
        }

        # Check if this transition requires phase advancement
        current_to_new = (work_item.status, new_status)
        requires_advancement = (current_to_new in phase_advancement_transitions.items())

        if not requires_advancement:
            # Status change doesn't require phase advancement
            return ValidationResult(valid=True)

        # Get next allowed phase for this work item type
        next_phase = self.phase_validator.get_next_allowed_phase(work_item)

        if not next_phase:
            # Already at final phase - check if this is a valid status transition for final phase
            # Use type-aware validation to check if this status is allowed for this phase
            type_mapping = self.TYPE_PHASE_STATUS_MAPPING.get(work_item.type, {})
            valid_statuses = type_mapping.get(work_item.phase, [])
            
            if new_status in valid_statuses:
                # This status is valid for the final phase of this work item type
                return ValidationResult(valid=True)
            
            # Cannot transition to this status at final phase
            valid_status_list = [s.value for s in valid_statuses]
            return ValidationResult(
                valid=False,
                reason=(
                    f"Work item already at final phase ({work_item.phase.name}). "
                    f"Cannot transition to {new_status.value}.\n\n"
                    f"Valid statuses for {work_item.type.value.upper()} work items in {work_item.phase.name} phase: {', '.join(valid_status_list)}"
                )
            )

        # Validate phase transition requirements
        phase_validation = self.phase_validator.validate_transition(work_item, next_phase)

        if not phase_validation.is_valid:
            # Phase gate not passed - cannot advance status
            return ValidationResult(
                valid=False,
                reason=(
                    f"Cannot transition to {new_status.value}: "
                    f"Phase gate validation failed\n\n"
                    f"{phase_validation.error_message}\n\n"
                    f"Fix: Complete phase requirements before status transition\n"
                    f"   apm work-item phase-status {work_item.id}  # View requirements\n"
                    f"   apm work-item next {work_item.id}  # Advance when ready\n"
                )
            )

        # Phase gate passed - allow status transition
        return ValidationResult(valid=True)

    # ========== SESSION TRACKING (WI-35) ==========

    def _track_session_activity(
        self,
        task: Task,
        new_status: TaskStatus,
        old_status: TaskStatus
    ) -> None:
        """
        Automatically track task work in current session.

        Updates session metadata when tasks are worked on or completed.
        Fails gracefully if no active session.

        Args:
            task: Task entity (after transition)
            new_status: New status
            old_status: Previous status
        """
        from ..database.methods import sessions as session_methods

        try:
            # Check if there's an active session
            session = session_methods.get_current_session(self.db)

            if not session:
                # No active session - this is OK (manual CLI usage without session)
                return

            # Track work item touch (any task activity)
            session_methods.update_current_session(
                self.db,
                work_item_touched=task.work_item_id
            )

            # Track task completion
            if new_status == TaskStatus.DONE and old_status != TaskStatus.DONE:
                session_methods.update_current_session(
                    self.db,
                    task_completed=task.id
                )

        except Exception:
            # Session tracking failure should not break workflow
            # This is enhancement, not core functionality
            pass

    # ========== EVENT EMISSION (WI-35 Task #173) ==========

    def _emit_workflow_event(
        self,
        entity_type: str,
        entity_id: int,
        entity_name: str,
        previous_status: str,
        new_status: str,
        work_item_id: Optional[int] = None,
        project_id: Optional[int] = None,
        agent_assigned: Optional[str] = None
    ) -> None:
        """
        Emit workflow event to EventBus for automatic capture.

        NEW (WI-35 Task #173): Integrates workflow state changes with event system.

        Args:
            entity_type: "task" or "work_item"
            entity_id: Entity ID
            entity_name: Entity name
            previous_status: Previous status value
            new_status: New status value
            work_item_id: Work item ID (for task events)
            project_id: Project ID (for event filtering)
            agent_assigned: Agent role (for task events)

        Graceful degradation: Event emission failures don't block workflow.
        """
        from ..database.methods import sessions as session_methods
        from ..sessions.event_bus import EventBus
        from ..events.models import Event, EventType, EventCategory, EventSeverity

        try:
            # Get current session (required for event tracking)
            session = session_methods.get_current_session(self.db)
            if not session:
                # No active session - skip event emission
                # This is OK for manual CLI usage outside session
                return

            # Map entity transitions to event types
            event_type_map = {
                ('task', 'in_progress'): EventType.TASK_STARTED,
                ('task', 'completed'): EventType.TASK_DONE,
                ('task', 'blocked'): EventType.TASK_BLOCKED,
                ('work_item', 'in_progress'): EventType.WORK_ITEM_STARTED,
                ('work_item', 'completed'): EventType.WORK_ITEM_DONE,
            }

            # Determine event type
            event_type = event_type_map.get(
                (entity_type, new_status),
                None  # Generic transition (not mapped to specific event type)
            )

            if not event_type:
                # Not a notable transition, skip event emission
                return

            # Create workflow event
            event = Event(
                event_type=event_type,
                event_category=EventCategory.WORKFLOW,
                event_severity=EventSeverity.INFO,
                session_id=session.id,
                source='workflow_service',
                event_data={
                    'entity_type': entity_type,
                    'entity_id': entity_id,
                    'entity_name': entity_name,
                    'previous_status': previous_status,
                    'new_status': new_status,
                    'agent_assigned': agent_assigned
                },
                project_id=project_id,
                work_item_id=work_item_id,
                task_id=entity_id if entity_type == 'task' else None
            )

            # Emit event (non-blocking, background persistence)
            event_bus = EventBus(self.db)
            event_bus.emit(event)
            # Note: Don't shutdown here - EventBus runs as daemon thread
            # Will auto-shutdown when process exits

        except Exception:
            # Event emission failure should not break workflow
            # This is enhancement, not core functionality
            pass

    # ========== HOOK INTEGRATION (Task #147) ==========

    def _trigger_task_start_hook(self, task: Task) -> None:
        """
        Trigger TaskStart hook to assemble context using Context Delivery Agent.

        Called when task transitions to ACTIVE state.
        Writes context to .agentpm/contexts/task_{id}_context.md

        Args:
            task: Updated task entity (after transition)

        Note:
            This is a fire-and-forget operation. Hook failures don't block workflow.
            Context assembly happens asynchronously via hook system.
        """
        import subprocess
        import json
        from pathlib import Path

        try:
            # Check if TaskStart hook exists
            hook_path = Path('.claude/hooks/task-start.py')

            if not hook_path.exists():
                # Hook not installed - this is not an error (hooks are optional)
                # Context can still be accessed via `apm context show`
                return

            # Prepare hook input
            hook_input = {
                'task_id': task.id,
                'agent_role': task.assigned_to,
                'session_id': 'workflow-transition'
            }

            # Execute hook (asynchronous - don't wait for completion)
            # Hook output is written to .agentpm/contexts/task_{id}_context.md
            subprocess.Popen(
                ['python3', str(hook_path)],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            ).communicate(input=json.dumps(hook_input), timeout=1.0)

            # Note: We don't check hook success - this is intentional
            # Hooks are enhancement, not core functionality
            # If hook fails, context is still accessible via CLI

        except subprocess.TimeoutExpired:
            # Hook took >1s - this is acceptable (continues in background)
            pass

        except Exception:
            # Hook execution failed - gracefully continue
            # This is not a workflow-blocking error
            pass
