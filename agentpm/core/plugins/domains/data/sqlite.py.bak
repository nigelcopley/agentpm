"""
SQLite Plugin - Database Context Extraction

Extracts SQLite database schema, tables, and configuration.

Provides:
1. Project facts (database location, schema version, tables, indexes)
2. Code amalgamations (schema DDL, migration history)

Pattern: BasePlugin implementation
"""

from pathlib import Path
from typing import Dict, Any, List, Optional
import sqlite3

from ...base.plugin_interface import BasePlugin
from ...base.types import PluginCategory
from ...utils import filter_project_files


class SQLitePlugin(BasePlugin):
    """
    SQLite database plugin for context extraction.

    Provides:
    1. Database facts (location, schema, tables, indexes)
    2. Schema amalgamations (DDL, migrations)
    """

    @property
    def plugin_id(self) -> str:
        return "data:sqlite"

    @property
    def enriches(self) -> str:
        return "sqlite"

    @property
    def category(self) -> PluginCategory:
        return PluginCategory.DATA

    def detect(self, project_path: Path) -> float:
        """Detect SQLite database presence."""
        confidence = 0.0

        # Phase 1: Files - Look for .db, .sqlite, .sqlite3 files
        db_extensions = ['*.db', '*.sqlite', '*.sqlite3']
        for pattern in db_extensions:
            if list(project_path.glob(f"**/{pattern}")):
                confidence += 0.15
                break

        # Phase 2: Imports - Check for sqlite3 imports
        py_files = list(project_path.glob("**/*.py"))[:10]
        for py_file in py_files:
            try:
                content = py_file.read_text()
                if "import sqlite3" in content or "from sqlite3" in content:
                    confidence += 0.40
                    break
            except Exception:
                continue

        # Phase 3: Structure - Check for typical SQLite usage patterns
        for py_file in py_files[:5]:
            try:
                content = py_file.read_text()
                if ".db" in content or "sqlite" in content.lower():
                    confidence += 0.15
                    break
            except Exception:
                continue

        return min(confidence, 1.0)

    def extract_project_facts(self, project_path: Path) -> Dict[str, Any]:
        """
        Extract SQLite database facts.

        Returns database configuration and schema information.
        """
        facts = {}

        # Find database files
        db_files = self._find_database_files(project_path)
        facts['database_files'] = db_files

        if db_files:
            # Analyze first database
            primary_db = project_path / db_files[0]
            facts['primary_database'] = db_files[0]

            # Extract schema info
            schema_info = self._extract_schema_info(primary_db)
            facts.update(schema_info)
        else:
            facts['primary_database'] = None

        return facts

    def generate_code_amalgamations(self, project_path: Path) -> Dict[str, str]:
        """
        Generate SQLite schema amalgamations.

        Returns database schema DDL and structure.
        """
        amalgamations = {}

        # Find database files
        db_files = self._find_database_files(project_path)

        if db_files:
            primary_db = project_path / db_files[0]

            # Generate schema DDL
            amalgamations['schema'] = self._generate_schema_ddl(primary_db)

            # Generate table list with details
            amalgamations['tables'] = self._generate_table_details(primary_db)

            # Generate index information
            amalgamations['indexes'] = self._generate_index_details(primary_db)
        else:
            amalgamations['schema'] = "# No SQLite database found\n"
            amalgamations['tables'] = "# No SQLite database found\n"
            amalgamations['indexes'] = "# No SQLite database found\n"

        return amalgamations

    # ========== Fact Extraction Helpers ==========

    def _find_database_files(self, project_path: Path) -> List[str]:
        """Find SQLite database files"""
        db_files = []

        # Common database file patterns
        patterns = ['*.db', '*.sqlite', '*.sqlite3', '*.db3']

        for pattern in patterns:
            for db_file in project_path.glob(f'**/{pattern}'):
                # Exclude test databases and venv
                if 'test' not in str(db_file) and 'venv' not in str(db_file):
                    db_files.append(str(db_file.relative_to(project_path)))

        # Check common locations
        common_locs = ['.agentpm/agentpm.db', 'data/app.db', 'db/database.sqlite']
        for loc in common_locs:
            if (project_path / loc).exists():
                if loc not in db_files:
                    db_files.append(loc)

        return sorted(db_files)

    def _extract_schema_info(self, db_path: Path) -> Dict[str, Any]:
        """Extract schema information from database"""
        info = {}

        try:
            conn = sqlite3.connect(str(db_path))

            # Get tables
            cursor = conn.execute("""
                SELECT name FROM sqlite_master
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
                ORDER BY name
            """)
            tables = [row[0] for row in cursor.fetchall()]

            info['tables'] = tables
            info['table_count'] = len(tables)

            # Get indexes
            cursor = conn.execute("""
                SELECT name FROM sqlite_master
                WHERE type='index' AND name NOT LIKE 'sqlite_%'
                ORDER BY name
            """)
            indexes = [row[0] for row in cursor.fetchall()]
            info['indexes'] = indexes
            info['index_count'] = len(indexes)

            # Check for schema_migrations table
            if 'schema_migrations' in tables:
                cursor = conn.execute("""
                    SELECT version FROM schema_migrations
                    ORDER BY applied_at DESC LIMIT 1
                """)
                row = cursor.fetchone()
                info['schema_version'] = row[0] if row else None
            else:
                info['schema_version'] = None

            # Foreign keys enabled?
            cursor = conn.execute("PRAGMA foreign_keys")
            fk_row = cursor.fetchone()
            info['foreign_keys_enabled'] = bool(fk_row and fk_row[0] == 1)

            conn.close()

        except sqlite3.Error as e:
            info['error'] = str(e)

        return info

    # ========== Code Amalgamation Helpers ==========

    def _generate_schema_ddl(self, db_path: Path) -> str:
        """Generate complete schema DDL"""
        content = "# SQLite Schema DDL\n"
        content += f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        content += f"# Database: {db_path.name}\n\n"

        try:
            conn = sqlite3.connect(str(db_path))

            # Get CREATE statements for all tables
            cursor = conn.execute("""
                SELECT sql FROM sqlite_master
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
                ORDER BY name
            """)

            for row in cursor.fetchall():
                if row[0]:
                    content += row[0] + ';\n\n'

            # Get CREATE statements for all indexes
            cursor = conn.execute("""
                SELECT sql FROM sqlite_master
                WHERE type='index' AND name NOT LIKE 'sqlite_%' AND sql IS NOT NULL
                ORDER BY name
            """)

            content += "-- Indexes\n"
            for row in cursor.fetchall():
                if row[0]:
                    content += row[0] + ';\n'

            conn.close()

        except sqlite3.Error as e:
            content += f"\n-- Error reading schema: {e}\n"

        return content

    def _generate_table_details(self, db_path: Path) -> str:
        """Generate table details (columns, types)"""
        content = "# SQLite Table Details\n"
        content += f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"

        try:
            conn = sqlite3.connect(str(db_path))

            # Get all tables
            cursor = conn.execute("""
                SELECT name FROM sqlite_master
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
                ORDER BY name
            """)
            tables = [row[0] for row in cursor.fetchall()]

            for table in tables:
                content += f"\n## Table: {table}\n"

                # Get columns
                cursor = conn.execute(f"PRAGMA table_info({table})")
                columns = cursor.fetchall()

                content += "Columns:\n"
                for col in columns:
                    col_id, name, type_, notnull, default, pk = col
                    pk_marker = " PRIMARY KEY" if pk else ""
                    null_marker = " NOT NULL" if notnull else ""
                    default_marker = f" DEFAULT {default}" if default else ""
                    content += f"  - {name}: {type_}{pk_marker}{null_marker}{default_marker}\n"

                # Get foreign keys
                cursor = conn.execute(f"PRAGMA foreign_key_list({table})")
                fks = cursor.fetchall()
                if fks:
                    content += "Foreign Keys:\n"
                    for fk in fks:
                        content += f"  - {fk[3]} REFERENCES {fk[2]}({fk[4]})\n"

                # Get row count
                try:
                    cursor = conn.execute(f"SELECT COUNT(*) FROM {table}")
                    count = cursor.fetchone()[0]
                    content += f"Row Count: {count}\n"
                except:
                    pass

            conn.close()

        except sqlite3.Error as e:
            content += f"\n-- Error: {e}\n"

        return content

    def _generate_index_details(self, db_path: Path) -> str:
        """Generate index details"""
        content = "# SQLite Indexes\n"
        content += f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"

        try:
            conn = sqlite3.connect(str(db_path))

            # Get all indexes
            cursor = conn.execute("""
                SELECT name, tbl_name, sql FROM sqlite_master
                WHERE type='index' AND name NOT LIKE 'sqlite_%'
                ORDER BY tbl_name, name
            """)

            current_table = None
            for row in cursor.fetchall():
                index_name, table_name, sql = row

                if table_name != current_table:
                    content += f"\n## Table: {table_name}\n"
                    current_table = table_name

                if sql:
                    content += f"{sql};\n"
                else:
                    content += f"-- {index_name} (auto-generated)\n"

            conn.close()

        except sqlite3.Error as e:
            content += f"\n-- Error: {e}\n"

        return content


# Import datetime for timestamps
from datetime import datetime