"""
Work Items Blueprint for APM (Agent Project Manager) Web Application

Comprehensive work items and tasks management functionality.
"""

from flask import Blueprint, render_template, abort, request, redirect, url_for, jsonify, flash
import logging
from datetime import datetime

# Create work items blueprint
work_items_bp = Blueprint('work_items', __name__, url_prefix='/work-items')

logger = logging.getLogger(__name__)

def get_database_service():
    """Get database service instance with robust path resolution"""
    from ...core.database.service import DatabaseService
    import os
    
    # Try different database paths
    db_paths = [
        '.agentpm/data/agentpm.db',
        '../.agentpm/data/agentpm.db',
        '../../.agentpm/data/agentpm.db'
    ]
    
    for db_path in db_paths:
        if os.path.exists(db_path):
            return DatabaseService(db_path)
    
    # If no database found, return service with default path
    return DatabaseService('.agentpm/data/agentpm.db')

def _is_htmx_request():
    """Check if request is from HTMX"""
    return request.headers.get('HX-Request') == 'true'

@work_items_bp.route('/')
def work_items_list():
    """Work items list view with comprehensive metrics, filtering, and search"""
    db = get_database_service()
    
    # Get project ID for work items
    from ...core.database.methods import projects, work_items, tasks
    from ...core.database.enums import WorkItemStatus, WorkItemType
    
    projects_list = projects.list_projects(db) or []
    project_id = projects_list[0].id if projects_list else 1
    
    # Get filter parameters
    search_query = request.args.get('search', '').strip()
    status_filter = request.args.get('status', '')
    type_filter = request.args.get('type', '')
    priority_filter = request.args.get('priority', '')
    sort_by = request.args.get('sort', 'updated_desc')
    
    # Get work items and tasks
    work_items_list = work_items.list_work_items(db, project_id=project_id) or []
    tasks_list = tasks.list_tasks(db) or []
    
    # Apply filters
    filtered_work_items = work_items_list
    
    # Search filter
    if search_query:
        filtered_work_items = [
            wi for wi in filtered_work_items
            if search_query.lower() in (wi.name or '').lower() or 
               search_query.lower() in (wi.description or '').lower()
        ]
    
    # Status filter
    if status_filter:
        filtered_work_items = [
            wi for wi in filtered_work_items
            if wi.status and wi.status.value == status_filter
        ]
    
    # Type filter
    if type_filter:
        filtered_work_items = [
            wi for wi in filtered_work_items
            if wi.type and wi.type.value == type_filter
        ]
    
    # Priority filter
    if priority_filter:
        try:
            priority = int(priority_filter)
            filtered_work_items = [
                wi for wi in filtered_work_items
                if wi.priority == priority
            ]
        except ValueError:
            pass
    
    # Apply sorting
    if sort_by == 'name_asc':
        filtered_work_items.sort(key=lambda x: (x.name or '').lower())
    elif sort_by == 'name_desc':
        filtered_work_items.sort(key=lambda x: (x.name or '').lower(), reverse=True)
    elif sort_by == 'status_asc':
        filtered_work_items.sort(key=lambda x: x.status.value if x.status else '')
    elif sort_by == 'status_desc':
        filtered_work_items.sort(key=lambda x: x.status.value if x.status else '', reverse=True)
    elif sort_by == 'priority_asc':
        filtered_work_items.sort(key=lambda x: x.priority or 0)
    elif sort_by == 'priority_desc':
        filtered_work_items.sort(key=lambda x: x.priority or 0, reverse=True)
    elif sort_by == 'created_asc':
        filtered_work_items.sort(key=lambda x: x.created_at or datetime.min)
    elif sort_by == 'created_desc':
        filtered_work_items.sort(key=lambda x: x.created_at or datetime.min, reverse=True)
    else:  # updated_desc (default)
        filtered_work_items.sort(key=lambda x: x.updated_at or x.created_at or datetime.min, reverse=True)
    
    # Calculate comprehensive metrics for the sidebar
    metrics = {
        # Basic counts
        'total_work_items': len(work_items_list),
        'total_tasks': len(tasks_list),
        
        # Status-based counts
        'draft_work_items': len([wi for wi in work_items_list if wi.status and wi.status.value == 'draft']),
        'ready_work_items': len([wi for wi in work_items_list if wi.status and wi.status.value == 'ready']),
        'active_work_items': len([wi for wi in work_items_list if wi.status and wi.status.value == 'active']),
        'review_work_items': len([wi for wi in work_items_list if wi.status and wi.status.value == 'review']),
        'blocked_work_items': len([wi for wi in work_items_list if wi.status and wi.status.value == 'blocked']),
        'done_work_items': len([wi for wi in work_items_list if wi.status and wi.status.value == 'done']),
        'archived_work_items': len([wi for wi in work_items_list if wi.status and wi.status.value == 'archived']),
        'cancelled_work_items': len([wi for wi in work_items_list if wi.status and wi.status.value == 'cancelled']),
        
        # Phase-based counts (simplified mapping)
        'phase_d1_discovery': len([wi for wi in work_items_list if wi.status and wi.status.value in ['draft']]),
        'phase_p1_plan': len([wi for wi in work_items_list if wi.status and wi.status.value in ['ready']]),
        'phase_i1_implementation': len([wi for wi in work_items_list if wi.status and wi.status.value in ['active']]),
        'phase_r1_review': len([wi for wi in work_items_list if wi.status and wi.status.value in ['review']]),
        'phase_o1_operations': len([wi for wi in work_items_list if wi.status and wi.status.value in ['done']]),
        'phase_e1_evolution': 0,  # No specific phase for evolution
        
        # Type-based counts
        'feature_work_items': len([wi for wi in work_items_list if wi.type and wi.type.value == 'feature']),
        'enhancement_work_items': len([wi for wi in work_items_list if wi.type and wi.type.value == 'enhancement']),
        'bugfix_work_items': len([wi for wi in work_items_list if wi.type and wi.type.value == 'bugfix']),
        'analysis_work_items': len([wi for wi in work_items_list if wi.type and wi.type.value == 'analysis']),
        'research_work_items': len([wi for wi in work_items_list if wi.type and wi.type.value == 'research']),
        'documentation_work_items': len([wi for wi in work_items_list if wi.type and wi.type.value == 'documentation']),
        'maintenance_work_items': len([wi for wi in work_items_list if wi.type and wi.type.value == 'maintenance']),
        
        # Priority-based counts
        'priority_1_work_items': len([wi for wi in work_items_list if wi.priority == 1]),
        'priority_2_work_items': len([wi for wi in work_items_list if wi.priority == 2]),
        'priority_3_work_items': len([wi for wi in work_items_list if wi.priority == 3]),
    }
    
    # Get available filter options
    filter_options = {
        'statuses': [{'value': status.value, 'label': status.value.replace('_', ' ').title()} 
                    for status in WorkItemStatus],
        'types': [{'value': type_.value, 'label': type_.value.replace('_', ' ').title()} 
                 for type_ in WorkItemType],
        'priorities': [{'value': str(i), 'label': f'Priority {i}'} for i in range(1, 6)],
        'sort_options': [
            {'value': 'updated_desc', 'label': 'Last Updated (Newest)'},
            {'value': 'updated_asc', 'label': 'Last Updated (Oldest)'},
            {'value': 'created_desc', 'label': 'Created (Newest)'},
            {'value': 'created_asc', 'label': 'Created (Oldest)'},
            {'value': 'name_asc', 'label': 'Name (A-Z)'},
            {'value': 'name_desc', 'label': 'Name (Z-A)'},
            {'value': 'status_asc', 'label': 'Status (A-Z)'},
            {'value': 'status_desc', 'label': 'Status (Z-A)'},
            {'value': 'priority_asc', 'label': 'Priority (Low to High)'},
            {'value': 'priority_desc', 'label': 'Priority (High to Low)'},
        ]
    }
    
    # Check if this is an HTMX request for dynamic filtering
    if _is_htmx_request():
        # Return only the content that should be updated
        return render_template('work-items/partials/work_items_content.html', 
                             work_items=filtered_work_items,
                             metrics=metrics,
                             filter_options=filter_options,
                             current_filters={
                                 'search': search_query,
                                 'status': status_filter,
                                 'type': type_filter,
                                 'priority': priority_filter,
                                 'sort': sort_by
                             })
    
    # Return full page for regular requests
    return render_template('work-items/list.html', 
                         work_items=filtered_work_items,
                         metrics=metrics,
                         filter_options=filter_options,
                         current_filters={
                             'search': search_query,
                             'status': status_filter,
                             'type': type_filter,
                             'priority': priority_filter,
                             'sort': sort_by
                         })

@work_items_bp.route('/<int:work_item_id>')
def work_item_detail(work_item_id: int):
    """
    Comprehensive work item detail view.
    
    Shows all work item information in a single view:
    - Basic information (name, description, status, priority)
    - Task summaries (progress, decisions, etc.)
    - Agent assignments
    - Timeline and history
    - Related work item context
    - Dependencies and relationships
    """
    # Fetch work item data
    db = get_database_service()
    from ...core.database.methods import (
        work_items as wi_methods, 
        tasks as task_methods,
        agents,
        contexts,
        ideas
    )
    from ...core.database.enums import EntityType, ContextType
    
    work_item = wi_methods.get_work_item(db, work_item_id)
    
    if not work_item:
        abort(404, description=f"Work item {work_item_id} not found")
    
    # Get related data
    tasks = task_methods.list_tasks(db, work_item_id=work_item_id) or []
    agents_list = agents.list_agents(db) or []
    
    # Get work item contexts
    work_item_contexts = []
    try:
        work_item_contexts = contexts.get_rich_contexts_by_entity(
            db, EntityType.WORK_ITEM, work_item_id
        ) or []
    except Exception as e:
        logger.warning(f"Error fetching work item contexts: {e}")
    
    # Get related idea if exists
    related_idea = None
    if work_item.originated_from_idea_id:
        try:
            related_idea = ideas.get_idea(db, work_item.originated_from_idea_id)
        except Exception as e:
            logger.warning(f"Error fetching related idea: {e}")
    
    # Get parent work item if exists
    parent_work_item = None
    if work_item.parent_work_item_id:
        try:
            parent_work_item = wi_methods.get_work_item(db, work_item.parent_work_item_id)
        except Exception as e:
            logger.warning(f"Error fetching parent work item: {e}")
    
    # Get child work items
    child_work_items = []
    try:
        all_work_items = wi_methods.list_work_items(db, project_id=work_item.project_id) or []
        child_work_items = [wi for wi in all_work_items if wi.parent_work_item_id == work_item_id]
    except Exception as e:
        logger.warning(f"Error fetching child work items: {e}")
    
    # Calculate task statistics
    tasks_count = len(tasks)
    completed_tasks = sum(1 for task in tasks if task.status and task.status.value == 'done')
    in_progress_tasks = sum(1 for task in tasks if task.status and task.status.value in ['in_progress', 'active'])
    blocked_tasks = sum(1 for task in tasks if task.status and task.status.value == 'blocked')
    pending_tasks = sum(1 for task in tasks if task.status and task.status.value in ['pending', 'ready'])
    
    # Calculate progress percentage
    progress_percentage = 0
    if tasks_count > 0:
        progress_percentage = round((completed_tasks / tasks_count) * 100, 1)
    
    # Get business and technical context
    business_context = None
    technical_context = None
    
    for context in work_item_contexts:
        if context.context_type == ContextType.BUSINESS_PILLARS_CONTEXT:
            business_context = context
        elif context.context_type == ContextType.TECHNICAL_CONTEXT:
            technical_context = context
    
    # Calculate effort statistics
    total_estimated_hours = sum(task.effort_hours or 0 for task in tasks)
    total_logged_hours = 0  # Task model doesn't have logged hours field yet
    
    # Get phase information and requirements
    phase_info = None
    phase_requirements = None
    phase_validation = None
    phase_content = {}
    
    try:
        from ...core.workflow.phase_validator import PhaseValidator
        from ...core.database.enums import Phase, TaskType, ContextType
        
        # Get phase validator instance
        phase_validator = PhaseValidator()
        
        # Get phase requirements for this work item type
        if work_item.phase:
            phase_requirements = phase_validator.get_phase_requirements(work_item.phase, work_item.type)
        
        # Get all phases for this work item type
        all_phases = phase_validator.get_allowed_phases(work_item.type)
        
        # Get phase-specific content for each phase
        for phase in all_phases:
            try:
                phase_content[phase.value] = {
                    'tasks': [],
                    'contexts': [],
                    'deliverables': [],
                    'status': 'pending'
                }
                
                # Determine phase status
                if work_item.phase:
                    current_phase_index = all_phases.index(work_item.phase) if work_item.phase in all_phases else -1
                    phase_index = all_phases.index(phase)
                    
                    if phase_index < current_phase_index:
                        phase_content[phase.value]['status'] = 'completed'
                    elif phase_index == current_phase_index:
                        phase_content[phase.value]['status'] = 'current'
                    else:
                        phase_content[phase.value]['status'] = 'pending'
                
                # Get tasks for this phase (filter by task type that typically belongs to this phase)
                phase_task_types = _get_phase_task_types(phase)
                phase_tasks = [task for task in tasks if task.type in phase_task_types]
                phase_content[phase.value]['tasks'] = phase_tasks
                
                # Get contexts for this phase
                phase_contexts = _get_phase_contexts(work_item_contexts, phase)
                phase_content[phase.value]['contexts'] = phase_contexts
                
                # Get deliverables for this phase
                phase_deliverables = _get_phase_deliverables(phase, phase_tasks, phase_contexts)
                phase_content[phase.value]['deliverables'] = phase_deliverables
                
            except Exception as phase_error:
                logger.error(f"Error processing phase {phase.value}: {phase_error}")
                # Continue with other phases
        
        # Create phase information structure
        phase_info = {
            'current_phase': work_item.phase,
            'all_phases': all_phases,
            'phase_requirements': phase_requirements,
            'phase_sequence': all_phases,
            'phase_content': phase_content
        }
        
        # Validate current phase if it exists
        if work_item.phase:
            validation_result = phase_validator.validate_phase_completion(work_item, work_item.phase)
            phase_validation = {
                'is_valid': validation_result.is_valid,
                'missing_requirements': validation_result.missing_requirements,
                'confidence_score': 0.0  # PhaseValidationResult doesn't have confidence_score
            }
        
    except Exception as e:
        logger.warning(f"Error fetching phase information: {e}")
        import traceback
        logger.error(f"Phase info error traceback: {traceback.format_exc()}")
    
    # Ensure phase_info is created even if there's an error
    if phase_info is None:
        logger.warning("Phase info is None, creating minimal structure")
        phase_info = {
            'current_phase': work_item.phase,
            'all_phases': [],
            'phase_requirements': None,
            'phase_sequence': [],
            'phase_content': {}
        }
    
    return render_template('work-items/detail.html', 
                         work_item=work_item, 
                         work_item_id=work_item_id,
                         tasks=tasks,
                         tasks_count=tasks_count,
                         completed_tasks=completed_tasks,
                         in_progress_tasks=in_progress_tasks,
                         blocked_tasks=blocked_tasks,
                         pending_tasks=pending_tasks,
                         progress_percentage=progress_percentage,
                         work_item_contexts=work_item_contexts,
                         business_context=business_context,
                         technical_context=technical_context,
                         related_idea=related_idea,
                         parent_work_item=parent_work_item,
                         child_work_items=child_work_items,
                         agents=agents_list,
                         total_estimated_hours=total_estimated_hours,
                         total_logged_hours=total_logged_hours,
                         phase_info=phase_info,
                         phase_validation=phase_validation)

def _get_phase_task_types(phase):
    """Get task types that typically belong to each phase"""
    from ...core.database.enums import TaskType
    
    phase_task_mapping = {
        'D1_discovery': [TaskType.ANALYSIS, TaskType.RESEARCH, TaskType.DESIGN],
        'P1_plan': [TaskType.PLANNING, TaskType.DESIGN],
        'I1_implementation': [TaskType.IMPLEMENTATION, TaskType.TESTING, TaskType.DOCUMENTATION],
        'R1_review': [TaskType.REVIEW, TaskType.TESTING],
        'O1_operations': [TaskType.DEPLOYMENT, TaskType.DOCUMENTATION],
        'E1_evolution': [TaskType.ANALYSIS, TaskType.RESEARCH, TaskType.DOCUMENTATION]
    }
    return phase_task_mapping.get(phase.value, [])

def _get_phase_contexts(contexts, phase):
    """Get contexts that belong to each phase"""
    from ...core.database.enums import ContextType
    
    phase_context_mapping = {
        'D1_discovery': [ContextType.BUSINESS_PILLARS_CONTEXT, ContextType.MARKET_RESEARCH_CONTEXT, ContextType.STAKEHOLDER_CONTEXT],
        'P1_plan': [ContextType.TECHNICAL_CONTEXT, ContextType.QUALITY_GATES_CONTEXT],
        'I1_implementation': [ContextType.IMPLEMENTATION_CONTEXT, ContextType.TECHNICAL_CONTEXT],
        'R1_review': [ContextType.QUALITY_GATES_CONTEXT],
        'O1_operations': [ContextType.TECHNICAL_CONTEXT],
        'E1_evolution': [ContextType.BUSINESS_PILLARS_CONTEXT, ContextType.COMPETITIVE_ANALYSIS_CONTEXT]
    }
    
    phase_context_types = phase_context_mapping.get(phase.value, [])
    return [ctx for ctx in contexts if ctx.context_type in phase_context_types]

def _get_phase_deliverables(phase, tasks, contexts):
    """Get deliverables for each phase based on phase requirements"""
    deliverables = []
    
    if phase.value == 'D1_discovery':
        deliverables = [
            {'name': 'Requirements Document', 'status': 'pending', 'description': 'Functional and non-functional requirements'},
            {'name': 'User Personas', 'status': 'pending', 'description': 'Target user definitions and characteristics'},
            {'name': 'Acceptance Criteria', 'status': 'pending', 'description': 'Success criteria (≥3 items required)'},
            {'name': 'Risk Register', 'status': 'pending', 'description': 'Identified risks and mitigation strategies'},
            {'name': 'High-level Architecture', 'status': 'pending', 'description': 'System design and integration points'},
            {'name': 'Technical Feasibility Report', 'status': 'pending', 'description': 'Technology assessment and constraints'}
        ]
    elif phase.value == 'P1_plan':
        deliverables = [
            {'name': 'Detailed Task List', 'status': 'pending', 'description': 'All tasks with estimates (≤8h each)'},
            {'name': 'Dependency Graph', 'status': 'pending', 'description': 'Task dependencies and critical path'},
            {'name': 'Resource Allocation Plan', 'status': 'pending', 'description': 'Agent assignments and skill mapping'},
            {'name': 'Risk Mitigation Plan', 'status': 'pending', 'description': 'Mitigation strategies for identified risks'},
            {'name': 'Timeline/Schedule', 'status': 'pending', 'description': 'Project timeline with milestones'},
            {'name': 'Detailed Design Documents', 'status': 'pending', 'description': 'Technical specifications and architecture'}
        ]
    elif phase.value == 'I1_implementation':
        deliverables = [
            {'name': 'Production Code', 'status': 'pending', 'description': 'Complete implementation'},
            {'name': 'Test Suite', 'status': 'pending', 'description': 'Comprehensive tests (>90% coverage)'},
            {'name': 'Updated Documentation', 'status': 'pending', 'description': 'API docs, usage examples, architecture'},
            {'name': 'Database Migrations', 'status': 'pending', 'description': 'Migration scripts and documentation'},
            {'name': 'Code Review Signoffs', 'status': 'pending', 'description': 'Peer review approvals'}
        ]
    elif phase.value == 'R1_review':
        deliverables = [
            {'name': 'Test Results', 'status': 'pending', 'description': 'All tests passing (100% pass rate)'},
            {'name': 'Acceptance Criteria Validation', 'status': 'pending', 'description': 'All criteria verified'},
            {'name': 'Security Scan Results', 'status': 'pending', 'description': 'Security vulnerabilities addressed'},
            {'name': 'Performance Benchmarks', 'status': 'pending', 'description': 'Performance requirements met'},
            {'name': 'Quality Standards Compliance', 'status': 'pending', 'description': 'Code quality standards met'}
        ]
    elif phase.value == 'O1_operations':
        deliverables = [
            {'name': 'Deployment Scripts', 'status': 'pending', 'description': 'Automated deployment configuration'},
            {'name': 'Monitoring Setup', 'status': 'pending', 'description': 'Health checks and alerting'},
            {'name': 'Operational Documentation', 'status': 'pending', 'description': 'Runbooks and procedures'},
            {'name': 'Rollback Plan', 'status': 'pending', 'description': 'Rollback procedures and testing'},
            {'name': 'Go-live Checklist', 'status': 'pending', 'description': 'Pre-deployment validation'}
        ]
    elif phase.value == 'E1_evolution':
        deliverables = [
            {'name': 'Telemetry Analysis', 'status': 'pending', 'description': 'Usage metrics and performance data'},
            {'name': 'User Feedback Summary', 'status': 'pending', 'description': 'Collected feedback and insights'},
            {'name': 'Improvement Recommendations', 'status': 'pending', 'description': 'Identified enhancements'},
            {'name': 'Technical Debt Assessment', 'status': 'pending', 'description': 'Code quality and maintainability'},
            {'name': 'Lessons Learned', 'status': 'pending', 'description': 'Process improvements and patterns'}
        ]
    
    # Update deliverable status based on available content
    for deliverable in deliverables:
        if _is_deliverable_complete(deliverable, tasks, contexts):
            deliverable['status'] = 'completed'
        elif _is_deliverable_in_progress(deliverable, tasks, contexts):
            deliverable['status'] = 'in_progress'
    
    return deliverables

def _is_deliverable_complete(deliverable, tasks, contexts):
    """Check if a deliverable is complete based on available tasks and contexts"""
    # This is a simplified check - in a real implementation, you'd have more sophisticated logic
    deliverable_name = deliverable['name'].lower()
    
    # Check if there are completed tasks or contexts that indicate this deliverable is done
    for task in tasks:
        if task.status and task.status.value == 'done':
            task_name = task.name.lower()
            if any(keyword in task_name for keyword in deliverable_name.split()):
                return True
    
    return False

def _is_deliverable_in_progress(deliverable, tasks, contexts):
    """Check if a deliverable is in progress based on available tasks and contexts"""
    deliverable_name = deliverable['name'].lower()
    
    # Check if there are active tasks that indicate this deliverable is being worked on
    for task in tasks:
        if task.status and task.status.value in ['active', 'in_progress']:
            task_name = task.name.lower()
            if any(keyword in task_name for keyword in deliverable_name.split()):
                return True
    
    return False

@work_items_bp.route('/<int:work_item_id>/tasks/<int:task_id>')
def work_item_task_detail(work_item_id: int, task_id: int):
    """
    Redirect to the main task detail view.
    
    This ensures consistency and avoids code duplication.
    The task detail view will handle all the task information display.
    """
    # Verify the task exists and belongs to the work item
    db = get_database_service()
    from ...core.database.methods import tasks as task_methods, work_items as wi_methods
    
    task = task_methods.get_task(db, task_id)
    work_item = wi_methods.get_work_item(db, work_item_id)
    
    if not task:
        abort(404, description=f"Task {task_id} not found")
    
    if not work_item:
        abort(404, description=f"Work item {work_item_id} not found")
    
    # Verify the task belongs to this work item
    if task.work_item_id != work_item_id:
        abort(404, description=f"Task {task_id} does not belong to work item {work_item_id}")
    
    # Redirect to the main task detail route
    return redirect(url_for('tasks.task_detail', task_id=task_id))

@work_items_bp.route('/create', methods=['GET', 'POST'])
def create_work_item():
    """Create a new work item"""
    if request.method == 'GET':
        # Show create form
        db = get_database_service()
        from ...core.database.methods import projects, ideas
        from ...core.database.enums import WorkItemType, WorkItemStatus
        
        projects_list = projects.list_projects(db) or []
        ideas_list = ideas.list_ideas(db) or []
        
        return render_template('work-items/create.html',
                             projects=projects_list,
                             ideas=ideas_list,
                             work_item_types=WorkItemType,
                             work_item_statuses=WorkItemStatus)
    
    elif request.method == 'POST':
        # Process form submission
        try:
            db = get_database_service()
            from ...core.database.methods import work_items
            from ...core.database.models import WorkItem
            from ...core.database.enums import WorkItemType, WorkItemStatus
            
            # Get form data
            name = request.form.get('name', '').strip()
            description = request.form.get('description', '').strip()
            work_item_type = request.form.get('type', 'feature')
            business_context = request.form.get('business_context', '').strip()
            priority = int(request.form.get('priority', 3))
            effort_estimate = request.form.get('effort_estimate')
            effort_estimate_hours = float(effort_estimate) if effort_estimate else None
            project_id = int(request.form.get('project_id', 1))
            originated_from_idea_id = request.form.get('originated_from_idea_id')
            originated_from_idea_id = int(originated_from_idea_id) if originated_from_idea_id else None
            
            # Validate required fields
            if not name:
                flash('Work item name is required', 'error')
                return redirect(url_for('work_items.create_work_item'))
            
            # Create work item
            work_item = WorkItem(
                name=name,
                description=description if description else None,
                type=WorkItemType(work_item_type),
                business_context=business_context if business_context else None,
                priority=priority,
                effort_estimate_hours=effort_estimate_hours,
                project_id=project_id,
                originated_from_idea_id=originated_from_idea_id,
                status=WorkItemStatus.DRAFT
            )
            
            created_work_item = work_items.create_work_item(db, work_item)
            
            flash(f'Work item "{created_work_item.name}" created successfully', 'success')
            return redirect(url_for('work_items.work_item_detail', work_item_id=created_work_item.id))
            
        except Exception as e:
            logger.error(f"Error creating work item: {e}")
            flash(f'Error creating work item: {str(e)}', 'error')
            return redirect(url_for('work_items.create_work_item'))

@work_items_bp.route('/<int:work_item_id>/edit', methods=['GET', 'POST'])
def edit_work_item(work_item_id: int):
    """Edit an existing work item"""
    db = get_database_service()
    from ...core.database.methods import work_items, projects, ideas
    from ...core.database.enums import WorkItemType, WorkItemStatus
    
    work_item = work_items.get_work_item(db, work_item_id)
    if not work_item:
        abort(404, description=f"Work item {work_item_id} not found")
    
    if request.method == 'GET':
        # Show edit form
        projects_list = projects.list_projects(db) or []
        ideas_list = ideas.list_ideas(db) or []
        
        return render_template('work-items/edit.html',
                             work_item=work_item,
                             projects=projects_list,
                             ideas=ideas_list,
                             work_item_types=WorkItemType,
                             work_item_statuses=WorkItemStatus)
    
    elif request.method == 'POST':
        # Process form submission
        try:
            # Get form data
            name = request.form.get('name', '').strip()
            description = request.form.get('description', '').strip()
            work_item_type = request.form.get('type', 'feature')
            business_context = request.form.get('business_context', '').strip()
            priority = int(request.form.get('priority', 3))
            effort_estimate = request.form.get('effort_estimate')
            effort_estimate_hours = float(effort_estimate) if effort_estimate else None
            status = request.form.get('status', 'draft')
            project_id = int(request.form.get('project_id', 1))
            originated_from_idea_id = request.form.get('originated_from_idea_id')
            originated_from_idea_id = int(originated_from_idea_id) if originated_from_idea_id else None
            
            # Validate required fields
            if not name:
                flash('Work item name is required', 'error')
                return redirect(url_for('work_items.edit_work_item', work_item_id=work_item_id))
            
            # Update work item
            work_item.name = name
            work_item.description = description if description else None
            work_item.type = WorkItemType(work_item_type)
            work_item.business_context = business_context if business_context else None
            work_item.priority = priority
            work_item.effort_estimate_hours = effort_estimate_hours
            work_item.status = WorkItemStatus(status)
            work_item.project_id = project_id
            work_item.originated_from_idea_id = originated_from_idea_id
            
            updated_work_item = work_items.update_work_item(db, work_item)
            
            flash(f'Work item "{updated_work_item.name}" updated successfully', 'success')
            return redirect(url_for('work_items.work_item_detail', work_item_id=updated_work_item.id))
            
        except Exception as e:
            logger.error(f"Error updating work item: {e}")
            flash(f'Error updating work item: {str(e)}', 'error')
            return redirect(url_for('work_items.edit_work_item', work_item_id=work_item_id))

@work_items_bp.route('/<int:work_item_id>/delete', methods=['POST'])
def delete_work_item(work_item_id: int):
    """Delete a work item"""
    try:
        db = get_database_service()
        from ...core.database.methods import work_items
        
        work_item = work_items.get_work_item(db, work_item_id)
        if not work_item:
            abort(404, description=f"Work item {work_item_id} not found")
        
        work_items.delete_work_item(db, work_item_id)
        
        flash(f'Work item "{work_item.name}" deleted successfully', 'success')
        return redirect(url_for('work_items.work_items_list'))
        
    except Exception as e:
        logger.error(f"Error deleting work item: {e}")
        flash(f'Error deleting work item: {str(e)}', 'error')
        return redirect(url_for('work_items.work_item_detail', work_item_id=work_item_id))

@work_items_bp.route('/<int:work_item_id>/update-status', methods=['POST'])
def update_work_item_status(work_item_id: int):
    """Update work item status via AJAX"""
    try:
        db = get_database_service()
        from ...core.database.methods import work_items
        from ...core.database.enums import WorkItemStatus
        
        work_item = work_items.get_work_item(db, work_item_id)
        if not work_item:
            return jsonify({'error': 'Work item not found'}), 404
        
        new_status = request.json.get('status')
        if not new_status:
            return jsonify({'error': 'Status is required'}), 400
        
        try:
            work_item.status = WorkItemStatus(new_status)
        except ValueError:
            return jsonify({'error': 'Invalid status'}), 400
        
        updated_work_item = work_items.update_work_item(db, work_item)
        
        return jsonify({
            'success': True,
            'status': updated_work_item.status.value,
            'message': f'Status updated to {updated_work_item.status.value}'
        })
        
    except Exception as e:
        logger.error(f"Error updating work item status: {e}")
        return jsonify({'error': str(e)}), 500
