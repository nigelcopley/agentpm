"""
OpenAI Codex Generator with Jinja2 Template System

Generates OpenAI Codex configuration files from APM database entities.
Codex natively reads AGENTS.md, so we only need to generate .codex/config.toml.

Key Insight: Codex already supports AGENTS.md natively through project_doc_fallback_filenames.
We don't need to transform or rewrite AGENTS.md - Codex reads it directly!

Architecture:
- CodexGenerator: Main generator class implementing BaseProviderGenerator
- TemplateBasedMixin: Jinja2 template rendering support
- config.toml.j2: Codex configuration with profiles and sandbox settings
- codexignore.j2: Exclusion patterns using CommonExclusions.CODEX

Pattern: Template Method Pattern with Strategy Pattern for rendering
"""

from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime
import sys

# Python 3.11+ has tomllib built-in, older versions need tomli
if sys.version_info >= (3, 11):
    import tomllib
else:
    try:
        import tomli as tomllib
    except ImportError:
        tomllib = None

from agentpm.core.database.service import DatabaseService
from agentpm.core.database.models.agent import Agent
from agentpm.core.database.models.rule import Rule
from agentpm.core.database.models.project import Project
from agentpm.providers.base import (
    BaseProviderGenerator,
    TemplateBasedMixin,
    GenerationResult,
    FileOutput
)
from agentpm.providers.common import CommonExclusions


class CodexGenerator(BaseProviderGenerator, TemplateBasedMixin):
    """
    OpenAI Codex configuration generator using Jinja2 templates.

    Generates provider-native configuration from APM database:
    - AGENTS.md: Used natively by Codex (no transformation needed!)
    - .codex/config.toml: Codex configuration with profiles and sandbox settings
    - .codex/.codexignore: Exclusion patterns

    Key Difference from Claude Code:
    - Claude Code: Transforms AGENTS.md â†’ CLAUDE.md + individual agent files
    - Codex: Uses AGENTS.md directly + generates config.toml only

    Design Principles:
    - Minimal transformation: Codex reads AGENTS.md natively
    - Template-driven: Configuration in Jinja2 templates
    - Database-first: All data from database, not files
    - Single Responsibility: Each method has one clear purpose

    Example:
        >>> db = DatabaseService("path/to/db")
        >>> generator = CodexGenerator(db)
        >>> result = generator.generate_from_agents(
        ...     agents=db.list_agents(),
        ...     rules=db.list_rules(),
        ...     project=db.get_project(),
        ...     output_dir=Path("/project")
        ... )
        >>> print(f"Generated {len(result.files)} files")
    """

    def __init__(self, db_service: DatabaseService):
        """
        Initialize Codex generator.

        Args:
            db_service: Database service for accessing APM data

        Raises:
            FileNotFoundError: If template directory doesn't exist
            ImportError: If jinja2 is not installed
        """
        self.db = db_service

        # Initialize Jinja2 templates
        template_dir = Path(__file__).parent / "templates"
        self._init_templates(template_dir)

        # Register custom filters
        self._register_custom_filters()

    @property
    def provider_name(self) -> str:
        """Provider identifier."""
        return "codex"

    @property
    def config_directory(self) -> str:
        """Native configuration directory."""
        return ".codex"

    def generate_from_agents(
        self,
        agents: List[Agent],
        rules: List[Rule],
        project: Project,
        output_dir: Path,
        **kwargs
    ) -> GenerationResult:
        """
        Generate Codex configuration files from database entities.

        Creates the following structure:
        - output_dir/AGENTS.md (already exists - generated by memory/generator.py)
        - output_dir/.codex/config.toml (Codex configuration)
        - output_dir/.codex/.codexignore (exclusion patterns)

        Args:
            agents: Flat list of all agents from database
            rules: All active rules from database
            project: Project metadata
            output_dir: Project root directory
            **kwargs: Optional parameters:
                - include_ignore (bool): Generate .codexignore (default: True)
                - model (str): Default model (default: "gpt-5-codex")
                - approval_policy (str): Approval policy (default: "on-request")

        Returns:
            GenerationResult with success status, files, and statistics

        Example:
            >>> result = generator.generate_from_agents(
            ...     agents=[agent1, agent2],
            ...     rules=[rule1, rule2],
            ...     project=project,
            ...     output_dir=Path("/project"),
            ...     model="gpt-5-codex"
            ... )
        """
        errors: List[str] = []
        files: List[FileOutput] = []
        stats: Dict[str, Any] = {
            "config_generated": False,
            "ignore_generated": False,
            "rules_included": len(rules),
            "duration_ms": 0,
            "generation_time": datetime.utcnow().isoformat()
        }

        start_time = datetime.utcnow()

        try:
            # Create .codex directory
            codex_dir = output_dir / self.config_directory
            codex_dir.mkdir(parents=True, exist_ok=True)

            # 1. Verify AGENTS.md exists (required by Codex)
            agents_md = output_dir / "AGENTS.md"
            if not agents_md.exists():
                errors.append(
                    "AGENTS.md not found. Run 'apm memory generate' to create it. "
                    "Codex requires AGENTS.md for project context."
                )

            # 2. Generate config.toml
            try:
                config_file = self._generate_config_toml(
                    agents=agents,
                    rules=rules,
                    project=project,
                    output_dir=codex_dir,
                    **kwargs
                )
                files.append(config_file)
                stats["config_generated"] = True
            except Exception as e:
                errors.append(f"config.toml generation failed: {e}")

            # 3. Generate .codexignore (optional)
            if kwargs.get("include_ignore", True):
                try:
                    ignore_file = self._generate_codexignore(
                        project=project,
                        output_dir=codex_dir
                    )
                    files.append(ignore_file)
                    stats["ignore_generated"] = True
                except Exception as e:
                    errors.append(f".codexignore generation failed: {e}")

            # Calculate duration
            duration = (datetime.utcnow() - start_time).total_seconds() * 1000
            stats["duration_ms"] = int(duration)

            return GenerationResult(
                success=len(errors) == 0,
                files=files,
                errors=errors,
                statistics=stats
            )

        except Exception as e:
            errors.append(f"Generation failed: {e}")
            return GenerationResult(
                success=False,
                files=files,
                errors=errors,
                statistics=stats
            )

    def validate_config(self, config_dir: Path) -> List[str]:
        """
        Validate existing Codex configuration.

        Checks:
        - .codex directory exists
        - AGENTS.md exists in parent directory (required by Codex)
        - config.toml exists and is valid TOML
        - Required sections exist in config.toml

        Args:
            config_dir: Path to .codex directory

        Returns:
            List of validation error messages (empty if valid)

        Example:
            >>> errors = generator.validate_config(Path("/project/.codex"))
            >>> if errors:
            ...     print(f"Configuration errors: {errors}")
        """
        errors: List[str] = []

        # Check .codex directory exists
        if not config_dir.exists():
            errors.append(f"Configuration directory not found: {config_dir}")
            return errors

        if not config_dir.is_dir():
            errors.append(f"Configuration path is not a directory: {config_dir}")
            return errors

        # Check AGENTS.md in parent directory (required by Codex)
        agents_md = config_dir.parent / "AGENTS.md"
        if not agents_md.exists():
            errors.append(
                f"AGENTS.md not found at: {agents_md}. "
                "Codex requires AGENTS.md for project context. "
                "Run 'apm memory generate' to create it."
            )

        # Check config.toml exists
        config_toml = config_dir / "config.toml"
        if not config_toml.exists():
            errors.append(f"config.toml not found at: {config_toml}")
            return errors

        # Validate config.toml is valid TOML
        try:
            if tomllib is None:
                raise ImportError("tomllib/tomli not available")
            with open(config_toml, "rb") as f:
                config = tomllib.load(f)

            # Check required fields
            if "model" not in config:
                errors.append("config.toml missing required field: model")

            if "approval_policy" not in config:
                errors.append("config.toml missing required field: approval_policy")

            # Check profiles exist
            if "profiles" not in config:
                errors.append("config.toml missing [profiles] section")

        except ImportError:
            errors.append(
                "tomllib/tomli package required for TOML validation. "
                "Python 3.11+ has built-in tomllib. For Python 3.10 and earlier: pip install tomli"
            )
        except Exception as e:
            errors.append(f"Invalid config.toml: {e}")

        return errors

    def format_context(
        self,
        project: Project,
        work_item: Optional[Any],
        task: Optional[Any]
    ) -> str:
        """
        Format APM context for real-time updates in Codex format.

        Creates a markdown-formatted context block for injection into
        Codex sessions. This can be appended to AGENTS.md or provided
        as a separate context file.

        Args:
            project: Project metadata
            work_item: Optional current work item
            task: Optional current task

        Returns:
            Formatted markdown context string

        Example:
            >>> context = generator.format_context(project, work_item, task)
            >>> print(context)
            ## Current Context
            - Project: MyApp
            - Work Item: #123 - Implement feature X
            - Task: #456 - Write unit tests
        """
        lines = []
        lines.append("## Current Context")
        lines.append("")
        lines.append(f"**Project**: {project.name}")
        lines.append(f"**Status**: {project.status.value}")
        lines.append("")

        if work_item:
            lines.append("**Current Work Item**:")
            lines.append(f"- ID: {work_item.id}")
            lines.append(f"- Name: {work_item.name}")
            lines.append(f"- Type: {work_item.type.value}")
            lines.append(f"- Status: {work_item.status.value}")
            lines.append(f"- Phase: {work_item.phase.value if work_item.phase else 'None'}")
            lines.append("")

        if task:
            lines.append("**Current Task**:")
            lines.append(f"- ID: {task.id}")
            lines.append(f"- Name: {task.name}")
            lines.append(f"- Type: {task.type.value}")
            lines.append(f"- Status: {task.status.value}")
            lines.append("")

        return "\n".join(lines)

    # ========================================================================
    # Private Generation Methods
    # ========================================================================

    def _generate_config_toml(
        self,
        agents: List[Agent],
        rules: List[Rule],
        project: Project,
        output_dir: Path,
        **kwargs
    ) -> FileOutput:
        """
        Generate config.toml for Codex.

        Contains:
        - Model configuration
        - Approval policy
        - Sandbox mode settings
        - Shell environment policy
        - APM-specific profiles (planning, implementation, testing)
        - OpenTelemetry configuration

        Args:
            agents: All agents from database
            rules: All active rules
            project: Project metadata
            output_dir: .codex directory path
            **kwargs: Optional configuration overrides

        Returns:
            FileOutput with config.toml metadata
        """
        # Extract configuration from kwargs with sensible defaults
        model = kwargs.get("model", "gpt-5-codex")
        approval_policy = kwargs.get("approval_policy", "on-request")
        sandbox_mode = kwargs.get("sandbox_mode", "workspace-write")

        # Render template
        context = {
            "project": project,
            "agents": agents,
            "rules": rules,
            "model": model,
            "approval_policy": approval_policy,
            "sandbox_mode": sandbox_mode,
            "generation_time": datetime.utcnow().isoformat()
        }

        content = self._render_template("config.toml.j2", context)

        # Write file
        output_path = output_dir / "config.toml"
        output_path.write_text(content)

        return FileOutput.create_from_content(output_path, content)

    def _generate_codexignore(
        self,
        project: Project,
        output_dir: Path
    ) -> FileOutput:
        """
        Generate .codexignore file with exclusion patterns.

        Uses CommonExclusions.CODEX patterns plus project-specific patterns.

        Args:
            project: Project metadata
            output_dir: .codex directory path

        Returns:
            FileOutput with .codexignore metadata
        """
        # Get standard exclusions for Codex
        exclusions = CommonExclusions.CODEX

        # Render template
        context = {
            "project": project,
            "exclusions": exclusions,
            "generation_time": datetime.utcnow().isoformat()
        }

        content = self._render_template("codexignore.j2", context)

        # Write file
        output_path = output_dir / ".codexignore"
        output_path.write_text(content)

        return FileOutput.create_from_content(output_path, content)

    # ========================================================================
    # Helper Methods
    # ========================================================================

    def _register_custom_filters(self) -> None:
        """
        Register Codex-specific Jinja2 filters.

        Currently uses only base filters from TemplateBasedMixin.
        Override to add custom filters if needed.
        """
        super()._register_custom_filters()
        # No Codex-specific filters needed yet
